# KeyPath Codebase Review & Improvement Plan

*Generated by RepoPrompt analysis focusing on clarity, performance, organization, and understandability*

## Executive Summary

The project has a solid foundation: clearly named contracts in Core/Contracts, a Wizard UI built from composable views, and a dedicated LaunchDaemon installer. However, core service code (especially KanataManager and LaunchDaemonInstaller) has grown monolithic and duplicates concerns (admin prompting, process control, diagnostics, path handling, log analysis). Singletons and global state complicate testing and composition. Several hot-path operations block the main thread (osascript, Process.waitUntilExit), and shell execution is fragile (quoting issues for file content).

**Focus improvements on**: decomposition, unification of cross-cutting concerns (admin command execution, process running, logging), stricter concurrency boundaries, safer shell operations, and consistent dependency injection. Convert dev-only hard-coded paths to environment or build-config-driven settings.

## 1. Code Organization

### Observations
- **Good**: Core/Contracts defines cohesive protocols; Wizard UI is well-structured into Components/Pages; EventRouter separates processors; PreferencesService centralizes comms config.
- **Needs improvement**: KanataManager contains service control, config I/O, diagnostics, permissions glue, admin interactions, process lifecycle, UDP control. LaunchDaemonInstaller contains multiple similar installer flows. Admin command execution (osascript/Authorization Services) and Process launching are reimplemented in multiple places. Paths/constants are defined in multiple files.

### Actionable Reorganization Plan

#### A. Extract cross-cutting services into dedicated modules/classes

**Create Administration/AdminTaskRunner.swift**
- **Responsibility**: single API to run privileged operations using the preferred mechanism (Authorization Services preferred, with osascript fallback), properly quoted and robust.
- **Replace**: scattered NSAppleScript and osascript Process uses.
- **Example API**:
  ```swift
  class AdminTaskRunner {
      func runShell(commands: [String], prompt: String, requireMainThreadForDialog: Bool = true) async throws -> AdminResult
  }
  struct AdminResult { let stdout: String; let stderr: String; let exitCode: Int32 }
  ```
- **Files to modify**:
  - `InstallationWizard/Core/LaunchDaemonInstaller.swift`
    - Methods using osascript: `executeWithAdminPrivileges(...)`, `executeAllWithAdminPrivileges(...)`, `executeConsolidatedInstallation*`, `restartServicesWithAdmin`, `reloadService(...)`
    - Replace internal AppleScript/Process codepaths with `AdminTaskRunner.runShell(...)`
  - `InstallationWizard/Core/VHIDDeviceManager.swift`
    - `executeWithAdminPrivileges(command:description:)` → delegate to AdminTaskRunner
  - `Managers/KanataManager.swift`
    - `startLaunchDaemonService()`, `stopLaunchDaemonService()`, `prepareDaemonDirectories()`, `disableKarabinerElementsPermanently()`, `killAllKanataProcesses()`, `restartKarabinerDaemon()`

**Create Infrastructure/Processes/ProcessRunner.swift**
- **Responsibility**: standardize spawning child processes with timeout, capturing stdout/stderr, environment, and error handling. Avoid blocking main thread.
- **Example API**:
  ```swift
  struct ProcessSpec { let path: String; let args: [String]; let timeout: TimeInterval? }
  final class ProcessRunner {
      func run(_ spec: ProcessSpec) async throws -> ProcessResult
  }
  struct ProcessResult { let stdout: String; let stderr: String; let exitCode: Int32 }
  ```
- **Replace repeated Process usage**:
  - LaunchDaemonInstaller (launchctl, cp, chmod, codesign)
  - VHIDDeviceManager (pgrep/tail)
  - KanataManager (launchctl, pgrep, codesign, tail, sqlite3, etc.)
  - PackageManager (brew, codesign, kanata --version)
  - SystemStatusChecker & DiagnosticsView where shell commands are invoked

**Create Infrastructure/Logging/LoggerAdapter.swift**
- **Responsibility**: adapt AppLogger to the Core/Contracts Logging protocol; unify logging; eliminate direct AppLogger usages from most code.
- **Example**:
  ```swift
  final class LoggerAdapter: Logging { init(destinationConfig: LoggingConfiguration = .default) }
  ```
- Provide a singleton only in the composition root; inject Logging where needed.

#### B. Decompose KanataManager by responsibility

**New classes/files** (move code out of KanataManager; keep a thin facade that orchestrates):
- **Services/KanataServiceController.swift**
  - Start/stop/restart service (launchctl), warm-up window detection, PID registration calls to ProcessLifecycleManager.
  - Example signatures:
    ```swift
    func startService() async throws -> ServiceStartInfo
    func stopService() async throws
    func restartService() async throws
    ```
- **Configuration/KanataConfigController.swift**
  - Wraps ConfigurationService operations; owns "saveValidatedConfig", "backupFailedConfigAndApplySafe", "validateGeneratedConfig", and "parseKanataConfig".
  - Return richer error types (e.g., enum ConfigSaveError).
- **Diagnostics/KanataDiagnosticsAnalyzer.swift**
  - Extracts analyzeKanataFailure, log-based diagnosis, connection failure detection.
- **Monitoring/LogMonitorActor.swift** (actor)
  - Tail /var/log/kanata.log with incremental offsets; emits events to subscribers; replaces ad-hoc monitoring in KanataManager.

**Update KanataManager**
- Keep published UI-facing state; depend on the above services via init injection.
- Files to modify: `Managers/KanataManager.swift` (+ its extensions) to delegate to new services.
- Side effects: simplify testing, clearer error boundaries, reduce file size and complexity.

#### C. Unify path constants and remove duplication

- WizardSystemPaths is the single source-of-truth. Ensure KanataManager.buildKanataArguments, LaunchDaemonInstaller, PackageManager, DiagnosticsView all use WizardSystemPaths rather than inlined paths.
- Add helper methods to WizardSystemPaths for launchd identifiers and log paths; eliminate hard-coded strings across the codebase.

#### D. Strengthen file watching

- Replace the ConfigurationService private FileWatcher with a resilient watcher:
  - Monitor the directory rather than only the file; on rename/delete, re-open and continue.
  - Consider using FSEvents for robustness if frequent renames occur.
  - Update `Sources/KeyPath/Infrastructure/Config/ConfigurationService.swift`
    - Replace `startFileMonitoring()` internals
    - Side effect: fewer missed updates on rename; must ensure token cancellation reinitializes correctly.

#### E. Composition root and DI

- In App.swift, build and inject shared instances: LoggerAdapter (as Logging), ProcessRunner, AdminTaskRunner, KanataServiceController, KanataConfigController, etc.
- Replace singletons in dependent classes with injected protocols where feasible:
  - PreferencesService stays shared (UI settings), but pass snapshot to services.
  - PermissionOracle can remain a shared actor; wrap it in a protocol for easier mocking if needed.

## 2. Clarity & Readability

### Observations
- Many methods are long and contain imperative scripts; multiple "improved"/"consolidated" variants exist in LaunchDaemonInstaller; heavy logging obscures intent; inconsistent naming (e.g., "createConfigureAndLoadAllServices" vs "executeConsolidatedInstallationImproved").
- Protocols in Core/Contracts are clear and documented; good.

### Recommendations

**Rename and collapse similarly purposed methods**
- **LaunchDaemonInstaller**
  - **Replace**: `createAllLaunchDaemonServices`, `createConfigureAndLoadAllServices`, `executeConsolidatedInstallation*`, `executeAllWithAdminPrivileges`
  - **With explicit, minimal API**:
    ```swift
    func installAllServices() async throws
    func loadAllServices() async throws
    func repairVHIDServices() async throws
    func regenerateKanataServicePlist() async throws
    ```
  - Internals use AdminTaskRunner. Remove in-method AppleScript construction.

**Reduce logging verbosity in hot paths; promote log levels**
- Adopt LogLevel and pass logger with min-level; change many `AppLogger.shared.log` to `logger.debug/info/warning/error`.
- Example: EventRouter "Added processor", "Cleared all processors" can be at debug level only. KanataManager.startKanata logs numerous lines that can be coalesced and moved to diagnostics level.

**Extract script content builders to helpers**
- For shell command generation (e.g., log rotation plist/script), move content builders to dedicated types so the main method body reads as a short orchestration.
- Example:
  ```swift
  struct LogRotationAssetsBuilder { func script() -> String; func plist() -> String }
  ```

**Document non-obvious constraints with short "why" comments**
- KeyboardCapture: explain why `.listenOnly` vs `.defaultTap` is used, and ADR reference for single tap constraint.
- LaunchDaemonInstaller: explain warm-up window logic and service health detection heuristics.

**Avoid generic names** like `executeConsolidatedInstallationImproved`; prefer `installAllServicesWithSinglePrompt` and move "improved" detail to doc comment.

## 3. Performance

### Observations
- **Blocking main thread**: Several osascript and Process.waitUntilExit calls can block UI. Some are already dispatching to background, but not consistently. `executeOSAScriptOnMainThread` is used incorrectly in places where we could avoid main thread.
- **Repeated whole-file log reads** (e.g., `analyzeKanataLogs` reads entire `/var/log/kanata.log`). DiagnosticsView shells out to sqlite3 every refresh.
- **ConfigurationService "FileWatcher"** does not re-open file after rename, and `open(…O_RDONLY)` on the file will stop delivering events after rename; can lose updates.

### Recommendations

**Always run external processes off the main thread via ProcessRunner**
- Provide `await run(spec)` with timeout; present admin dialogs on main only when strictly necessary.

**Replace full log reads with bounded tails**
- Use `tail -n` with ProcessRunner or a streaming FileHandle that keeps an offset.
- Update:
  - `KanataManager.analyzeKanataLogs()`: shell out `tail -n 200` or maintain incremental offsets via LogMonitorActor.

**Switch KeyboardCapture event tap to `.listenOnly` for non-recording paths**
- For "record one key" capture, suppressing keydown by returning nil is okay since you want to prevent system beeps, but ensure this path is not active while Kanata is running. Already gated; keep as is.

**Improve FileWatcher robustness** (see organization D)

**Avoid reconstructing Process and NSRegularExpression in tight loops**; precompile regex or cache in helper types where repeatedly used (service health parsing).

## 4. Architecture

### Observations
- **Good**: Protocols for contracts; EventProcessing chain; Wizard navigation engine; PermissionOracle centralizes permission state.
- **Gaps**: Singletons and globals (`AppLogger.shared`, `PermissionOracle.shared`, `defaultEventRouter`, `PreferencesService.shared`) make composition and testing harder. KanataManager aggregates many concerns.

### Recommendations

**Adopt a Composition Root pattern and DI at App.swift**
- Instantiate and share core services via explicit initializers; pass protocol-conformant instances to dependents (e.g., `KanataServiceControlling`, `ProcessRunning`, `Logging`).
- Example: `KeyPathApp.init()` builds a container struct; subviews and managers use Environment or explicit init params.

**Make LaunchDaemonInstaller stateless** or explicitly inject ProcessRunner/AdminTaskRunner instead of doing Process in methods.

**Wrap PermissionOracle in a protocol** to support fake snapshots for UI previews/tests:
```swift
protocol PermissionSnapshotProviding { func currentSnapshot() async -> PermissionOracle.Snapshot }
```

**Event router safety and clarity**
- Remove do/catch in `EventRouter.route()` since `EventProcessing.process` is not throwing.
- Replace `dummy CGEventTapProxy(bitPattern: 0)!` uses with safely defaulted proxy parameters (or overload that doesn't require proxy).

**Normalize timeouts, warm-up windows, and retry policies**
- Create a `ServicePolicy` configuration (struct) with constants and inject it (e.g., warmupWindow, restartTimeouts, pollInterval).

## 5. Best Practices (Swift/SwiftUI, Safety)

### Observations
- Many shell/AppleScript invocations interpolate untrusted content into quoted strings, especially echo of config content into privileged file paths. This is brittle and can break with quotes/newlines; security hazard.
- Several `NSAlert.runModal` used inside SwiftUI view actions; acceptable but consider SwiftUI alerts for consistency and accessibility where possible.
- Hard-coded dev paths for logs (e.g., AppLogger logs to `/Volumes/FlashGordon/…`); WizardLogger also points to dev path.

### Recommendations

**Never inject raw content into shell echo; write temp file and move with sudo**
- Replace code like in `WizardAutoFixer.synchronizeConfigPaths`:
  - **Current (problematic)**: `echo '<content>' > '/path'`
  - **Replacement**:
    ```swift
    let tmp = write content to temporary path as current user
    AdminTaskRunner.runShell(["install", "-m", "0644", tmp, finalPath, "&&", "chown", "root:wheel", finalPath], prompt: "…")
    // Then unlink temp
    ```
- **Files to modify**:
  - `InstallationWizard/Core/WizardAutoFixer.swift` (synchronizeConfigPaths)
  - Any other site that uses echo to write privileged files
- **Side effects**: Fixes quoting bugs and improves security.

**Convert AppLogger hard-coded directory to standard location with build-config override**
- In `Logger.swift`:
  - Default to `~/Library/Logs/KeyPath`
  - Allow `DEV_LOG_DIR` override via environment variable or compile flags. Avoid the mount-dependent path.
- WizardLogger: same.

**Replace direct NSAlert where possible with SwiftUI alerts in views**
- For simple confirmation flows in wizard pages (open settings/help), use `.alert` with state.
- Keep NSAlert where you need AppKit-only patterns (e.g., customized AppleScript prompt interplay), but isolate inside service layer, not in views.

**Access control**: mark only externally used APIs as public, keep internals internal; align protocol visibility with usage.

**Concurrency annotations**
- For types with shared mutable state across threads (e.g., `LaunchDaemonInstaller.lastKickstartTimes`), move to an actor or guard with synchronization.
- Example:
  ```swift
  actor ServiceWarmupTracker { 
      private var restartTimes: [String: Date]
      func mark(_:) …
      func wasRecentlyRestarted(_:) -> Bool 
  }
  ```
- Inject into LaunchDaemonInstaller instead of static vars.

## Concrete Changes with Locations, Signatures, and Side Effects

### 1) Introduce AdminTaskRunner (new)
- **File**: `Sources/KeyPath/Infrastructure/Admin/AdminTaskRunner.swift`
- **Signature**:
  ```swift
  final class AdminTaskRunner {
      init(processRunner: ProcessRunner, logger: Logging)
      func runShell(_ script: String, prompt: String, requireMainThread: Bool = true) async throws -> AdminResult
      func runCommands(_ commands: [String], prompt: String) async throws -> AdminResult
  }
  ```
- **Replace**:
  - `LaunchDaemonInstaller.executeWithAdminPrivileges(...)` → `admin.runCommands`
  - `LaunchDaemonInstaller.executeAllWithAdminPrivileges(...)` → `admin.runCommands`
  - `LaunchDaemonInstaller.executeConsolidatedInstallation*` → `admin.runShell` with prepared script path
  - `VHIDDeviceManager.executeWithAdminPrivileges` → `admin.runCommands`
  - `KanataManager.*` methods that use osascript → `admin.runCommands`
- **Side effects**: unify prompting, reduce duplicated AppleScript codepaths, better error capture; ensure prompts occur on main.

### 2) Introduce ProcessRunner (new)
- **File**: `Sources/KeyPath/Infrastructure/Process/ProcessRunner.swift`
- **Signature**: as above; supports timeouts.
- **Replace every Process usage**:
  - Use `ProcessRunner.run(spec)` to avoid `waitUntilExit` blocking UI; add timeouts to commands like `launchctl print` and brew operations.
- **Side effects**: consistent error handling; easy to add metrics around process calls.

### 3) Secure file writing of privileged content
- **File**: `WizardAutoFixer.synchronizeConfigPaths` (`InstallationWizard/Core/WizardAutoFixer.swift`)
  - Replace AppleScript echo approach with:
    - Write to tmp file (`Data.write`) as current user
    - `AdminTaskRunner.runCommands(["install -m 0644 '\(tmp)\' '\(systemConfigPath)'", "chown root:wheel '\(systemConfigPath)'"], prompt: "...")` 
- Also review: LaunchDaemonInstaller plist/script installs; use `install(1)` instead of `cp + chmod + chown` sequences when possible.

### 4) Decompose KanataManager (multiple new files)
- **Files to add**:
  - `Services/KanataServiceController.swift`
    - `func start() async throws`, `func stop() async throws`, `func restart() async throws`
  - `Configuration/KanataConfigController.swift`
    - `func save(mappings:) async throws`; `func validate(config:) async -> Validation`; `func backupFailedAndApplySafe(...)`
  - `Diagnostics/KanataDiagnosticsAnalyzer.swift`
    - `func analyzeExit(exitCode:Int32, output:String) -> [KanataDiagnostic]`
  - `Monitoring/LogMonitorActor.swift` (actor)
    - `func start()`, `stop()`, `subscribe(callback:)`
- KanataManager to delegate; remove Process and AppleScript logic from it.
- **Side effects**: simplifies KanataManager and improves separation of concerns.

### 5) Event router cleanup
- **File**: `Core/Events/EventRouter.swift`
  - Remove do/catch inside route loop, since `EventProcessing.process` is non-throwing.
  - Replace dummyProxy force unwrap in convenience `route(event:scope:)` by:
    ```swift
    let proxy = CGEventTapProxy(bitPattern: 0) ?? .init(OpaquePointer(bitPattern: 0)!)
    ```
  - Or better, overload `EventProcessing.process(event:)` already exists; call that to avoid proxy entirely.
  - Provide a non-blocking comparison in `eventsEqual` if needed; consider comparing more fields when necessary.

### 6) File watcher robustness
- **File**: `Infrastructure/Config/ConfigurationService.swift` (FileWatcher)
  - Watch the directory; on `.rename/.delete`, re-open the file descriptor with `open(O_EVTONLY)`.
  - Or replace with FSEvents-based watcher for the directory.
  - Ensure `startFileMonitoring` returns a token that stops and closes descriptors properly.
- **Side effects**: fewer missed reloads when files are rotated or replaced.

### 7) Logging unification
- **File**: `Utilities/Logger.swift` & `Core/Contracts/Logging.swift`
  - Add LoggerAdapter to implement Logging protocol, configure level and destination.
  - Replace `AppLogger.shared.log()` usage across code with injected Logging where feasible. Keep AppLogger for low-level file rotation if desired, but hide behind adapter.
  - Remove hard-coded dev path in Logger and WizardLogger; default to `~/Library/Logs/KeyPath`; allow override via environment.

### 8) Shell and admin flows naming and simplification
- **File**: `InstallationWizard/Core/LaunchDaemonInstaller.swift`
  - **Rename**:
    - `createConfigureAndLoadAllServices()` → `installAllServicesWithSinglePrompt()`
    - `executeConsolidatedInstallationImproved(...)` → `installAllServicesWithScript()`
  - Use AdminTaskRunner + ProcessRunner.
  - Move warm-up tracking to ServiceWarmupTracker actor.
- **Side effects**: clearer installer surface area; easier recovery flows.

### 9) DiagnosticsView cleanup
- **File**: `UI/DiagnosticsView.swift`
  - Remove direct sqlite3 TCC access (system db is protected); rely on PermissionOracle snapshot for display; add "Full Disk Access recommended" messaging where necessary.
  - Offload shell work (codesign, launchctl, tail) to a background queue via ProcessRunner.

### 10) Permissions oracle consistency
- Ensure all pages (Wizard*Page, ContentView overlays) query PermissionOracle for status; remove redundant PermissionService calls and heuristics in views (e.g., EnhancedStatusSection.sqlite3 probe).

## Critical Architectural Decisions to Make

- **Admin elevation strategy**: Prefer Authorization Services for reliability in a sandboxed GUI app; keep an osascript fallback behind AdminTaskRunner. This reduces app store-suspect script prompts and improves UX.
- **Single canonical Kanata binary path**: Already centralized in WizardSystemPaths. Continue using bundled Developer ID signed binary exclusively to avoid TCC fragmentation.
- **Single event tap policy (ADR-006)**: Maintain one event producer at a time. KeyboardCapture should remain disabled when Kanata is running and use `.listenOnly` for emergency monitoring.
- **Composition root**: Build and inject services in App.swift; minimize singletons to PermissionOracle (actor) and UI Environment objects.

## Examples of Improved Code Interfaces

### KanataServiceController
```swift
init(processRunner: ProcessRunner, admin: AdminTaskRunner, logger: Logging, policy: ServicePolicy)
func start(configPath: String, arguments: [String]) async throws -> ServiceStartInfo
func stop() async throws
func status() async -> LaunchDaemonStatus
```

### AdminTaskRunner
```swift
func runScript(at path: String, prompt: String) async throws -> AdminResult
func copyAsRoot(from tmp: String, to final: String, mode: String = "0644", owner: String = "root:wheel") async throws
```

### ConfigurationService
```swift
func saveConfiguration(keyMappings:) async throws -> KanataConfiguration // already exists
// add:
func savePrivilegedConfig(fromTemp path: String, toSystemPath: String) async throws // may call AdminTaskRunner
```

## Potential Side Effects and Mitigations

- Moving to AdminTaskRunner/ProcessRunner changes error surfaces from stdlib Error to custom errors; update call sites to handle richer failures (e.g., exitCode).
- Replacing echo-based writes with temp+install changes behavior when content includes unicode/newlines – in practice, this fixes current bugs.
- DI will require touching many initializers; add convenience initializers (defaulting to shared singletons) to reduce churn, but prefer explicit injection in App.swift.

## Swift and SwiftUI Best Practices Checklist

- Avoid `runModal` NSAlert in SwiftUI where not needed; prefer `.alert` with state.
- Do not block main thread for process I/O; offload using structured concurrency and background queues/`ProcessRunner`. Prefer `Task {}`; use `Task.detached` only when you intentionally need to break parent cancellation/priority or actor context, and document the rationale. Present admin prompts on the main thread for UI security.
- Prefer actors for shared mutable state accessed across tasks (PID cache already uses actor—extend to service warm-up tracking).
- Use Result builders for script assembly sparingly; prefer arrays-of-commands to reduce quoting complexity.
- Make larger view bodies readable by extracting subviews and moving imperative logic into view models/managers.

## Quick Wins (Low Effort, High Impact)

- Fix shell echo quoting in `WizardAutoFixer.synchronizeConfigPaths` (temp+install).
- Remove do/catch in `EventRouter.route()` and dummy proxy force unwrap; call the `process(event:)` overload.
- Replace hard-coded log directories with user logs and environment override.
- Switch `analyzeKanataLogs` to `tail -n 200`; avoid full file read.
- Introduce ProcessRunner; refactor the most critical long-running calls first (launchctl, codesign, brew).

## Roadmap Ordering

1. **Introduce ProcessRunner and AdminTaskRunner**; refactor LaunchDaemonInstaller and WizardAutoFixer writes; fix quoting/security.
2. **Decompose KanataManager**: move service control and config save/validate into dedicated classes; switch to injected services in App.swift.
3. **Logging unification and dev-path removal**; adjust log levels to reduce noise.
4. **FileWatcher robustness**; replace single-file watches with directory watcher.
5. **UI cleanup**: remove direct TCC DB probes; use PermissionOracle everywhere; replace some NSAlert usages with SwiftUI `.alert`.

This plan increases clarity, reduces duplicated code, removes main-thread blocking, and improves safety/security. It sets up a maintainable architecture where each subsystem has a clear responsibility with well-defined interfaces and testable boundaries.