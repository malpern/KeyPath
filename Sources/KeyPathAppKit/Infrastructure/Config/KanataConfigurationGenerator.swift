import Foundation
import KeyPathCore
import KeyPathDaemonLifecycle
import Network

// MARK: - Kanata Configuration Model

/// Represents Kanata configuration data and metadata
public struct KanataConfiguration: Sendable {
    public let content: String
    public let keyMappings: [KeyMapping]
    public let lastModified: Date
    public let path: String
    public let chordGroups: [ChordGroupConfig]
    public let sequences: [KanataDefseqParser.ParsedSequence]

    public init(
        content: String,
        keyMappings: [KeyMapping],
        lastModified: Date,
        path: String,
        chordGroups: [ChordGroupConfig] = [],
        sequences: [KanataDefseqParser.ParsedSequence] = []
    ) {
        self.content = content
        self.keyMappings = keyMappings
        self.lastModified = lastModified
        self.path = path
        self.chordGroups = chordGroups
        self.sequences = sequences
    }

    /// Generate configuration content from key mappings (adds default system collections when absent).
    public static func generateFromMappings(_ mappings: [KeyMapping]) -> String {
        let collections = [RuleCollection].collection(named: "Custom Mappings", mappings: mappings)
        return generateFromCollections(collections)
    }

    /// Generate configuration content from rule collections.
    /// Flattens enabled collections to `defsrc`/`deflayer` for backward compatibility with Kanata config format.
    public static func generateFromCollections(
        _ collections: [RuleCollection],
        leaderKeyPreference: LeaderKeyPreference? = nil,
        navActivationMode: ContextHUDTriggerMode = .tapToToggle,
        chordGroups: [ChordGroupConfig] = [],
        sequences: [KanataDefseqParser.ParsedSequence] = []
    ) -> String {
        var resolvedCollections = collections.isEmpty ? defaultSystemCollections : collections
        if !resolvedCollections.contains(where: { $0.id == RuleCollectionIdentifier.macFunctionKeys }) {
            resolvedCollections.append(contentsOf: defaultSystemCollections)
        }
        resolvedCollections = RuleCollectionDeduplicator.dedupe(resolvedCollections)
        let enabledCollections = resolvedCollections.filter(\.isEnabled)
        // Note: Disabled collections are NOT written to config (ADR-025: JSON stores are source of truth)

        // Extract UI-authored chord groups config (MAL-37)
        let uiChordGroupsConfig = enabledCollections
            .compactMap(\.configuration.chordGroupsConfig)
            .first

        AppLogger.shared.log("ðŸ“š [KanataConfig] Enabled collections: \(enabledCollections.map { "\($0.name) (enabled: \($0.isEnabled))" }.joined(separator: ", "))")

        let (rawBlocks, aliasDefinitions, extraLayers, chordMappings) = buildCollectionBlocks(
            from: enabledCollections,
            leaderKeyPreference: leaderKeyPreference,
            navActivationMode: navActivationMode
        )
        let mergedAliasDefinitions = aliasDefinitions
        AppLogger.shared.log("ðŸ“š [KanataConfig] Total alias definitions: \(mergedAliasDefinitions.count), first 5: \(mergedAliasDefinitions.prefix(5).map(\.aliasName).joined(separator: ", "))")
        let blocks = deduplicateBlocks(rawBlocks)
        let enabledNames = enabledCollections.map(\.name).joined(separator: ", ")

        let header = """
        ;; Generated by KeyPath
        ;; Enabled: \(enabledNames.isEmpty ? "none" : enabledNames)

        (defcfg
          process-unmapped-keys yes
          danger-enable-cmd yes
        )
        """

        let safetyNotes = """
        ;; SAFETY: This configuration is auto-generated. Do not edit by hand.
        ;; SAFETY: Only explicitly enabled mappings are written to this file.
        ;; EMERGENCY EXIT: Hold Left Control + Space + Escape to force-quit Kanata
        """

        let defvarBlock = renderDefvarBlock()
        let sourceBlock = renderDefsrcBlock(blocks)

        // Load app-specific keys to use @kp-{key} aliases in base layer
        let appSpecificKeys = loadAppSpecificKeys()

        let baseLayerBlock = renderLayerBlock(name: RuleCollectionLayer.base.kanataName, blocks: blocks) { entry in
            // If this key has app-specific overrides, use the alias instead of the plain key
            // This enables the switch expression in keypath-apps.kbd to intercept the key
            let keyName = entry.sourceKey.lowercased()
            if appSpecificKeys.contains(keyName) {
                return appSpecificAliasName(for: keyName)
            }
            return entry.baseOutput
        }
        let additionalLayerBlocks = extraLayers.map { layer in
            renderLayerBlock(name: layer.kanataName, blocks: blocks) { entry in
                entry.layerOutputs[layer] ?? "_"
            }
        }.joined(separator: "\n")
        let fakeKeysBlock = renderFakeKeysBlock(extraLayers)
        let aliasBlock = renderAliasBlock(mergedAliasDefinitions)
        let chordsBlock = renderChordsBlock(chordMappings)
        let preservedChordGroupsBlock = renderChordGroupsBlock(chordGroups)
        let preservedSequencesBlock = renderSequencesBlock(sequences)
        let uiChordGroupsBlock = renderUIChordGroupsBlock(uiChordGroupsConfig)

        // Include keypath-apps.kbd if there are app-specific keys
        // This must come after defcfg but before any layer that uses @kp-* aliases
        let appIncludeBlock = if !appSpecificKeys.isEmpty {
            """
            ;; App-specific keymaps (virtual keys and switch expressions)
            (include keypath-apps.kbd)
            """
        } else {
            ""
        }

        return [
            header,
            safetyNotes,
            appIncludeBlock,
            defvarBlock,
            sourceBlock,
            aliasBlock, // Must come before layers that reference aliases (e.g., @kp-ac-spc)
            baseLayerBlock,
            additionalLayerBlocks,
            fakeKeysBlock,
            chordsBlock,
            preservedSequencesBlock,
            preservedChordGroupsBlock,
            uiChordGroupsBlock
        ]
        .filter { !$0.isEmpty }
        .joined(separator: "\n")
    }

    private static let defaultEmptyConfig = generateFromCollections(defaultSystemCollections)
}
