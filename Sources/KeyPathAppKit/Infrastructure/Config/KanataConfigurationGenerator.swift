import Foundation
import KeyPathCore
import KeyPathDaemonLifecycle
import Network

// MARK: - Kanata Configuration Model

/// Represents Kanata configuration data and metadata
public struct KanataConfiguration: Sendable {
    public let content: String
    public let keyMappings: [KeyMapping]
    public let lastModified: Date
    public let path: String
    public let chordGroups: [ChordGroupConfig]

    public init(
        content: String,
        keyMappings: [KeyMapping],
        lastModified: Date,
        path: String,
        chordGroups: [ChordGroupConfig] = []
    ) {
        self.content = content
        self.keyMappings = keyMappings
        self.lastModified = lastModified
        self.path = path
        self.chordGroups = chordGroups
    }

    /// Generate configuration content from key mappings (adds default system collections when absent).
    public static func generateFromMappings(_ mappings: [KeyMapping]) -> String {
        let collections = [RuleCollection].collection(named: "Custom Mappings", mappings: mappings)
        return generateFromCollections(collections)
    }

    /// Generate configuration content from rule collections.
    /// Flattens enabled collections to `defsrc`/`deflayer` for backward compatibility with Kanata config format.
    public static func generateFromCollections(
        _ collections: [RuleCollection],
        chordGroups: [ChordGroupConfig] = []
    ) -> String {
        var resolvedCollections = collections.isEmpty ? defaultSystemCollections : collections
        if !resolvedCollections.contains(where: { $0.id == RuleCollectionIdentifier.macFunctionKeys }) {
            resolvedCollections.append(contentsOf: defaultSystemCollections)
        }
        resolvedCollections = RuleCollectionDeduplicator.dedupe(resolvedCollections)
        let enabledCollections = resolvedCollections.filter(\.isEnabled)
        // Note: Disabled collections are NOT written to config (ADR-025: JSON stores are source of truth)
        let (rawBlocks, aliasDefinitions, extraLayers, chordMappings) = buildCollectionBlocks(from: enabledCollections)
        let blocks = deduplicateBlocks(rawBlocks)
        let enabledNames = enabledCollections.map(\.name).joined(separator: ", ")
        let header = """
        ;; Generated by KeyPath
        ;; Enabled: \(enabledNames.isEmpty ? "none" : enabledNames)

        (defcfg
          process-unmapped-keys yes
          danger-enable-cmd yes
        )
        """

        let safetyNotes = """
        ;; SAFETY: This configuration is auto-generated. Do not edit by hand.
        ;; SAFETY: Only explicitly enabled mappings are written to this file.
        ;; EMERGENCY EXIT: Hold Left Control + Space + Escape to force-quit Kanata
        """

        let defvarBlock = renderDefvarBlock()
        let sourceBlock = renderDefsrcBlock(blocks)

        // Load app-specific keys to use @kp-{key} aliases in base layer
        let appSpecificKeys = loadAppSpecificKeys()

        let baseLayerBlock = renderLayerBlock(name: RuleCollectionLayer.base.kanataName, blocks: blocks) { entry in
            // If this key has app-specific overrides, use the alias instead of the plain key
            // This enables the switch expression in keypath-apps.kbd to intercept the key
            let keyName = entry.sourceKey.lowercased()
            if appSpecificKeys.contains(keyName) {
                return appSpecificAliasName(for: keyName)
            }
            return entry.baseOutput
        }
        let additionalLayerBlocks = extraLayers.map { layer in
            renderLayerBlock(name: layer.kanataName, blocks: blocks) { entry in
                entry.layerOutputs[layer] ?? "_"
            }
        }.joined(separator: "\n")
        let fakeKeysBlock = renderFakeKeysBlock(extraLayers)
        let aliasBlock = renderAliasBlock(aliasDefinitions)
        let chordsBlock = renderChordsBlock(chordMappings)
        let chordGroupsBlock = renderChordGroupsBlock(chordGroups)

        // Include keypath-apps.kbd if there are app-specific keys
        // This must come after defcfg but before any layer that uses @kp-* aliases
        let appIncludeBlock = if !appSpecificKeys.isEmpty {
            """
            ;; App-specific keymaps (virtual keys and switch expressions)
            (include keypath-apps.kbd)
            """
        } else {
            ""
        }

        return [
            header,
            safetyNotes,
            appIncludeBlock,
            defvarBlock,
            sourceBlock,
            baseLayerBlock,
            additionalLayerBlocks,
            fakeKeysBlock,
            aliasBlock,
            chordsBlock,
            chordGroupsBlock
        ]
            .filter { !$0.isEmpty }
            .joined(separator: "\n")
    }

    private static let defaultEmptyConfig = generateFromCollections(defaultSystemCollections)

    // MARK: - Rendering helpers

    /// Render defvar block with timing variables for reuse across the config.
    /// These variables allow users to globally adjust timing values.
    private static func renderDefvarBlock() -> String {
        """
        #|
        ================================================================================
        TIMING VARIABLES
        ================================================================================
        |#

        (defvar
          tap-timeout   200
          hold-timeout  200
          chord-timeout  50
        )

        """
    }

    private static func renderAliasBlock(_ aliases: [AliasDefinition]) -> String {
        guard !aliases.isEmpty else { return "" }
        var lines = [
            "#|",
            "================================================================================",
            "ALIAS DEFINITIONS (defalias)",
            "================================================================================",
            "|#",
            "",
            "(defalias"
        ]
        let definitions = aliases.map { alias in
            // Format multi-line actions with proper indentation
            let formattedDef = formatMultiLineAction(alias.definition)
            return "  \(alias.aliasName) \(formattedDef)"
        }
        lines.append(contentsOf: definitions)
        lines.append(")")
        lines.append("")
        return lines.joined(separator: "\n")
    }

    /// Format complex actions across multiple lines for better readability.
    /// Handles common patterns like multi actions and long tap-hold chains.
    private static func formatMultiLineAction(_ action: String) -> String {
        // If action already contains newlines (from our formatting), return as-is
        if action.contains("\n") {
            return action
        }

        // Only format if action is long enough to benefit from multi-line
        guard action.count > 80 else {
            return action
        }

        // Format multi actions with multiple components
        if action.hasPrefix("(multi "), action.count > 100 {
            return formatMultiAction(action)
        }

        // Format long tap-hold actions that contain multi
        if action.contains("(tap-hold") || action.contains("(tap-hold-press") || action.contains("(tap-hold-release"), action.contains("(multi ") {
            return formatTapHoldWithMulti(action)
        }

        // Otherwise, return as-is to avoid breaking valid syntax
        return action
    }

    /// Format a multi action across multiple lines.
    /// Only handles simple cases to avoid breaking valid syntax.
    private static func formatMultiAction(_ action: String) -> String {
        // Extract components from (multi comp1 comp2 comp3)
        guard action.hasPrefix("(multi "), action.hasSuffix(")") else {
            return action
        }

        let inner = String(action.dropFirst(7).dropLast(1)) // Remove "(multi " and ")"

        // Count top-level components (separated by spaces at depth 0)
        var parenDepth = 0
        var componentCount = 0
        var lastWasSpace = false

        for char in inner {
            if char == "(" {
                parenDepth += 1
                lastWasSpace = false
            } else if char == ")" {
                parenDepth -= 1
                lastWasSpace = false
            } else if char == " ", parenDepth == 0 {
                if !lastWasSpace {
                    componentCount += 1
                }
                lastWasSpace = true
            } else {
                lastWasSpace = false
            }
        }

        // Only format if we have 3+ components (multi with 2+ items)
        guard componentCount >= 2 else {
            return action
        }

        // Simple formatting: split on spaces at depth 0
        var result = "(multi\n"
        var currentComponent = ""
        parenDepth = 0

        for char in inner {
            if char == "(" {
                currentComponent.append(char)
                parenDepth += 1
            } else if char == ")" {
                currentComponent.append(char)
                parenDepth -= 1
            } else if char == " ", parenDepth == 0 {
                // Space at top level - start new component
                let trimmed = currentComponent.trimmingCharacters(in: .whitespaces)
                if !trimmed.isEmpty {
                    result += "    \(trimmed)\n"
                }
                currentComponent = ""
            } else {
                currentComponent.append(char)
            }
        }

        // Add final component
        let trimmed = currentComponent.trimmingCharacters(in: .whitespaces)
        if !trimmed.isEmpty {
            result += "    \(trimmed)\n"
        }

        result += "  )"
        return result
    }

    /// Format tap-hold actions that contain multi sub-actions.
    private static func formatTapHoldWithMulti(_ action: String) -> String {
        // Pattern: (tap-hold timeout timeout key (multi ...))
        // We want: (tap-hold timeout timeout key\n  (multi\n    ...))

        // Find the (multi part
        guard let multiStart = action.range(of: "(multi ") else {
            return action
        }

        let beforeMulti = String(action[..<multiStart.lowerBound]).trimmingCharacters(in: .whitespaces)
        let multiPart = String(action[multiStart.lowerBound...])

        // Format the multi part
        let formattedMulti = formatMultiAction(multiPart)

        // Combine with proper indentation
        if formattedMulti.contains("\n") {
            return "\(beforeMulti)\n  \(formattedMulti.replacingOccurrences(of: "\n", with: "\n  "))"
        }

        return action
    }

    /// Render deffakekeys block for layer change notifications.
    /// Creates fake keys that send push-msg when layers are entered/exited,
    /// working around Kanata's limitation where layer-while-held doesn't broadcast LayerChange TCP messages.
    private static func renderFakeKeysBlock(_ layers: [RuleCollectionLayer]) -> String {
        guard !layers.isEmpty else { return "" }
        var lines = [
            "#|",
            "================================================================================",
            "VIRTUAL KEYS (deffakekeys)",
            "================================================================================",
            "|#",
            "",
            ";; Used to broadcast layer changes via TCP (layer-while-held doesn't do this natively)",
            "(deffakekeys"
        ]
        // Add enter/exit fake keys for each non-base layer
        for layer in layers {
            let layerName = layer.kanataName
            lines.append("  kp-layer-\(layerName)-enter (push-msg \"layer:\(layerName)\")")
            lines.append("  kp-layer-\(layerName)-exit (push-msg \"layer:base\")")
        }
        lines.append(")")
        return lines.joined(separator: "\n") + "\n"
    }

    /// Render defchordsv2 block for chord mappings (simultaneous key presses)
    private static func renderChordsBlock(_ chordMappings: [ChordMapping]) -> String {
        guard !chordMappings.isEmpty else { return "" }
        var lines = [
            "#|",
            "================================================================================",
            "CHORD MAPPINGS (defchordsv2)",
            "================================================================================",
            "|#",
            "",
            "(defchordsv2"
        ]
        for chord in chordMappings {
            // Format: (key1 key2) output timeout release-behavior ()
            // timeout: uses $chord-timeout variable (default 50ms)
            // all-released: trigger when all keys are released
            lines.append("  (\(chord.inputKeys)) \(chord.output) $chord-timeout all-released ()")
        }
        lines.append(")")
        return lines.joined(separator: "\n") + "\n"
    }

    private static func renderChordGroupsBlock(_ chordGroups: [ChordGroupConfig]) -> String {
        guard !chordGroups.isEmpty else { return "" }
        var lines = [
            "#|",
            "================================================================================",
            "CHORD GROUPS (defchords)",
            "================================================================================",
            "|#",
            ""
        ]

        for group in chordGroups {
            lines.append("(defchords \(group.name) \(group.timeoutToken)")
            for chord in group.chords {
                let keys = chord.keys.joined(separator: " ")
                lines.append("  (\(keys)) \(chord.action)")
            }
            lines.append(")")
            lines.append("")
        }

        if lines.last == "" { lines.removeLast() }
        return lines.joined(separator: "\n") + "\n"
    }

    /// Represents a chord mapping (simultaneous key presses)
    private struct ChordMapping {
        let inputKeys: String // Space-separated keys, e.g., "lsft rsft"
        let output: String // Output action, e.g., "caps"
        let description: String?
    }

    private static func renderDefsrcBlock(_ blocks: [CollectionBlock]) -> String {
        var lines = [
            "#|",
            "================================================================================",
            "PHYSICAL KEYBOARD LAYOUT - DEFSRC",
            "================================================================================",
            "|#",
            "",
            "(defsrc"
        ]
        if blocks.isEmpty {
            lines.append("  ;; No enabled collections")
        } else {
            for block in blocks {
                lines.append(contentsOf: KeyboardGridFormatter.renderDefsrc(block))
                lines.append("")
            }
            if lines.last == "" { lines.removeLast() }
        }
        lines.append(")")
        return lines.joined(separator: "\n")
    }

    private static func renderLayerBlock(
        name: String,
        blocks: [CollectionBlock],
        valueProvider: (LayerEntry) -> String
    ) -> String {
        var lines: [String] = []

        // Add section header for base layer only (other layers are grouped)
        if name == "base" {
            lines.append(contentsOf: [
                "#|",
                "================================================================================",
                "LAYER DEFINITIONS",
                "================================================================================",
                "|#",
                ""
            ])
        }

        lines.append("(deflayer \(name)")
        if blocks.isEmpty {
            lines.append("  ;; No enabled collections")
        } else {
            for block in blocks {
                lines.append(contentsOf: KeyboardGridFormatter.renderLayer(block, valueProvider: valueProvider))
                lines.append("")
            }
            if lines.last == "" { lines.removeLast() }
        }
        lines.append(")")
        return lines.joined(separator: "\n")
    }

    // Note: renderDisabledCollections removed - disabled collections not written to config (ADR-025)

    private static func metadataLines(for collection: RuleCollection, indent: String, status: String)
        -> [String] {
        [
            "\(indent);; === Collection: \(collection.name) (\(status)) ===",
            "\(indent);; UUID: \(collection.id.uuidString)",
            "\(indent);; Description: \(collection.summary)"
        ]
    }

    private static func metadataLines(for activator: MomentaryActivator, indent: String) -> [String] {
        [
            "\(indent);; === Momentary Layer Switch ===",
            "\(indent);; Input: \(activator.input)",
            "\(indent);; Activates: \(activator.targetLayer.displayName)"
        ]
    }

    /// Get the system default collections (macOS Function Keys enabled by default)
    public static var systemDefaultCollections: [RuleCollection] {
        defaultSystemCollections
    }

    private static var defaultSystemCollections: [RuleCollection] {
        [
            RuleCollection(
                id: RuleCollectionIdentifier.macFunctionKeys,
                name: "macOS Function Keys",
                summary: "Preserves brightness, volume, and media control keys (F1-F12).",
                category: .system,
                mappings: macFunctionKeyMappings,
                isEnabled: true,
                isSystemDefault: true,
                icon: "keyboard",
                targetLayer: .base
            )
        ]
    }

    private static var macFunctionKeyMappings: [KeyMapping] {
        [
            KeyMapping(input: "f1", output: "brdn"),
            KeyMapping(input: "f2", output: "brup"),
            KeyMapping(input: "f3", output: "f3"),
            KeyMapping(input: "f4", output: "f4"),
            KeyMapping(input: "f7", output: "prev"),
            KeyMapping(input: "f8", output: "pp"),
            KeyMapping(input: "f9", output: "next"),
            KeyMapping(input: "f10", output: "mute"),
            KeyMapping(input: "f11", output: "vold"),
            KeyMapping(input: "f12", output: "volu")
        ]
    }

    // MARK: - Block builders

    private static func buildCollectionBlocks(
        from collections: [RuleCollection]
    ) -> ([CollectionBlock], [AliasDefinition], [RuleCollectionLayer], [ChordMapping]) {
        var blocks: [CollectionBlock] = []
        var aliasDefinitions: [AliasDefinition] = []
        var additionalLayers: [RuleCollectionLayer] = []
        var chordMappings: [ChordMapping] = []
        var seenLayers = Set<RuleCollectionLayer>()
        var activatorBlocks: [CollectionBlock] = []
        var seenActivators: Set<String> = []

        // Detect layers that should be activated when "hyper" is triggered.
        // These are collections with momentaryActivator.input == "hyper" (like Quick Launcher).
        // Since "hyper" isn't a physical key, we integrate these layers into the hyper hold action
        // of collections like Caps Lock Remap that output hyper on hold.
        let hyperLinkedLayerInfos: [HyperLinkedLayerInfo] = collections
            .filter(\.isEnabled)
            .compactMap { collection -> HyperLinkedLayerInfo? in
                guard let activator = collection.momentaryActivator,
                      activator.input.lowercased() == "hyper"
                else {
                    return nil
                }
                // Get trigger mode from launcher config if available
                let triggerMode: HyperTriggerMode = collection.configuration.launcherGridConfig?.hyperTriggerMode ?? .hold
                return HyperLinkedLayerInfo(layerName: activator.targetLayer.kanataName, triggerMode: triggerMode)
            }

        // Precompute mapped keys for non-base layers to avoid blocking keys mapped by other collections.
        var layerMappedKeys: [RuleCollectionLayer: Set<String>] = [:]

        func effectiveMappings(for collection: RuleCollection) -> [KeyMapping] {
            switch collection.configuration {
            case let .homeRowMods(config):
                generateHomeRowModsMappings(from: config)
            case .tapHoldPicker:
                generateTapHoldPickerMappings(from: collection)
            case .layerPresetPicker:
                generateLayerPresetMappings(from: collection)
            case let .launcherGrid(config):
                generateLauncherGridMappings(from: config)
            case .list, .table, .singleKeyPicker:
                collection.mappings
            }
        }

        for collection in collections where collection.isEnabled {
            let mappings = effectiveMappings(for: collection)
            let regularMappings = mappings.filter { !$0.input.contains(" ") }
            let inputs = regularMappings.map { KanataKeyConverter.convertToKanataKey($0.input) }
            var existing = layerMappedKeys[collection.targetLayer, default: []]
            existing.formUnion(inputs)
            layerMappedKeys[collection.targetLayer] = existing
        }

        for collection in collections where collection.targetLayer != .base {
            if !seenLayers.contains(collection.targetLayer) {
                seenLayers.insert(collection.targetLayer)
                additionalLayers.append(collection.targetLayer)
            }
        }

        for collection in collections {
            guard collection.isEnabled, let activator = collection.momentaryActivator else { continue }

            // Skip "hyper" activators - they're integrated into the hyper hold action
            // (handled by KanataBehaviorRenderer via hyperLinkedLayerInfos set above)
            if activator.input.lowercased() == "hyper" {
                continue
            }

            let tapKey = KanataKeyConverter.convertToKanataKey(activator.input)
            let aliasName = aliasSafeName(layer: activator.targetLayer, key: tapKey)
            if !seenActivators.contains(aliasName) {
                seenActivators.insert(aliasName)
                let layerName = activator.targetLayer.kanataName

                // For chained layers (sourceLayer != .base), use one-shot-press instead of tap-hold
                // This allows quick entry to nested layers without requiring hold
                let definition = if activator.sourceLayer == .base {
                    // Standard tap-hold for base layer activators
                    // Use multi to combine layer-while-held with fake key triggers for TCP layer notifications.
                    // This works around Kanata's limitation where layer-while-held doesn't broadcast LayerChange messages.
                    "(tap-hold $tap-timeout $hold-timeout \(tapKey)\n    (multi\n      (layer-while-held \(layerName))\n      (on-press-fakekey kp-layer-\(layerName)-enter tap)\n      (on-release-fakekey kp-layer-\(layerName)-exit tap)))"
                } else {
                    // One-shot for chained layers (e.g., nav ‚Üí window, nav ‚Üí sym)
                    // Activates target layer for 2 seconds or until next key press.
                    // Include layer notification fake keys for overlay and UI updates.
                    // Exit notification triggers when one-shot releases, returning to parent layer.
                    "(multi\n    (one-shot-press 2000 (layer-while-held \(layerName)))\n    (on-press-fakekey kp-layer-\(layerName)-enter tap)\n    (on-release-fakekey kp-layer-\(layerName)-exit tap))"
                }
                aliasDefinitions.append(AliasDefinition(aliasName: aliasName, definition: definition))

                // Determine where to place the activator
                let entry = if activator.sourceLayer == .base {
                    LayerEntry(
                        sourceKey: tapKey,
                        baseOutput: "@\(aliasName)",
                        layerOutputs: [:]
                    )
                } else {
                    // Chained activator: place in source layer, passthrough in base
                    LayerEntry(
                        sourceKey: tapKey,
                        baseOutput: tapKey, // Passthrough in base layer
                        layerOutputs: [activator.sourceLayer: "@\(aliasName)"]
                    )
                }
                let metadata = metadataLines(for: activator, indent: "  ")
                activatorBlocks.append(CollectionBlock(metadata: metadata, entries: [entry]))
            }
        }

        for collection in collections where collection.isEnabled {
            var metadata = metadataLines(for: collection, indent: "  ", status: "enabled")

            // Handle special display styles: generate mappings from config
            let effectiveMappings: [KeyMapping] = switch collection.configuration {
            case let .homeRowMods(config):
                generateHomeRowModsMappings(from: config)
            case .tapHoldPicker:
                generateTapHoldPickerMappings(from: collection)
            case .layerPresetPicker:
                generateLayerPresetMappings(from: collection)
            case let .launcherGrid(config):
                generateLauncherGridMappings(from: config)
            case .list, .table, .singleKeyPicker:
                collection.mappings
            }

            // Separate chord mappings (input contains space = multiple simultaneous keys)
            let regularMappings = effectiveMappings.filter { !$0.input.contains(" ") }
            let chordInputMappings = effectiveMappings.filter { $0.input.contains(" ") }

            // Add chord mappings to the separate chord list
            for mapping in chordInputMappings {
                let inputKeys = mapping.input.split(separator: " ").map { KanataKeyConverter.convertToKanataKey(String($0)) }.joined(separator: " ")
                let output = KanataKeyConverter.convertToKanataSequence(mapping.output)
                chordMappings.append(ChordMapping(inputKeys: inputKeys, output: output, description: mapping.description))
            }

            if regularMappings.isEmpty {
                if !chordInputMappings.isEmpty {
                    // Collection has only chord mappings - add metadata comment
                    metadata.append("  ;; (chord mappings in defchordsv2 block)")
                } else {
                    metadata.append("  ;; (no mappings)")
                }
                blocks.append(CollectionBlock(metadata: metadata, entries: []))
                continue
            }
            var entries = regularMappings.map { mapping -> LayerEntry in
                let sourceKey = KanataKeyConverter.convertToKanataKey(mapping.input)
                var layerOutputs: [RuleCollectionLayer: String] = [:]

                let trimmedOutput = mapping.output.trimmingCharacters(in: .whitespacesAndNewlines)

                // Determine the output action based on behavior or simple output
                let layerOutput: String
                if mapping.behavior != nil {
                    // Advanced behavior (tap-hold, tap-dance) - use renderer
                    // Pass hyperLinkedLayerInfos so "hyper" hold action includes linked layer activations
                    let rendered = KanataBehaviorRenderer.render(mapping, hyperLinkedLayerInfos: hyperLinkedLayerInfos)
                    // Create alias for complex behaviors to keep deflayer clean
                    let aliasName = behaviorAliasName(for: mapping, layer: collection.targetLayer)
                    aliasDefinitions.append(AliasDefinition(aliasName: aliasName, definition: rendered))
                    layerOutput = "@\(aliasName)"
                } else if mapping.requiresFork {
                    // Generate fork alias for mappings with modifier-specific outputs
                    let aliasName = forkAliasName(for: mapping, layer: collection.targetLayer)
                    let forkDef = buildForkDefinition(for: mapping)
                    aliasDefinitions.append(AliasDefinition(aliasName: aliasName, definition: forkDef))
                    layerOutput = "@\(aliasName)"
                } else if trimmedOutput.hasPrefix("("), trimmedOutput.count > 1 {
                    // Complex action (push-msg, multi, etc.) - needs alias
                    let aliasName = actionAliasName(for: mapping, layer: collection.targetLayer)
                    aliasDefinitions.append(AliasDefinition(aliasName: aliasName, definition: trimmedOutput))
                    layerOutput = "@\(aliasName)"
                } else {
                    // Simple output (key name)
                    layerOutput = KanataKeyConverter.convertToKanataSequence(trimmedOutput)
                }

                if collection.targetLayer != .base {
                    layerOutputs[collection.targetLayer] = layerOutput
                }
                let baseOutput: String =
                    if collection.targetLayer == .base {
                        layerOutput
                    } else {
                        sourceKey
                    }
                return LayerEntry(
                    sourceKey: sourceKey,
                    baseOutput: baseOutput,
                    layerOutputs: layerOutputs
                )
            }

            // For Vim collection: optionally block unmapped keys in navigation layer
            if collection.id == RuleCollectionIdentifier.vimNavigation,
               collection.targetLayer != .base {
                let mappedKeys = layerMappedKeys[collection.targetLayer] ?? Set(entries.map(\.sourceKey))
                let activatorKey = collection.momentaryActivator.map { KanataKeyConverter.convertToKanataKey($0.input) } ?? ""
                // Read user's selected physical layout from UserDefaults
                let selectedLayoutId = UserDefaults.standard.string(forKey: LayoutPreferences.layoutIdKey) ?? LayoutPreferences.defaultLayoutId
                let layout = PhysicalLayout.find(id: selectedLayoutId) ?? .macBookUS
                let extraKeys = Self.navigationUnmappedKeys(
                    excluding: mappedKeys,
                    skipping: activatorKey.isEmpty ? [] : [activatorKey],
                    layout: layout
                )
                let blockedEntries = extraKeys.map { key in
                    LayerEntry(
                        sourceKey: key,
                        baseOutput: key, // base layer keeps normal behavior
                        layerOutputs: [collection.targetLayer: "XX"] // nav layer blocks output
                    )
                }
                entries.append(contentsOf: blockedEntries)
            }

            blocks.append(CollectionBlock(metadata: metadata, entries: entries))
        }

        return (activatorBlocks + blocks, aliasDefinitions, additionalLayers, chordMappings)
    }

    private static func deduplicateBlocks(_ blocks: [CollectionBlock]) -> [CollectionBlock] {
        // Merge entries with the same source key instead of just keeping the first one.
        // This ensures layer-specific mappings (like launcher in launcher layer) aren't lost
        // when another collection (like Vim) also uses the same keys in a different layer.
        var mergedEntries: [String: LayerEntry] = [:]
        var entriesByBlock: [[String]] = [] // Track which keys belong to which block
        var keyOrder: [String] = [] // Preserve insertion order

        for block in blocks {
            var blockKeys: [String] = []
            for entry in block.entries {
                if let existing = mergedEntries[entry.sourceKey] {
                    // Merge layer outputs from this entry into the existing one
                    var combinedLayerOutputs = existing.layerOutputs
                    for (layer, output) in entry.layerOutputs {
                        combinedLayerOutputs[layer] = output
                    }
                    // Keep the base output from the first entry (earlier collection takes precedence)
                    mergedEntries[entry.sourceKey] = LayerEntry(
                        sourceKey: existing.sourceKey,
                        baseOutput: existing.baseOutput,
                        layerOutputs: combinedLayerOutputs
                    )
                } else {
                    // New key - add it
                    mergedEntries[entry.sourceKey] = entry
                    keyOrder.append(entry.sourceKey)
                }
                blockKeys.append(entry.sourceKey)
            }
            entriesByBlock.append(blockKeys)
        }

        // Rebuild blocks with merged entries, keeping original block structure
        var result: [CollectionBlock] = []
        var usedKeys: Set<String> = []

        for (index, block) in blocks.enumerated() {
            let blockKeySet = Set(entriesByBlock[index])
            var uniqueEntries: [LayerEntry] = []
            for key in keyOrder {
                guard blockKeySet.contains(key), !usedKeys.contains(key) else { continue }
                if let entry = mergedEntries[key] {
                    uniqueEntries.append(entry)
                    usedKeys.insert(key)
                }
            }
            result.append(CollectionBlock(metadata: block.metadata, entries: uniqueEntries))
        }

        return result
    }

    /// Formats collection blocks into keyboard-shaped, padded rows for readability.
    private enum KeyboardGridFormatter {
        // Simple 60%/MacBook ANSI-ish layout expressed in Kanata key names
        private static let layoutRows: [[String]] = [
            ["esc", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12", "del"],
            ["grv", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "min", "eql", "bspc"],
            ["tab", "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\"],
            ["caps", "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'", "ret"],
            ["lsft", "z", "x", "c", "v", "b", "n", "m", ",", ".", "/", "rsft"],
            ["lctl", "lalt", "lmet", "spc", "rmet", "ralt", "rctl"]
        ]

        private static let order: [String: Int] = {
            var idx: [String: Int] = [:]
            for (rowIndex, row) in layoutRows.enumerated() {
                for (colIndex, key) in row.enumerated() {
                    idx[key] = rowIndex * 100 + colIndex // wide spacing to keep row priority
                }
            }
            return idx
        }()

        static func renderDefsrc(_ block: CollectionBlock) -> [String] {
            guard !block.entries.isEmpty else {
                return block.metadata + ["  ;; (no mappings)"]
            }
            let sorted = sortEntries(block.entries)
            let body = renderGridLines(sorted) { $0.sourceKey }
            return block.metadata + body
        }

        static func renderLayer(
            _ block: CollectionBlock,
            valueProvider: (LayerEntry) -> String
        ) -> [String] {
            guard !block.entries.isEmpty else {
                return block.metadata + ["  ;; (no mappings)"]
            }
            let sorted = sortEntries(block.entries)
            let body = renderGridLines(sorted, valueProvider: valueProvider)
            return block.metadata + body
        }

        private static func sortEntries(_ entries: [LayerEntry]) -> [LayerEntry] {
            entries.sorted { lhs, rhs in
                let l = order[lhs.sourceKey] ?? Int.max
                let r = order[rhs.sourceKey] ?? Int.max
                if l == r {
                    return lhs.sourceKey < rhs.sourceKey
                }
                return l < r
            }
        }

        /// Render entries grouped into physical rows; rows without entries are skipped.
        private static func renderGridLines(
            _ entries: [LayerEntry],
            valueProvider: (LayerEntry) -> String
        ) -> [String] {
            var rows: [[String]] = []
            var remaining = entries

            for layoutRow in layoutRows {
                var tokens: [String] = []
                for key in layoutRow {
                    if let idx = remaining.firstIndex(where: { $0.sourceKey == key }) {
                        let entry = remaining.remove(at: idx)
                        tokens.append(valueProvider(entry))
                    }
                }
                if !tokens.isEmpty {
                    rows.append(tokens)
                }
            }

            // Anything not in the known layout gets appended in a trailing row
            if !remaining.isEmpty {
                rows.append(remaining.map { valueProvider($0) })
            }

            return rows.map { "  " + padRow($0) }
        }

        private static func padRow(_ tokens: [String]) -> String {
            let width = tokens.map(\.count).max() ?? 0
            let padded = tokens.map { token in
                token.padding(toLength: width, withPad: " ", startingAt: 0)
            }
            return padded.joined(separator: " ")
        }
    }

    /// Build a deterministic list of unmapped keys on the specified physical layout to block in navigation layer.
    /// Excludes modifier keys and any keys already mapped.
    /// - Parameters:
    ///   - mappedKeys: Keys that are already mapped (will not be blocked)
    ///   - extraSkips: Additional keys to skip (e.g., layer activator key)
    ///   - layout: The physical keyboard layout to use for determining available keys
    private static func navigationUnmappedKeys(
        excluding mappedKeys: Set<String>,
        skipping extraSkips: Set<String> = [],
        layout: PhysicalLayout = .macBookUS
    ) -> [String] {
        // Skip modifier/utility keys and any explicitly provided skips (e.g., activator key)
        let defaultSkips: Set<String> = [
            "leftmeta", "rightmeta", "leftctrl", "rightctrl",
            "leftalt", "rightalt", "leftshift", "rightshift",
            "capslock", "fn"
        ]
        let skip = defaultSkips.union(extraSkips)

        let keys = layout.keys.compactMap { key -> String? in
            // Skip invalid keycodes (e.g., Touch ID uses 0xFFFF as placeholder)
            guard key.keyCode != 0xFFFF else { return nil }
            let name = OverlayKeyboardView.keyCodeToKanataName(key.keyCode).lowercased()
            // Skip unknown keycodes
            guard !name.hasPrefix("unknown-") else { return nil }
            guard !skip.contains(name) else { return nil }
            let kanata = KanataKeyConverter.convertToKanataKey(name)
            guard !mappedKeys.contains(kanata) else { return nil }
            return kanata
        }

        return Array(Set(keys)).sorted()
    }

    private static func aliasSafeName(layer: RuleCollectionLayer, key: String) -> String {
        let sanitized =
            key
                .replacingOccurrences(of: "-", with: "_")
                .replacingOccurrences(of: " ", with: "_")
        return "layer_\(layer.kanataName)_\(sanitized)"
    }

    /// Generate alias name for fork-based modifier detection
    private static func forkAliasName(for mapping: KeyMapping, layer: RuleCollectionLayer) -> String {
        let sanitized =
            mapping.input
                .replacingOccurrences(of: "-", with: "_")
                .replacingOccurrences(of: " ", with: "_")
        return "fork_\(layer.kanataName)_\(sanitized)"
    }

    /// Generate alias name for advanced behavior (tap-hold, tap-dance)
    private static func behaviorAliasName(for mapping: KeyMapping, layer: RuleCollectionLayer) -> String {
        let sanitized =
            mapping.input
                .replacingOccurrences(of: "-", with: "_")
                .replacingOccurrences(of: " ", with: "_")
        return "beh_\(layer.kanataName)_\(sanitized)"
    }

    /// Generate alias name for complex actions (push-msg, multi, etc.)
    private static func actionAliasName(for mapping: KeyMapping, layer: RuleCollectionLayer) -> String {
        let sanitized =
            mapping.input
                .replacingOccurrences(of: "-", with: "_")
                .replacingOccurrences(of: " ", with: "_")
        return "act_\(layer.kanataName)_\(sanitized)"
    }

    /// Build fork definition for modifier-aware mappings
    /// Fork syntax: (fork default-action alternate-action (trigger-keys))
    /// Note: Inside fork, modifier prefixes like m-right must be (multi lmet right)
    private static func buildForkDefinition(for mapping: KeyMapping) -> String {
        let defaultOutput = convertToForkAction(mapping.output)

        // Shift modifier takes precedence
        if let shiftedOutput = mapping.shiftedOutput {
            let shiftOutput = convertToForkAction(shiftedOutput)
            return "(fork \(defaultOutput) \(shiftOutput) (lsft rsft))"
        }

        // Ctrl modifier
        if let ctrlOutput = mapping.ctrlOutput {
            let ctrlOutputConverted = convertToForkAction(ctrlOutput)
            return "(fork \(defaultOutput) \(ctrlOutputConverted) (lctl rctl))"
        }

        // Fallback (shouldn't reach here if requiresFork is true)
        return defaultOutput
    }

    /// Convert a key output to a fork-compatible action
    /// - Single keys with modifiers: (multi modifier key) format
    /// - Multi-key sequences: (macro ...) with chord syntax inside
    private static func convertToForkAction(_ output: String) -> String {
        let tokens = output.split(separator: " ").map(String.init)

        if tokens.count > 1 {
            // Multi-key sequence -> wrap in macro
            // Inside macro, chord syntax (M-right) works and requires UPPERCASE prefixes
            let converted = tokens.map { KanataKeyConverter.convertToKanataKeyForMacro($0) }
            return "(macro \(converted.joined(separator: " ")))"
        } else if let single = tokens.first {
            // Single key - must use (multi ...) format for modifiers inside fork
            return convertSingleKeyToForkFormat(single)
        }
        return output
    }

    /// Convert a single key (possibly with modifiers) to fork-compatible format
    /// e.g., "M-right" -> "(multi lmet right)", "pgup" -> "pgup"
    /// Note: Inside fork actions (not inside macro), modifier prefixes must be (multi ...)
    /// Generate KeyMapping instances from HomeRowModsConfig
    private static func generateHomeRowModsMappings(from config: HomeRowModsConfig) -> [KeyMapping] {
        var mappings: [KeyMapping] = []

        for key in config.enabledKeys {
            guard let modifier = config.modifierAssignments[key] else { continue }

            let tapTimeout = max(
                1,
                config.timing.tapWindow
                    + (config.timing.tapOffsets[key] ?? 0)
                    + (config.timing.quickTapEnabled ? config.timing.quickTapTermMs : 0)
            )
            let holdTimeout = max(1, config.timing.holdDelay + (config.timing.holdOffsets[key] ?? 0))

            // Create dual-role behavior: tap = letter, hold = modifier
            let behavior = DualRoleBehavior(
                tapAction: key,
                holdAction: modifier,
                tapTimeout: tapTimeout,
                holdTimeout: holdTimeout,
                activateHoldOnOtherKey: true, // Best for home-row mods
                quickTap: config.timing.quickTapEnabled,
                customTapKeys: []
            )

            let mapping = KeyMapping(
                input: key,
                output: key, // Fallback, but behavior takes precedence
                behavior: .dualRole(behavior)
            )
            mappings.append(mapping)
        }

        return mappings
    }

    /// Generate mappings for a tap-hold picker collection (e.g., Caps Lock Remap)
    private static func generateTapHoldPickerMappings(from collection: RuleCollection) -> [KeyMapping] {
        guard case let .tapHoldPicker(config) = collection.configuration else {
            return []
        }

        let tapOutput = config.selectedTapOutput ?? config.tapOptions.first?.output ?? "hyper"
        let holdOutput = config.selectedHoldOutput ?? config.holdOptions.first?.output ?? "hyper"

        // Create dual-role behavior: tap = tapOutput, hold = holdOutput
        let behavior = DualRoleBehavior(
            tapAction: tapOutput,
            holdAction: holdOutput,
            tapTimeout: 200,
            holdTimeout: 200,
            activateHoldOnOtherKey: true,
            quickTap: false,
            customTapKeys: []
        )

        let mapping = KeyMapping(
            input: config.inputKey,
            output: tapOutput, // Fallback, but behavior takes precedence
            behavior: .dualRole(behavior)
        )

        return [mapping]
    }

    /// Generate mappings for a layer preset picker collection (e.g., Symbol Layer)
    private static func generateLayerPresetMappings(from collection: RuleCollection) -> [KeyMapping] {
        guard case let .layerPresetPicker(config) = collection.configuration else {
            return collection.mappings
        }

        guard !config.presets.isEmpty else {
            return collection.mappings
        }

        return config.selectedMappings.isEmpty ? (config.presets.first?.mappings ?? []) : config.selectedMappings
    }

    /// Generate key mappings from launcher grid configuration
    private static func generateLauncherGridMappings(from config: LauncherGridConfig) -> [KeyMapping] {
        let isTapMode = config.hyperTriggerMode == .tap

        var mappings = config.mappings
            .filter(\.isEnabled)
            // In tap mode, ESC is reserved for canceling the one-shot, so filter it out
            .filter { !isTapMode || $0.key.lowercased() != "esc" }
            .map { mapping in
                let output = if isTapMode {
                    "(multi \(mapping.target.kanataOutput) (push-msg \"layer:base\"))"
                } else {
                    mapping.target.kanataOutput
                }
                return KeyMapping(
                    input: mapping.key,
                    output: output
                )
            }

        // In tap mode, add ESC ‚Üí XX (no output) to cancel one-shot without side effects
        if isTapMode {
            mappings.append(KeyMapping(input: "esc", output: "(multi XX (push-msg \"layer:base\"))"))
        }

        return mappings
    }

    private static func convertSingleKeyToForkFormat(_ key: String) -> String {
        // Map modifier prefixes to their key names
        let modifierMap: [(prefix: String, key: String)] = [
            ("M-S-", "lmet lsft"), // Meta+Shift
            ("C-S-", "lctl lsft"), // Ctrl+Shift
            ("A-S-", "lalt lsft"), // Alt+Shift
            ("M-", "lmet"), // Meta/Command
            ("A-", "lalt"), // Alt/Option
            ("C-", "lctl"), // Control
            ("S-", "lsft") // Shift
        ]

        var remainingKey = key
        var modifiers: [String] = []

        // Extract all modifier prefixes
        for (prefix, modKey) in modifierMap {
            if remainingKey.hasPrefix(prefix) {
                modifiers.append(contentsOf: modKey.split(separator: " ").map(String.init))
                remainingKey = String(remainingKey.dropFirst(prefix.count))
                break // Only match one combined prefix
            }
        }

        if modifiers.isEmpty {
            // No modifiers - return as-is (convert to kanata key format)
            return KanataKeyConverter.convertToKanataKey(remainingKey)
        }

        // Has modifiers - wrap in (multi ...)
        let baseKey = KanataKeyConverter.convertToKanataKey(remainingKey)
        return "(multi \(modifiers.joined(separator: " ")) \(baseKey))"
    }

    private struct CollectionBlock {
        let metadata: [String]
        let entries: [LayerEntry]
    }

    private struct LayerEntry {
        let sourceKey: String
        let baseOutput: String
        let layerOutputs: [RuleCollectionLayer: String]
    }

    private struct AliasDefinition {
        let aliasName: String
        let definition: String
    }

    // MARK: - App-Specific Key Support

    /// Load the set of input keys that have app-specific overrides.
    /// These keys should use @kp-{key} aliases in the base layer to enable per-app behavior.
    private static func loadAppSpecificKeys() -> Set<String> {
        let path = (WizardSystemPaths.userConfigDirectory as NSString)
            .appendingPathComponent("AppKeymaps.json")

        AppLogger.shared.log("üîç [ConfigGen] loadAppSpecificKeys: checking path \(path)")

        guard FileManager.default.fileExists(atPath: path) else {
            AppLogger.shared.log("‚ö†Ô∏è [ConfigGen] loadAppSpecificKeys: file does not exist")
            return []
        }

        guard let data = FileManager.default.contents(atPath: path) else {
            AppLogger.shared.log("‚ö†Ô∏è [ConfigGen] loadAppSpecificKeys: could not read file contents")
            return []
        }

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601 // Match AppKeymapStore's encoding

        guard let keymaps = try? decoder.decode([AppKeymap].self, from: data) else {
            AppLogger.shared.log("‚ö†Ô∏è [ConfigGen] loadAppSpecificKeys: JSON decode failed")
            return []
        }

        AppLogger.shared.log("üîç [ConfigGen] loadAppSpecificKeys: found \(keymaps.count) keymaps")

        // Collect all input keys from enabled keymaps
        var keys = Set<String>()
        for keymap in keymaps where keymap.mapping.isEnabled {
            for override in keymap.overrides {
                keys.insert(override.inputKey.lowercased())
            }
        }

        AppLogger.shared.log("üîç [ConfigGen] loadAppSpecificKeys: returning \(keys.count) keys: \(keys)")
        return keys
    }

    /// Convert a key name to its app-specific alias format (kp-{key}).
    /// Uses the same sanitization as AppConfigGenerator.
    private static func appSpecificAliasName(for key: String) -> String {
        let sanitized = key.lowercased()
            .replacingOccurrences(of: " ", with: "-")
            .filter { $0.isLetter || $0.isNumber || $0 == "-" }

        guard !sanitized.isEmpty else {
            let hash = key.unicodeScalars.reduce(0) { $0 + Int($1.value) }
            return "@kp-key-\(String(format: "%04x", hash % 65521))"
        }

        if let first = sanitized.first, !first.isLetter {
            return "@kp-key-\(sanitized)"
        }

        return "@kp-\(sanitized)"
    }
}
