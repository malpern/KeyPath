import ApplicationServices
import Foundation
import IOKit.hidsystem
import KeyPathCore
import Network
import SwiftUI

// MARK: - Kanata Configuration Model

/// Represents Kanata configuration data and metadata
public struct KanataConfiguration: Sendable {
  public let content: String
  public let keyMappings: [KeyMapping]
  public let lastModified: Date
  public let path: String

  public init(content: String, keyMappings: [KeyMapping], lastModified: Date, path: String) {
    self.content = content
    self.keyMappings = keyMappings
    self.lastModified = lastModified
    self.path = path
  }

  /// Generate configuration content from key mappings (adds default system collections when absent).
  public static func generateFromMappings(_ mappings: [KeyMapping]) -> String {
    let collections = [RuleCollection].collection(named: "Custom Mappings", mappings: mappings)
    return generateFromCollections(collections)
  }

  /// Generate configuration content from rule collections.
  /// Flattens enabled collections to `defsrc`/`deflayer` for backward compatibility with Kanata config format.
  public static func generateFromCollections(_ collections: [RuleCollection]) -> String {
    var resolvedCollections = collections.isEmpty ? defaultSystemCollections : collections
    if !resolvedCollections.contains(where: { $0.id == RuleCollectionIdentifier.macFunctionKeys }) {
      resolvedCollections.append(contentsOf: defaultSystemCollections)
    }
    let enabledCollections = resolvedCollections.filter(\.isEnabled)
    let disabledCollections = resolvedCollections.filter { !$0.isEnabled && !$0.mappings.isEmpty }
    let (rawBlocks, aliasDefinitions, extraLayers) = buildCollectionBlocks(from: enabledCollections)
    let blocks = deduplicateBlocks(rawBlocks)
    let header = """
      ;; Generated by KeyPath
      ;; SAFETY: Do not edit while KeyPath/kanata is running; restart service after changes.
      ;; Rule Collections: \(resolvedCollections.filter(\.isEnabled).count) enabled, \(resolvedCollections.count) total

      (defcfg
        process-unmapped-keys yes
        danger-enable-cmd yes
      )
      """

    let aliasBlock = renderAliasBlock(aliasDefinitions)
    let sourceBlock = renderDefsrcBlock(blocks)
    let baseLayerBlock = renderLayerBlock(name: RuleCollectionLayer.base.kanataName, blocks: blocks)
    { $0.baseOutput }
    let additionalLayerBlocks = extraLayers.map { layer in
      renderLayerBlock(name: layer.kanataName, blocks: blocks) { entry in
        entry.layerOutputs[layer] ?? "_"
      }
    }.joined(separator: "\n")
    let disabledBlock = renderDisabledCollections(disabledCollections)

    return [header, aliasBlock, sourceBlock, baseLayerBlock, additionalLayerBlocks, disabledBlock]
      .filter { !$0.isEmpty }
      .joined(separator: "\n")
  }

  private static let defaultEmptyConfig = generateFromCollections(defaultSystemCollections)

  // MARK: - Rendering helpers

  private static func renderAliasBlock(_ aliases: [AliasDefinition]) -> String {
    guard !aliases.isEmpty else { return "" }
    let definitions = aliases.map { "  \($0.aliasName) \($0.definition)" }.joined(separator: "\n")
    return """
      (defalias
      \(definitions)
      )

      """
  }

  private static func renderDefsrcBlock(_ blocks: [CollectionBlock]) -> String {
    var lines = ["(defsrc"]
    if blocks.isEmpty {
      lines.append("  ;; No enabled collections")
    } else {
      for block in blocks {
        lines.append(contentsOf: block.metadata)
        if block.entries.isEmpty {
          lines.append("  ;; (no mappings)")
        } else {
          for entry in block.entries {
            lines.append("  \(entry.sourceKey)")
          }
        }
        lines.append("")
      }
      if lines.last == "" { lines.removeLast() }
    }
    lines.append(")")
    return lines.joined(separator: "\n")
  }

  private static func renderLayerBlock(
    name: String,
    blocks: [CollectionBlock],
    valueProvider: (LayerEntry) -> String
  ) -> String {
    var lines = ["(deflayer \(name)"]
    if blocks.isEmpty {
      lines.append("  ;; No enabled collections")
    } else {
      for block in blocks {
        lines.append(contentsOf: block.metadata)
        if block.entries.isEmpty {
          lines.append("  ;; (no mappings)")
        } else {
          for entry in block.entries {
            lines.append("  \(valueProvider(entry))")
          }
        }
        lines.append("")
      }
      if lines.last == "" { lines.removeLast() }
    }
    lines.append(")")
    return lines.joined(separator: "\n")
  }

  private static func renderDisabledCollections(_ collections: [RuleCollection]) -> String {
    guard !collections.isEmpty else { return "" }
    return collections.map { renderDisabledSection($0) }.joined(separator: "\n\n")
  }

  private static func renderDisabledSection(_ collection: RuleCollection) -> String {
    var lines = metadataLines(for: collection, indent: "", status: "disabled")
    guard !collection.mappings.isEmpty else {
      lines.append(";; (no mappings)")
      return lines.joined(separator: "\n")
    }

    let sourceKeys = collection.mappings.map { KanataKeyConverter.convertToKanataKey($0.input) }
      .joined(separator: " ")
    let layerKeys = collection.mappings.map {
      KanataKeyConverter.convertToKanataSequence($0.output)
    }.joined(separator: " ")
    lines.append(contentsOf: [
      ";; (defsrc",
      ";;   \(sourceKeys)",
      ";; )",
      ";; (deflayer base",
      ";;   \(layerKeys)",
      ";; )",
    ])
    return lines.joined(separator: "\n")
  }

  private static func metadataLines(for collection: RuleCollection, indent: String, status: String)
    -> [String]
  {
    [
      "\(indent);; === Collection: \(collection.name) (\(status)) ===",
      "\(indent);; UUID: \(collection.id.uuidString)",
      "\(indent);; Description: \(collection.summary)",
    ]
  }

  private static func metadataLines(for activator: MomentaryActivator, indent: String) -> [String] {
    [
      "\(indent);; === Momentary Layer Switch ===",
      "\(indent);; Input: \(activator.input)",
      "\(indent);; Activates: \(activator.targetLayer.displayName)",
    ]
  }

  /// Get the system default collections (macOS Function Keys enabled by default)
  public static var systemDefaultCollections: [RuleCollection] {
    defaultSystemCollections
  }

  private static var defaultSystemCollections: [RuleCollection] {
    [
      RuleCollection(
        id: RuleCollectionIdentifier.macFunctionKeys,
        name: "macOS Function Keys",
        summary: "Preserves brightness, volume, and media control keys (F1-F12).",
        category: .system,
        mappings: macFunctionKeyMappings,
        isEnabled: true,
        isSystemDefault: true,
        icon: "keyboard",
        targetLayer: .base
      )
    ]
  }

  private static var macFunctionKeyMappings: [KeyMapping] {
    [
      KeyMapping(input: "f1", output: "brdn"),
      KeyMapping(input: "f2", output: "brup"),
      KeyMapping(input: "f3", output: "f3"),
      KeyMapping(input: "f4", output: "f4"),
      KeyMapping(input: "f7", output: "prev"),
      KeyMapping(input: "f8", output: "pp"),
      KeyMapping(input: "f9", output: "next"),
      KeyMapping(input: "f10", output: "mute"),
      KeyMapping(input: "f11", output: "vold"),
      KeyMapping(input: "f12", output: "volu"),
    ]
  }

  // MARK: - Block builders

  private static func buildCollectionBlocks(
    from collections: [RuleCollection]
  ) -> ([CollectionBlock], [AliasDefinition], [RuleCollectionLayer]) {
    var blocks: [CollectionBlock] = []
    var aliasDefinitions: [AliasDefinition] = []
    var additionalLayers: [RuleCollectionLayer] = []
    var seenLayers = Set<RuleCollectionLayer>()
    var activatorBlocks: [CollectionBlock] = []
    var seenActivators: Set<String> = []

    for collection in collections where collection.targetLayer != .base {
      if !seenLayers.contains(collection.targetLayer) {
        seenLayers.insert(collection.targetLayer)
        additionalLayers.append(collection.targetLayer)
      }
    }

    for collection in collections {
      guard collection.isEnabled, let activator = collection.momentaryActivator else { continue }
      let tapKey = KanataKeyConverter.convertToKanataKey(activator.input)
      let aliasName = aliasSafeName(layer: activator.targetLayer, key: tapKey)
      if !seenActivators.contains(aliasName) {
        seenActivators.insert(aliasName)
        let definition =
          "(tap-hold 200 200 \(tapKey) (layer-while-held \(activator.targetLayer.kanataName)))"
        aliasDefinitions.append(AliasDefinition(aliasName: aliasName, definition: definition))
        let entry = LayerEntry(
          sourceKey: tapKey,
          baseOutput: "@\(aliasName)",
          layerOutputs: [:]
        )
        let metadata = metadataLines(for: activator, indent: "  ")
        activatorBlocks.append(CollectionBlock(metadata: metadata, entries: [entry]))
      }
    }

    for collection in collections where collection.isEnabled {
      var metadata = metadataLines(for: collection, indent: "  ", status: "enabled")
      if collection.mappings.isEmpty {
        metadata.append("  ;; (no mappings)")
        blocks.append(CollectionBlock(metadata: metadata, entries: []))
        continue
      }
      let entries = collection.mappings.map { mapping -> LayerEntry in
        let sourceKey = KanataKeyConverter.convertToKanataKey(mapping.input)
        var layerOutputs: [RuleCollectionLayer: String] = [:]
        if collection.targetLayer != .base {
          layerOutputs[collection.targetLayer] = KanataKeyConverter.convertToKanataSequence(
            mapping.output)
        }
        let baseOutput: String =
          if collection.targetLayer == .base {
            KanataKeyConverter.convertToKanataSequence(mapping.output)
          } else {
            sourceKey
          }
        return LayerEntry(
          sourceKey: sourceKey,
          baseOutput: baseOutput,
          layerOutputs: layerOutputs
        )
      }
      blocks.append(CollectionBlock(metadata: metadata, entries: entries))
    }

    return (activatorBlocks + blocks, aliasDefinitions, additionalLayers)
  }

  private static func deduplicateBlocks(_ blocks: [CollectionBlock]) -> [CollectionBlock] {
    var seenSources: Set<String> = []
    return blocks.map { block in
      let uniqueEntries = block.entries.filter { entry in
        if seenSources.contains(entry.sourceKey) {
          return false
        }
        seenSources.insert(entry.sourceKey)
        return true
      }
      return CollectionBlock(metadata: block.metadata, entries: uniqueEntries)
    }
  }

  private static func aliasSafeName(layer: RuleCollectionLayer, key: String) -> String {
    let sanitized =
      key
      .replacingOccurrences(of: "-", with: "_")
      .replacingOccurrences(of: " ", with: "_")
    return "layer_\(layer.kanataName)_\(sanitized)"
  }

  private struct CollectionBlock {
    let metadata: [String]
    let entries: [LayerEntry]
  }

  private struct LayerEntry {
    let sourceKey: String
    let baseOutput: String
    let layerOutputs: [RuleCollectionLayer: String]
  }

  private struct AliasDefinition {
    let aliasName: String
    let definition: String
  }
}

// MARK: - Configuration Service

/// Centralized configuration management service for Kanata
///
/// This service handles all configuration-related operations:
/// - Loading and saving configuration files
/// - Validation via TCP and file-based checks
/// - File watching and change detection
/// - Key mapping generation and conversion
public final class ConfigurationService: FileConfigurationProviding {
  public typealias Config = KanataConfiguration

  // MARK: - Properties

  public let configurationPath: String
  public let configDirectory: String
  public let configFileName = "keypath.kbd"

  private var currentConfiguration: KanataConfiguration?
  private var fileWatcher: FileWatcher?
  private var observers: [@Sendable (Config) async -> Void] = []

  // Perform blocking file I/O off the main actor
  private let ioQueue = DispatchQueue(label: "com.keypath.configservice.io", qos: .utility)
  // Protect shared state when accessed from multiple threads
  private let stateLock = NSLock()

  // MARK: - Initialization

  public init(configDirectory: String? = nil) {
    if let customDirectory = configDirectory {
      self.configDirectory = customDirectory
    } else {
      self.configDirectory = "\(NSHomeDirectory())/.config/keypath"
    }
    configurationPath = "\(self.configDirectory)/\(configFileName)"
  }

  // MARK: - ConfigurationProviding Protocol

  public func current() async -> KanataConfiguration {
    // Fast path: return cached config if available
    if let cached = withLockedCurrentConfig() { return cached }

    // Try to load existing configuration, fallback to empty if not found
    do {
      let config = try await reload()
      return config
    } catch {
      AppLogger.shared.log("‚ö†Ô∏è [ConfigService] Failed to load current config, using empty: \(error)")
      let emptyConfig = KanataConfiguration(
        content: KanataConfiguration.generateFromMappings([]),
        keyMappings: [],
        lastModified: Date(),
        path: configurationPath
      )
      setCurrentConfiguration(emptyConfig)
      return emptyConfig
    }
  }

  public func reload() async throws -> KanataConfiguration {
    var exists = await fileExistsAsync(path: configurationPath)

    if !exists {
      AppLogger.shared.log(
        "‚ö†Ô∏è [ConfigService] Config missing at \(configurationPath) ‚Äì creating default before reload")
      do {
        try await createInitialConfigIfNeeded()
        exists = await fileExistsAsync(path: configurationPath)
      } catch {
        AppLogger.shared.log(
          "‚ùå [ConfigService] Failed to create default config during reload: \(error)")
      }
    }

    guard exists else {
      throw KeyPathError.configuration(.fileNotFound(path: configurationPath))
    }

    do {
      let content = try await readFileAsync(path: configurationPath)
      let config = try validate(content: content)
      setCurrentConfiguration(config)

      // Notify observers on main actor
      let snapshot = observersSnapshot()
      let tasks = snapshot.map { observer in
        Task { @MainActor in await observer(config) }
      }
      for t in tasks {
        await t.value
      }

      return config
    } catch let error as KeyPathError {
      throw error
    } catch {
      throw KeyPathError.configuration(.loadFailed(reason: error.localizedDescription))
    }
  }

  public func observe(_ onChange: @Sendable @escaping (Config) async -> Void)
    -> ConfigurationObservationToken
  {
    var index = 0
    stateLock.lock()
    observers.append(onChange)
    index = observers.count - 1
    stateLock.unlock()

    return ConfigurationObservationToken {
      self.stateLock.lock()
      if index < self.observers.count { self.observers.remove(at: index) }
      self.stateLock.unlock()
    }
  }

  // MARK: - FileConfigurationProviding Protocol

  public func validate(content: String) throws -> KanataConfiguration {
    // Basic validation - ensure content is not empty
    guard !content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
      throw KeyPathError.configuration(.invalidFormat(reason: "Configuration content is empty"))
    }

    // Get file modification date
    let attributes = try? FileManager.default.attributesOfItem(atPath: configurationPath)
    let lastModified = (attributes?[.modificationDate] as? Date) ?? Date()

    // Extract key mappings from content (simplified - could be enhanced)
    let keyMappings = extractKeyMappingsFromContent(content)

    return KanataConfiguration(
      content: content,
      keyMappings: keyMappings,
      lastModified: lastModified,
      path: configurationPath
    )
  }

  public func startFileMonitoring() -> ConfigurationObservationToken {
    guard fileWatcher == nil else {
      // Already monitoring
      return ConfigurationObservationToken { /* no-op */  }
    }

    fileWatcher = FileWatcher(path: configurationPath) { [weak self] in
      Task { @MainActor in
        await self?.handleFileChange()
      }
    }

    return ConfigurationObservationToken { [weak self] in
      self?.stopFileMonitoring()
    }
  }

  // MARK: - Configuration Management

  /// Create the configuration directory and initial config if needed
  public func createInitialConfigIfNeeded() async throws {
    // Create config directory if it doesn't exist (off-main)
    try await createDirectoryAsync(path: configDirectory)
    AppLogger.shared.log("‚úÖ [ConfigService] Config directory created at \(configDirectory)")

    // Check if config file exists
    let exists = await fileExistsAsync(path: configurationPath)
    if !exists {
      AppLogger.shared.log("‚ö†Ô∏è [ConfigService] No existing config found at \(configurationPath)")

      // Create empty configuration
      try await saveConfiguration(keyMappings: [])
      AppLogger.shared.log("‚úÖ [ConfigService] Created initial empty configuration")
    } else {
      AppLogger.shared.log("‚úÖ [ConfigService] Existing config found at \(configurationPath)")
    }
  }

  /// Save configuration using rule collections.
  /// IMPORTANT: Validates config before saving - will throw on invalid config
  public func saveConfiguration(
    ruleCollections: [RuleCollection],
    customRules: [CustomRule] = []
  ) async throws {
    let combinedCollections = ruleCollections + customRules.asRuleCollections()
    let mappings = combinedCollections.enabledMappings()
    let configContent = KanataConfiguration.generateFromCollections(combinedCollections)

    // VALIDATE BEFORE SAVING - prevent writing broken configs
    AppLogger.shared.log("üîç [ConfigService] Validating config before save...")
    let validation = await validateConfiguration(configContent)

    if !validation.isValid {
      AppLogger.shared.log(
        "‚ùå [ConfigService] Config validation failed: \(validation.errors.joined(separator: ", "))")
      throw KeyPathError.configuration(.validationFailed(errors: validation.errors))
    }

    AppLogger.shared.log("‚úÖ [ConfigService] Config validation passed")

    try await writeFileAsync(string: configContent, to: configurationPath)

    // Update current configuration
    let newConfig = KanataConfiguration(
      content: configContent,
      keyMappings: mappings,
      lastModified: Date(),
      path: configurationPath
    )
    setCurrentConfiguration(newConfig)

    // Notify observers on main actor
    let snapshot = observersSnapshot()
    let tasks = snapshot.map { observer in
      Task { @MainActor in await observer(newConfig) }
    }
    for t in tasks {
      await t.value
    }

    AppLogger.shared.log("‚úÖ [ConfigService] Configuration saved with \(mappings.count) mappings")
  }

  /// Save configuration with key mappings (legacy helper)
  public func saveConfiguration(keyMappings: [KeyMapping]) async throws {
    let collections = [RuleCollection].collection(
      named: "Custom Mappings",
      mappings: keyMappings,
      category: .custom
    )
    try await saveConfiguration(ruleCollections: collections)
  }

  /// Save configuration with specific input/output mapping
  public func saveConfiguration(input: String, output: String) async throws {
    let keyMapping = KeyMapping(input: input, output: output)
    try await saveConfiguration(keyMappings: [keyMapping])
  }

  // MARK: - Validation

  /// Validate configuration via file-based check
  public func validateConfigViaFile() -> (isValid: Bool, errors: [String]) {
    let binaryPath = WizardSystemPaths.kanataActiveBinary
    guard FileManager.default.isExecutableFile(atPath: binaryPath) else {
      let message = "Kanata binary missing at \(binaryPath)"
      AppLogger.shared.log("‚ùå [ConfigService] File validation skipped: \(message)")
      if TestEnvironment.isTestMode {
        return (true, [])
      }
      return (false, [message])
    }

    let task = Process()
    task.executableURL = URL(fileURLWithPath: binaryPath)
    task.arguments = buildKanataArguments(checkOnly: true)

    let pipe = Pipe()
    task.standardOutput = pipe
    task.standardError = pipe

    var errors: [String] = []

    do {
      try task.run()
      task.waitUntilExit()

      let data = pipe.fileHandleForReading.readDataToEndOfFile()
      let output = String(data: data, encoding: .utf8) ?? ""

      if task.terminationStatus == 0 {
        AppLogger.shared.log("‚úÖ [ConfigService] File validation passed")
        return (true, [])
      } else {
        // Parse errors from output
        let lines = output.components(separatedBy: .newlines)
        for line in lines where !line.isEmpty && (line.contains("error") || line.contains("Error"))
        {
          errors.append(line.trimmingCharacters(in: .whitespaces))
        }

        if errors.isEmpty {
          errors.append("Configuration validation failed (exit code: \(task.terminationStatus))")
        }

        AppLogger.shared.log("‚ùå [ConfigService] File validation failed: \(errors)")
        return (false, errors)
      }

    } catch {
      AppLogger.shared.log("‚ùå [ConfigService] File validation error: \(error)")
      return (false, ["Failed to validate configuration file: \(error.localizedDescription)"])
    }
  }

  /// Validate configuration content using TCP if available, else CLI
  public func validateConfiguration(_ config: String) async -> (isValid: Bool, errors: [String]) {
    AppLogger.shared.log("üîç [Validation] ========== CONFIG VALIDATION START ==========")
    AppLogger.shared.log("üîç [Validation] Config size: \(config.count) characters")

    if TestEnvironment.isTestMode {
      AppLogger.shared.log("üß™ [Validation] Test mode detected ‚Äì using lightweight validation")
      let result = validateConfigurationInTestMode(config)
      AppLogger.shared.log("üîç [Validation] ========== CONFIG VALIDATION END ==========")
      return result
    }

    // Try TCP validation first
    let tcpPort = PreferencesService.shared.tcpServerPort
    let tcpClient = KanataTCPClient(port: tcpPort)

    let tcpResult = await tcpClient.validateConfig(config)

    // FIX #1: Explicitly close connection to prevent file descriptor leak
    await tcpClient.cancelInflightAndCloseConnection()

    switch tcpResult {
    case .success:
      AppLogger.shared.log("üåê [Validation] TCP validation PASSED")
      AppLogger.shared.log("üîç [Validation] ========== CONFIG VALIDATION END ==========")
      return (true, [])
    case .failure(let errors):
      AppLogger.shared.log("üåê [Validation] TCP validation FAILED with \(errors.count) errors")
      AppLogger.shared.log("üîç [Validation] ========== CONFIG VALIDATION END ==========")
      return (false, errors)
    case .networkError:
      AppLogger.shared.log("üåê [Validation] TCP validation unavailable, falling back to CLI")
      let cliResult = await validateConfigWithCLI(config)
      AppLogger.shared.log("üîç [Validation] ========== CONFIG VALIDATION END ==========")
      return cliResult
    }
  }

  /// Validate configuration via CLI (kanata --check)
  private func validateConfigWithCLI(_ config: String) async -> (isValid: Bool, errors: [String]) {
    AppLogger.shared.log("üñ•Ô∏è [Validation-CLI] Starting CLI validation process...")

    // Write config to a temporary file for validation
    let tempConfigPath = "\(configDirectory)/temp_validation.kbd"
    AppLogger.shared.log("üìù [Validation-CLI] Creating temp config file: \(tempConfigPath)")

    do {
      let tempConfigURL = URL(fileURLWithPath: tempConfigPath)
      let configDir = URL(fileURLWithPath: configDirectory)
      try FileManager.default.createDirectory(at: configDir, withIntermediateDirectories: true)
      try await writeFileURLAsync(string: config, to: tempConfigURL)
      AppLogger.shared.log(
        "üìù [Validation-CLI] Temp config written successfully (\(config.count) characters)")

      // Use kanata --check to validate
      let kanataBinary = WizardSystemPaths.kanataActiveBinary
      AppLogger.shared.log("üîß [Validation-CLI] Using kanata binary: \(kanataBinary)")

      guard FileManager.default.isExecutableFile(atPath: kanataBinary) else {
        let message = "Kanata binary missing at \(kanataBinary)"
        AppLogger.shared.log("‚ùå [Validation-CLI] \(message)")
        if TestEnvironment.isTestMode {
          AppLogger.shared.log("üß™ [Validation-CLI] Skipping CLI validation in tests")
          try? FileManager.default.removeItem(at: tempConfigURL)
          return (true, [])
        }
        try? FileManager.default.removeItem(at: tempConfigURL)
        return (false, [message])
      }

      let task = Process()
      task.executableURL = URL(fileURLWithPath: kanataBinary)
      let arguments = ["--cfg", tempConfigPath, "--check"]
      task.arguments = arguments
      AppLogger.shared.log(
        "üîß [Validation-CLI] Command: \(kanataBinary) \(arguments.joined(separator: " "))")

      let pipe = Pipe()
      task.standardOutput = pipe
      task.standardError = pipe

      let cliStart = Date()
      try task.run()
      task.waitUntilExit()
      let cliDuration = Date().timeIntervalSince(cliStart)
      AppLogger.shared.log(
        "‚è±Ô∏è [Validation-CLI] CLI validation completed in \(String(format: "%.3f", cliDuration)) seconds"
      )

      let data = pipe.fileHandleForReading.readDataToEndOfFile()
      let output = String(data: data, encoding: .utf8) ?? ""

      AppLogger.shared.log("üìã [Validation-CLI] Exit code: \(task.terminationStatus)")
      if !output.isEmpty {
        AppLogger.shared.log("üìã [Validation-CLI] Output: \(output.prefix(500))...")
      }

      // Clean up temp file
      try? FileManager.default.removeItem(at: tempConfigURL)
      AppLogger.shared.log("üóëÔ∏è [Validation-CLI] Temp file cleaned up")

      if task.terminationStatus == 0 {
        AppLogger.shared.log("‚úÖ [Validation-CLI] CLI validation PASSED")
        return (true, [])
      } else {
        let errors = parseKanataErrors(output)
        AppLogger.shared.log(
          "‚ùå [Validation-CLI] CLI validation FAILED with \(errors.count) errors:")
        for (index, error) in errors.enumerated() {
          AppLogger.shared.log("   Error \(index + 1): \(error)")
        }
        return (false, errors)
      }
    } catch {
      // Clean up temp file on error
      try? FileManager.default.removeItem(atPath: tempConfigPath)
      AppLogger.shared.log("‚ùå [Validation-CLI] Validation process failed: \(error)")
      AppLogger.shared.log("‚ùå [Validation-CLI] Error type: \(type(of: error))")
      return (false, ["Validation failed: \(error.localizedDescription)"])
    }
  }

  private func validateConfigurationInTestMode(_ config: String) -> (
    isValid: Bool, errors: [String]
  ) {
    guard !config.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
      return (false, ["Configuration content is empty"])
    }

    do {
      _ = try parseConfigurationFromString(config)
      return (true, [])
    } catch {
      return (false, ["Mock validation failed: \(error.localizedDescription)"])
    }
  }

  // MARK: - Backup and Recovery

  /// Backs up a failed config and applies safe default, returning backup path
  public func backupFailedConfigAndApplySafe(failedConfig: String, mappings: [KeyMapping])
    async throws
    -> String
  {
    AppLogger.shared.log("üõ°Ô∏è [Config] Backing up failed config and applying safe default")

    // Create backup directory if it doesn't exist
    let backupDir = "\(configDirectory)/backups"
    let backupDirURL = URL(fileURLWithPath: backupDir)
    try FileManager.default.createDirectory(at: backupDirURL, withIntermediateDirectories: true)

    // Create timestamped backup filename
    let formatter = DateFormatter()
    formatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
    let timestamp = formatter.string(from: Date())

    let backupPath = "\(backupDir)/failed_config_\(timestamp).kbd"
    let backupURL = URL(fileURLWithPath: backupPath)

    // Write the failed config to backup
    let backupContent = """
      ;; FAILED CONFIG - AUTOMATICALLY BACKED UP
      ;; Timestamp: \(timestamp)
      ;; Errors: \(mappings.count) mapping(s) could not be applied

      \(failedConfig)
      """
    try await writeFileURLAsync(string: backupContent, to: backupURL)

    AppLogger.shared.log("üíæ [Config] Failed config backed up to: \(backupPath)")

    // Apply safe default config using the standard generator
    let safeConfig = KanataConfiguration.generateFromMappings(mappings)

    let configURL = URL(fileURLWithPath: configurationPath)
    try await writeFileURLAsync(string: safeConfig, to: configURL)

    AppLogger.shared.log("‚úÖ [Config] Safe default config applied")

    // Update current configuration
    setCurrentConfiguration(
      KanataConfiguration(
        content: safeConfig,
        keyMappings: [KeyMapping(input: "caps", output: "escape")],
        lastModified: Date(),
        path: configurationPath
      ))

    return backupPath
  }

  /// Repair configuration using rule-based strategies (keeps output Kanata-compatible).
  public func repairConfiguration(config: String, errors: [String], mappings: [KeyMapping])
    async throws
    -> String
  {
    AppLogger.shared.log("üîß [Config] Performing rule-based repair for \(errors.count) errors")

    // Common repair strategies
    var repairedConfig = config

    for error in errors {
      let lowerError = error.lowercased()

      // Fix common syntax errors
      if lowerError.contains("missing"), lowerError.contains("defcfg") {
        // Add missing defcfg using the same safe defaults as our generator
        if !repairedConfig.contains("(defcfg") {
          let defcfgSection = """
            (defcfg
              process-unmapped-keys yes
              danger-enable-cmd yes
            )

            """
          repairedConfig = defcfgSection + repairedConfig
        }
      }

      // Fix empty parentheses issues
      if lowerError.contains("()") || lowerError.contains("empty") {
        repairedConfig = repairedConfig.replacingOccurrences(of: "()", with: "_")
        repairedConfig = repairedConfig.replacingOccurrences(of: "( )", with: "_")
      }

      // Fix mismatched defsrc/deflayer lengths
      if lowerError.contains("mismatch") || lowerError.contains("length") {
        // Regenerate from scratch using our proven template
        return KanataConfiguration.generateFromMappings(mappings)
      }
    }

    return repairedConfig
  }

  // MARK: - Private Methods

  private func handleFileChange() async {
    AppLogger.shared.log("üìÅ [ConfigService] Configuration file changed - reloading")
    do {
      _ = try await reload()
      AppLogger.shared.log("‚úÖ [ConfigService] Configuration reloaded successfully")
    } catch {
      AppLogger.shared.log("‚ùå [ConfigService] Failed to reload configuration: \(error)")
    }
  }

  private func stopFileMonitoring() {
    fileWatcher = nil
    AppLogger.shared.log("üõë [ConfigService] File monitoring stopped")
  }

  /// Extract key mappings from Kanata configuration content
  private func extractKeyMappingsFromContent(_ configContent: String) -> [KeyMapping] {
    var mappings: [KeyMapping] = []
    let lines = configContent.components(separatedBy: .newlines)

    var inDefsrc = false
    var inDeflayer = false
    var srcKeys: [String] = []
    var layerKeys: [String] = []

    for line in lines {
      let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)

      if trimmed.hasPrefix("(defsrc") {
        inDefsrc = true
        inDeflayer = false
        continue
      } else if trimmed.hasPrefix("(deflayer") {
        inDefsrc = false
        inDeflayer = true
        continue
      } else if trimmed == ")" {
        inDefsrc = false
        inDeflayer = false
        continue
      }

      if inDefsrc, !trimmed.isEmpty, !trimmed.hasPrefix(";") {
        srcKeys.append(
          contentsOf: trimmed.components(separatedBy: .whitespaces).filter { !$0.isEmpty })
      } else if inDeflayer, !trimmed.isEmpty, !trimmed.hasPrefix(";") {
        layerKeys.append(
          contentsOf: trimmed.components(separatedBy: .whitespaces).filter { !$0.isEmpty })
      }
    }

    // Match up src and layer keys, filtering out invalid keys
    var tempMappings: [KeyMapping] = []
    for (index, srcKey) in srcKeys.enumerated() where index < layerKeys.count {
      // Skip obviously invalid keys
      if srcKey != "invalid", !srcKey.isEmpty {
        tempMappings.append(KeyMapping(input: srcKey, output: layerKeys[index]))
      }
    }

    // Deduplicate mappings - keep only the last mapping for each input key
    var seenInputs: Set<String> = []
    for mapping in tempMappings.reversed() where !seenInputs.contains(mapping.input) {
      mappings.insert(mapping, at: 0)
      seenInputs.insert(mapping.input)
    }

    AppLogger.shared.log(
      "üîç [Parse] Found \(srcKeys.count) src keys, \(layerKeys.count) layer keys, deduplicated to \(mappings.count) unique mappings"
    )
    return mappings
  }

  private func buildKanataArguments(checkOnly: Bool = false) -> [String] {
    var args = ["--cfg", configurationPath]
    if checkOnly {
      args.append("--check")
    }

    // Add TCP port argument for actual runs (not validation checks)
    if !checkOnly {
      let tcpPort = PreferencesService.shared.tcpServerPort
      args.append(contentsOf: ["--port", "\(tcpPort)"])
      AppLogger.shared.log("üì° [ConfigService] Added TCP port argument: --port \(tcpPort)")
    }

    return args
  }

  /// Parse configuration from string content
  public func parseConfigurationFromString(_ content: String) throws -> KanataConfiguration {
    // Use the existing validate method which handles parsing
    try validate(content: content)
  }

  /// Parse Kanata error output to extract error messages
  public func parseKanataErrors(_ output: String) -> [String] {
    var errors: [String] = []
    let lines = output.components(separatedBy: .newlines)

    for line in lines where line.contains("[ERROR]") {
      // Extract the actual error message
      if let errorRange = line.range(of: "[ERROR]") {
        let errorMessage = String(line[errorRange.upperBound...]).trimmingCharacters(
          in: .whitespaces)
        errors.append(errorMessage)
      }
    }

    // Don't return empty strings - if no specific errors found and output is empty/whitespace,
    // return empty array instead of an array with empty string
    if errors.isEmpty {
      let trimmedOutput = output.trimmingCharacters(in: .whitespacesAndNewlines)
      if !trimmedOutput.isEmpty {
        // If there's non-empty output but no [ERROR] tags, include the full output as error
        errors.append(trimmedOutput)
      }
    }

    return errors
  }
}

// MARK: - Private helpers (I/O and state)

extension ConfigurationService {
  fileprivate func withLockedCurrentConfig() -> KanataConfiguration? {
    stateLock.lock()
    defer { stateLock.unlock() }
    return currentConfiguration
  }

  fileprivate func setCurrentConfiguration(_ config: KanataConfiguration) {
    stateLock.lock()
    defer { stateLock.unlock() }
    currentConfiguration = config
  }

  fileprivate func observersSnapshot() -> [@Sendable (Config) async -> Void] {
    stateLock.lock()
    defer { stateLock.unlock() }
    return observers
  }

  fileprivate func readFileAsync(path: String) async throws -> String {
    try await withCheckedThrowingContinuation { cont in
      ioQueue.async {
        do {
          let content = try String(contentsOfFile: path, encoding: .utf8)
          cont.resume(returning: content)
        } catch {
          cont.resume(throwing: error)
        }
      }
    }
  }

  fileprivate func writeFileAsync(string: String, to path: String) async throws {
    try await withCheckedThrowingContinuation { cont in
      ioQueue.async {
        do {
          try string.write(toFile: path, atomically: true, encoding: .utf8)
          cont.resume()
        } catch {
          cont.resume(throwing: error)
        }
      }
    }
  }

  fileprivate func writeFileURLAsync(string: String, to url: URL) async throws {
    try await withCheckedThrowingContinuation { cont in
      ioQueue.async {
        do {
          try string.write(to: url, atomically: true, encoding: .utf8)
          cont.resume()
        } catch {
          cont.resume(throwing: error)
        }
      }
    }
  }

  fileprivate func createDirectoryAsync(path: String) async throws {
    try await withCheckedThrowingContinuation { cont in
      ioQueue.async {
        do {
          try FileManager.default.createDirectory(
            atPath: path,
            withIntermediateDirectories: true,
            attributes: [.posixPermissions: 0o755]
          )
          cont.resume()
        } catch {
          cont.resume(throwing: error)
        }
      }
    }
  }

  fileprivate func fileExistsAsync(path: String) async -> Bool {
    await withCheckedContinuation { cont in
      ioQueue.async {
        cont.resume(returning: FileManager.default.fileExists(atPath: path))
      }
    }
  }
}

// MARK: - Key Conversion Utilities

/// Utility class for converting keys between KeyPath and Kanata formats
public enum KanataKeyConverter {
  /// Convert KeyPath input key to Kanata key format
  public static func convertToKanataKey(_ input: String) -> String {
    // Use the same key mapping logic as the original KanataManager
    let keyMap: [String: String] = [
      "caps": "caps",
      "capslock": "caps",
      "caps lock": "caps",
      "space": "spc",
      "spacebar": "spc",
      "enter": "ret",
      "return": "ret",
      "tab": "tab",
      "escape": "esc",
      "esc": "esc",
      "backspace": "bspc",
      "delete": "del",
      "cmd": "lmet",
      "command": "lmet",
      "lcmd": "lmet",
      "rcmd": "rmet",
      "leftcmd": "lmet",
      "rightcmd": "rmet",
      "left command": "lmet",
      "right command": "rmet",
      "left shift": "lsft",
      "lshift": "lsft",
      "right shift": "rsft",
      "rshift": "rsft",
      "left control": "lctl",
      "lctrl": "lctl",
      "ctrl": "lctl",
      "right control": "rctl",
      "rctrl": "rctl",
      "left option": "lalt",
      "lalt": "lalt",
      "right option": "ralt",
      "ralt": "ralt",
      "(": "lpar",
      ")": "rpar",
    ]

    let lowercased = input.lowercased()

    // Check if we have a specific mapping
    if let mapped = keyMap[lowercased] {
      return mapped
    }

    // For single characters, return as-is
    if lowercased.count == 1 {
      return lowercased
    }

    // For tokens that would break Kanata syntax, replace parens explicitly
    if lowercased.contains("(") { return "lpar" }
    if lowercased.contains(")") { return "rpar" }

    // For function keys and others, return as-is but lowercased
    return lowercased
  }

  /// Convert KeyPath output sequence to Kanata output format
  public static func convertToKanataSequence(_ output: String) -> String {
    let trimmed = output.trimmingCharacters(in: .whitespacesAndNewlines)

    // Split on any whitespace
    let tokens = trimmed.components(separatedBy: .whitespacesAndNewlines).filter { !$0.isEmpty }

    // No tokens -> nothing to emit (avoid indexing empty array)
    if tokens.isEmpty {
      return ""
    }

    // Multiple whitespace-separated tokens (e.g., "cmd space") ‚Üí chord/sequence
    if tokens.count > 1 {
      let kanataKeys = tokens.map { convertToKanataKey($0) }
      return "(\(kanataKeys.joined(separator: " ")))"
    }

    // Single token - check if it's a text sequence to type (e.g., "123", "hello")
    let singleToken = tokens[0]

    // If it's a multi-character string that looks like text to type (not a key name)
    // Convert to macro for typing each character
    if singleToken.count > 1, shouldConvertToMacro(singleToken) {
      // Split into individual characters and convert each to a key
      let characters = Array(singleToken)
      let keys = characters.map { String($0) }
      return "(macro \(keys.joined(separator: " ")))"
    }

    // Single key: just convert the key name, no parentheses
    return convertToKanataKey(singleToken)
  }

  /// Determine if a string should be converted to a macro (typed character by character)
  /// vs treated as a single key name like "escape" or "tab"
  private static func shouldConvertToMacro(_ token: String) -> Bool {
    // Known key names that shouldn't be split into macros
    let keyNames: Set<String> = [
      "escape", "esc", "return", "ret", "enter",
      "backspace", "bspc", "delete", "del",
      "tab", "space", "spc",
      "capslock", "caps", "capslk",
      "leftshift", "lsft", "rightshift", "rsft",
      "leftctrl", "lctl", "rightctrl", "rctl", "ctrl",
      "leftalt", "lalt", "rightalt", "ralt",
      "leftmeta", "lmet", "rightmeta", "rmet",
      "leftcmd", "rightcmd", "cmd", "command", "lcmd", "rcmd",
      "up", "down", "left", "right",
      "home", "end", "pageup", "pgup", "pagedown", "pgdn",
      "f1", "f2", "f3", "f4", "f5", "f6",
      "f7", "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
      "f16", "f17", "f18", "f19", "f20",
      // Kanata media/system outputs
      "brdn", "brup", "mission_control", "launchpad",
      "prev", "pp", "next", "mute", "vold", "volu",
    ]

    // If it's a known key name, don't convert to macro
    if keyNames.contains(token.lowercased()) {
      return false
    }

    // If it contains multiple alphanumeric characters or symbols, treat as text to type
    return token.count > 1
  }
}

// MARK: - File Watcher (Simplified)

/// Simple file watcher for configuration changes
private class FileWatcher {
  private let path: String
  private let callback: () -> Void
  private var source: DispatchSourceFileSystemObject?

  init(path: String, callback: @escaping () -> Void) {
    self.path = path
    self.callback = callback
    startWatching()
  }

  deinit {
    stopWatching()
  }

  private func startWatching() {
    let fileDescriptor = open(path, O_RDONLY)
    guard fileDescriptor >= 0 else {
      AppLogger.shared.log("‚ùå [FileWatcher] Could not open file for watching: \(path)")
      return
    }

    source = DispatchSource.makeFileSystemObjectSource(
      fileDescriptor: fileDescriptor,
      eventMask: [.write, .delete, .rename],
      queue: DispatchQueue.global(qos: .utility)
    )

    source?.setEventHandler { [weak self] in
      self?.callback()
    }

    source?.setCancelHandler {
      close(fileDescriptor)
    }

    source?.resume()
  }

  private func stopWatching() {
    source?.cancel()
    source = nil
  }
}
