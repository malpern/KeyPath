import ApplicationServices
import Foundation
import IOKit.hidsystem
import KeyPathCore
import KeyPathDaemonLifecycle
import Network
import SwiftUI

// MARK: - Kanata Configuration Model

/// Represents Kanata configuration data and metadata
public struct KanataConfiguration: Sendable {
    public let content: String
    public let keyMappings: [KeyMapping]
    public let lastModified: Date
    public let path: String

    public init(content: String, keyMappings: [KeyMapping], lastModified: Date, path: String) {
        self.content = content
        self.keyMappings = keyMappings
        self.lastModified = lastModified
        self.path = path
    }

    /// Generate configuration content from key mappings (adds default system collections when absent).
    public static func generateFromMappings(_ mappings: [KeyMapping]) -> String {
        let collections = [RuleCollection].collection(named: "Custom Mappings", mappings: mappings)
        return generateFromCollections(collections)
    }

    /// Generate configuration content from rule collections.
    /// Flattens enabled collections to `defsrc`/`deflayer` for backward compatibility with Kanata config format.
    public static func generateFromCollections(_ collections: [RuleCollection]) -> String {
        var resolvedCollections = collections.isEmpty ? defaultSystemCollections : collections
        if !resolvedCollections.contains(where: { $0.id == RuleCollectionIdentifier.macFunctionKeys }) {
            resolvedCollections.append(contentsOf: defaultSystemCollections)
        }
        resolvedCollections = RuleCollectionDeduplicator.dedupe(resolvedCollections)
        let enabledCollections = resolvedCollections.filter(\.isEnabled)
        // Note: Disabled collections are NOT written to config (ADR-025: JSON stores are source of truth)
        let (rawBlocks, aliasDefinitions, extraLayers, chordMappings) = buildCollectionBlocks(from: enabledCollections)
        let blocks = deduplicateBlocks(rawBlocks)
        let enabledNames = enabledCollections.map(\.name).joined(separator: ", ")
        let header = """
        ;; Generated by KeyPath
        ;; Enabled: \(enabledNames.isEmpty ? "none" : enabledNames)

        (defcfg
          process-unmapped-keys yes
          danger-enable-cmd yes
        )
        """

        let safetyNotes = """
        ;; SAFETY: This configuration is auto-generated. Do not edit by hand.
        ;; SAFETY: Only explicitly enabled mappings are written to this file.
        ;; EMERGENCY EXIT: Hold Left Control + Space + Escape to force-quit Kanata
        """

        let defvarBlock = renderDefvarBlock()
        let sourceBlock = renderDefsrcBlock(blocks)
        let baseLayerBlock = renderLayerBlock(name: RuleCollectionLayer.base.kanataName, blocks: blocks) { $0.baseOutput }
        let additionalLayerBlocks = extraLayers.map { layer in
            renderLayerBlock(name: layer.kanataName, blocks: blocks) { entry in
                entry.layerOutputs[layer] ?? "_"
            }
        }.joined(separator: "\n")
        let fakeKeysBlock = renderFakeKeysBlock(extraLayers)
        let aliasBlock = renderAliasBlock(aliasDefinitions)
        let chordsBlock = renderChordsBlock(chordMappings)

        return [header, safetyNotes, defvarBlock, sourceBlock, baseLayerBlock, additionalLayerBlocks, fakeKeysBlock, aliasBlock, chordsBlock]
            .filter { !$0.isEmpty }
            .joined(separator: "\n")
    }

    private static let defaultEmptyConfig = generateFromCollections(defaultSystemCollections)

    // MARK: - Rendering helpers

    /// Render defvar block with timing variables for reuse across the config.
    /// These variables allow users to globally adjust timing values.
    private static func renderDefvarBlock() -> String {
        """
        #|
        ================================================================================
        TIMING VARIABLES
        ================================================================================
        |#

        (defvar
          tap-timeout   200
          hold-timeout  200
          chord-timeout  50
        )

        """
    }

    private static func renderAliasBlock(_ aliases: [AliasDefinition]) -> String {
        guard !aliases.isEmpty else { return "" }
        var lines = [
            "#|",
            "================================================================================",
            "ALIAS DEFINITIONS (defalias)",
            "================================================================================",
            "|#",
            "",
            "(defalias"
        ]
        let definitions = aliases.map { alias in
            // Format multi-line actions with proper indentation
            let formattedDef = formatMultiLineAction(alias.definition)
            return "  \(alias.aliasName) \(formattedDef)"
        }
        lines.append(contentsOf: definitions)
        lines.append(")")
        lines.append("")
        return lines.joined(separator: "\n")
    }

    /// Format complex actions across multiple lines for better readability.
    /// Handles common patterns like multi actions and long tap-hold chains.
    private static func formatMultiLineAction(_ action: String) -> String {
        // If action already contains newlines (from our formatting), return as-is
        if action.contains("\n") {
            return action
        }

        // Only format if action is long enough to benefit from multi-line
        guard action.count > 80 else {
            return action
        }

        // Format multi actions with multiple components
        if action.hasPrefix("(multi "), action.count > 100 {
            return formatMultiAction(action)
        }

        // Format long tap-hold actions that contain multi
        if action.contains("(tap-hold") || action.contains("(tap-hold-press") || action.contains("(tap-hold-release"), action.contains("(multi ") {
            return formatTapHoldWithMulti(action)
        }

        // Otherwise, return as-is to avoid breaking valid syntax
        return action
    }

    /// Format a multi action across multiple lines.
    /// Only handles simple cases to avoid breaking valid syntax.
    private static func formatMultiAction(_ action: String) -> String {
        // Extract components from (multi comp1 comp2 comp3)
        guard action.hasPrefix("(multi "), action.hasSuffix(")") else {
            return action
        }

        let inner = String(action.dropFirst(7).dropLast(1)) // Remove "(multi " and ")"

        // Count top-level components (separated by spaces at depth 0)
        var parenDepth = 0
        var componentCount = 0
        var lastWasSpace = false

        for char in inner {
            if char == "(" {
                parenDepth += 1
                lastWasSpace = false
            } else if char == ")" {
                parenDepth -= 1
                lastWasSpace = false
            } else if char == " ", parenDepth == 0 {
                if !lastWasSpace {
                    componentCount += 1
                }
                lastWasSpace = true
            } else {
                lastWasSpace = false
            }
        }

        // Only format if we have 3+ components (multi with 2+ items)
        guard componentCount >= 2 else {
            return action
        }

        // Simple formatting: split on spaces at depth 0
        var result = "(multi\n"
        var currentComponent = ""
        parenDepth = 0

        for char in inner {
            if char == "(" {
                currentComponent.append(char)
                parenDepth += 1
            } else if char == ")" {
                currentComponent.append(char)
                parenDepth -= 1
            } else if char == " ", parenDepth == 0 {
                // Space at top level - start new component
                let trimmed = currentComponent.trimmingCharacters(in: .whitespaces)
                if !trimmed.isEmpty {
                    result += "    \(trimmed)\n"
                }
                currentComponent = ""
            } else {
                currentComponent.append(char)
            }
        }

        // Add final component
        let trimmed = currentComponent.trimmingCharacters(in: .whitespaces)
        if !trimmed.isEmpty {
            result += "    \(trimmed)\n"
        }

        result += "  )"
        return result
    }

    /// Format tap-hold actions that contain multi sub-actions.
    private static func formatTapHoldWithMulti(_ action: String) -> String {
        // Pattern: (tap-hold timeout timeout key (multi ...))
        // We want: (tap-hold timeout timeout key\n  (multi\n    ...))

        // Find the (multi part
        guard let multiStart = action.range(of: "(multi ") else {
            return action
        }

        let beforeMulti = String(action[..<multiStart.lowerBound]).trimmingCharacters(in: .whitespaces)
        let multiPart = String(action[multiStart.lowerBound...])

        // Format the multi part
        let formattedMulti = formatMultiAction(multiPart)

        // Combine with proper indentation
        if formattedMulti.contains("\n") {
            return "\(beforeMulti)\n  \(formattedMulti.replacingOccurrences(of: "\n", with: "\n  "))"
        }

        return action
    }

    /// Render deffakekeys block for layer change notifications.
    /// Creates fake keys that send push-msg when layers are entered/exited,
    /// working around Kanata's limitation where layer-while-held doesn't broadcast LayerChange TCP messages.
    private static func renderFakeKeysBlock(_ layers: [RuleCollectionLayer]) -> String {
        guard !layers.isEmpty else { return "" }
        var lines = [
            "#|",
            "================================================================================",
            "VIRTUAL KEYS (deffakekeys)",
            "================================================================================",
            "|#",
            "",
            ";; Used to broadcast layer changes via TCP (layer-while-held doesn't do this natively)",
            "(deffakekeys"
        ]
        // Add enter/exit fake keys for each non-base layer
        for layer in layers {
            let layerName = layer.kanataName
            lines.append("  kp-layer-\(layerName)-enter (push-msg \"layer:\(layerName)\")")
            lines.append("  kp-layer-\(layerName)-exit (push-msg \"layer:base\")")
        }
        lines.append(")")
        return lines.joined(separator: "\n") + "\n"
    }

    /// Render defchordsv2 block for chord mappings (simultaneous key presses)
    private static func renderChordsBlock(_ chordMappings: [ChordMapping]) -> String {
        guard !chordMappings.isEmpty else { return "" }
        var lines = [
            "#|",
            "================================================================================",
            "CHORD MAPPINGS (defchordsv2)",
            "================================================================================",
            "|#",
            "",
            "(defchordsv2"
        ]
        for chord in chordMappings {
            // Format: (key1 key2) output timeout release-behavior ()
            // timeout: uses $chord-timeout variable (default 50ms)
            // all-released: trigger when all keys are released
            lines.append("  (\(chord.inputKeys)) \(chord.output) $chord-timeout all-released ()")
        }
        lines.append(")")
        return lines.joined(separator: "\n") + "\n"
    }

    /// Represents a chord mapping (simultaneous key presses)
    private struct ChordMapping {
        let inputKeys: String // Space-separated keys, e.g., "lsft rsft"
        let output: String // Output action, e.g., "caps"
        let description: String?
    }

    private static func renderDefsrcBlock(_ blocks: [CollectionBlock]) -> String {
        var lines = [
            "#|",
            "================================================================================",
            "PHYSICAL KEYBOARD LAYOUT (defsrc)",
            "================================================================================",
            "|#",
            "",
            "(defsrc"
        ]
        if blocks.isEmpty {
            lines.append("  ;; No enabled collections")
        } else {
            for block in blocks {
                lines.append(contentsOf: KeyboardGridFormatter.renderDefsrc(block))
                lines.append("")
            }
            if lines.last == "" { lines.removeLast() }
        }
        lines.append(")")
        return lines.joined(separator: "\n")
    }

    private static func renderLayerBlock(
        name: String,
        blocks: [CollectionBlock],
        valueProvider: (LayerEntry) -> String
    ) -> String {
        var lines: [String] = []

        // Add section header for base layer only (other layers are grouped)
        if name == "base" {
            lines.append(contentsOf: [
                "#|",
                "================================================================================",
                "LAYER DEFINITIONS",
                "================================================================================",
                "|#",
                ""
            ])
        }

        lines.append("(deflayer \(name)")
        if blocks.isEmpty {
            lines.append("  ;; No enabled collections")
        } else {
            for block in blocks {
                lines.append(contentsOf: KeyboardGridFormatter.renderLayer(block, valueProvider: valueProvider))
                lines.append("")
            }
            if lines.last == "" { lines.removeLast() }
        }
        lines.append(")")
        return lines.joined(separator: "\n")
    }

    // Note: renderDisabledCollections removed - disabled collections not written to config (ADR-025)

    private static func metadataLines(for collection: RuleCollection, indent: String, status: String)
        -> [String] {
        [
            "\(indent);; === Collection: \(collection.name) (\(status)) ===",
            "\(indent);; UUID: \(collection.id.uuidString)",
            "\(indent);; Description: \(collection.summary)"
        ]
    }

    private static func metadataLines(for activator: MomentaryActivator, indent: String) -> [String] {
        [
            "\(indent);; === Momentary Layer Switch ===",
            "\(indent);; Input: \(activator.input)",
            "\(indent);; Activates: \(activator.targetLayer.displayName)"
        ]
    }

    /// Get the system default collections (macOS Function Keys enabled by default)
    public static var systemDefaultCollections: [RuleCollection] {
        defaultSystemCollections
    }

    private static var defaultSystemCollections: [RuleCollection] {
        [
            RuleCollection(
                id: RuleCollectionIdentifier.macFunctionKeys,
                name: "macOS Function Keys",
                summary: "Preserves brightness, volume, and media control keys (F1-F12).",
                category: .system,
                mappings: macFunctionKeyMappings,
                isEnabled: true,
                isSystemDefault: true,
                icon: "keyboard",
                targetLayer: .base
            )
        ]
    }

    private static var macFunctionKeyMappings: [KeyMapping] {
        [
            KeyMapping(input: "f1", output: "brdn"),
            KeyMapping(input: "f2", output: "brup"),
            KeyMapping(input: "f3", output: "f3"),
            KeyMapping(input: "f4", output: "f4"),
            KeyMapping(input: "f7", output: "prev"),
            KeyMapping(input: "f8", output: "pp"),
            KeyMapping(input: "f9", output: "next"),
            KeyMapping(input: "f10", output: "mute"),
            KeyMapping(input: "f11", output: "vold"),
            KeyMapping(input: "f12", output: "volu")
        ]
    }

    // MARK: - Block builders

    private static func buildCollectionBlocks(
        from collections: [RuleCollection]
    ) -> ([CollectionBlock], [AliasDefinition], [RuleCollectionLayer], [ChordMapping]) {
        var blocks: [CollectionBlock] = []
        var aliasDefinitions: [AliasDefinition] = []
        var additionalLayers: [RuleCollectionLayer] = []
        var chordMappings: [ChordMapping] = []
        var seenLayers = Set<RuleCollectionLayer>()
        var activatorBlocks: [CollectionBlock] = []
        var seenActivators: Set<String> = []

        // Detect layers that should be activated when "hyper" is triggered.
        // These are collections with momentaryActivator.input == "hyper" (like Quick Launcher).
        // Since "hyper" isn't a physical key, we integrate these layers into the hyper hold action
        // of collections like Caps Lock Remap that output hyper on hold.
        let hyperLinkedLayerInfos: [HyperLinkedLayerInfo] = collections
            .filter(\.isEnabled)
            .compactMap { collection -> HyperLinkedLayerInfo? in
                guard let activator = collection.momentaryActivator,
                      activator.input.lowercased() == "hyper"
                else {
                    return nil
                }
                // Get trigger mode from launcher config if available
                let triggerMode: HyperTriggerMode = collection.configuration.launcherGridConfig?.hyperTriggerMode ?? .hold
                return HyperLinkedLayerInfo(layerName: activator.targetLayer.kanataName, triggerMode: triggerMode)
            }

        // Precompute mapped keys for non-base layers to avoid blocking keys mapped by other collections.
        var layerMappedKeys: [RuleCollectionLayer: Set<String>] = [:]

        func effectiveMappings(for collection: RuleCollection) -> [KeyMapping] {
            switch collection.configuration {
            case let .homeRowMods(config):
                generateHomeRowModsMappings(from: config)
            case .tapHoldPicker:
                generateTapHoldPickerMappings(from: collection)
            case .layerPresetPicker:
                generateLayerPresetMappings(from: collection)
            case let .launcherGrid(config):
                generateLauncherGridMappings(from: config)
            case .list, .table, .singleKeyPicker:
                collection.mappings
            }
        }

        for collection in collections where collection.isEnabled {
            let mappings = effectiveMappings(for: collection)
            let regularMappings = mappings.filter { !$0.input.contains(" ") }
            let inputs = regularMappings.map { KanataKeyConverter.convertToKanataKey($0.input) }
            var existing = layerMappedKeys[collection.targetLayer, default: []]
            existing.formUnion(inputs)
            layerMappedKeys[collection.targetLayer] = existing
        }

        for collection in collections where collection.targetLayer != .base {
            if !seenLayers.contains(collection.targetLayer) {
                seenLayers.insert(collection.targetLayer)
                additionalLayers.append(collection.targetLayer)
            }
        }

        for collection in collections {
            guard collection.isEnabled, let activator = collection.momentaryActivator else { continue }

            // Skip "hyper" activators - they're integrated into the hyper hold action
            // (handled by KanataBehaviorRenderer via hyperLinkedLayerInfos set above)
            if activator.input.lowercased() == "hyper" {
                continue
            }

            let tapKey = KanataKeyConverter.convertToKanataKey(activator.input)
            let aliasName = aliasSafeName(layer: activator.targetLayer, key: tapKey)
            if !seenActivators.contains(aliasName) {
                seenActivators.insert(aliasName)
                let layerName = activator.targetLayer.kanataName

                // For chained layers (sourceLayer != .base), use one-shot-press instead of tap-hold
                // This allows quick entry to nested layers without requiring hold
                let definition = if activator.sourceLayer == .base {
                    // Standard tap-hold for base layer activators
                    // Use multi to combine layer-while-held with fake key triggers for TCP layer notifications.
                    // This works around Kanata's limitation where layer-while-held doesn't broadcast LayerChange messages.
                    "(tap-hold $tap-timeout $hold-timeout \(tapKey)\n    (multi\n      (layer-while-held \(layerName))\n      (on-press-fakekey kp-layer-\(layerName)-enter tap)\n      (on-release-fakekey kp-layer-\(layerName)-exit tap)))"
                } else {
                    // One-shot for chained layers (e.g., nav → window, nav → sym)
                    // Activates target layer for 2 seconds or until next key press.
                    // Include layer notification fake keys for overlay and UI updates.
                    // Exit notification triggers when one-shot releases, returning to parent layer.
                    "(multi\n    (one-shot-press 2000 (layer-while-held \(layerName)))\n    (on-press-fakekey kp-layer-\(layerName)-enter tap)\n    (on-release-fakekey kp-layer-\(layerName)-exit tap))"
                }
                aliasDefinitions.append(AliasDefinition(aliasName: aliasName, definition: definition))

                // Determine where to place the activator
                let entry = if activator.sourceLayer == .base {
                    LayerEntry(
                        sourceKey: tapKey,
                        baseOutput: "@\(aliasName)",
                        layerOutputs: [:]
                    )
                } else {
                    // Chained activator: place in source layer, passthrough in base
                    LayerEntry(
                        sourceKey: tapKey,
                        baseOutput: tapKey, // Passthrough in base layer
                        layerOutputs: [activator.sourceLayer: "@\(aliasName)"]
                    )
                }
                let metadata = metadataLines(for: activator, indent: "  ")
                activatorBlocks.append(CollectionBlock(metadata: metadata, entries: [entry]))
            }
        }

        for collection in collections where collection.isEnabled {
            var metadata = metadataLines(for: collection, indent: "  ", status: "enabled")

            // Handle special display styles: generate mappings from config
            let effectiveMappings: [KeyMapping] = switch collection.configuration {
            case let .homeRowMods(config):
                generateHomeRowModsMappings(from: config)
            case .tapHoldPicker:
                generateTapHoldPickerMappings(from: collection)
            case .layerPresetPicker:
                generateLayerPresetMappings(from: collection)
            case let .launcherGrid(config):
                generateLauncherGridMappings(from: config)
            case .list, .table, .singleKeyPicker:
                collection.mappings
            }

            // Separate chord mappings (input contains space = multiple simultaneous keys)
            let regularMappings = effectiveMappings.filter { !$0.input.contains(" ") }
            let chordInputMappings = effectiveMappings.filter { $0.input.contains(" ") }

            // Add chord mappings to the separate chord list
            for mapping in chordInputMappings {
                let inputKeys = mapping.input.split(separator: " ").map { KanataKeyConverter.convertToKanataKey(String($0)) }.joined(separator: " ")
                let output = KanataKeyConverter.convertToKanataSequence(mapping.output)
                chordMappings.append(ChordMapping(inputKeys: inputKeys, output: output, description: mapping.description))
            }

            if regularMappings.isEmpty {
                if !chordInputMappings.isEmpty {
                    // Collection has only chord mappings - add metadata comment
                    metadata.append("  ;; (chord mappings in defchordsv2 block)")
                } else {
                    metadata.append("  ;; (no mappings)")
                }
                blocks.append(CollectionBlock(metadata: metadata, entries: []))
                continue
            }
            var entries = regularMappings.map { mapping -> LayerEntry in
                let sourceKey = KanataKeyConverter.convertToKanataKey(mapping.input)
                var layerOutputs: [RuleCollectionLayer: String] = [:]

                let trimmedOutput = mapping.output.trimmingCharacters(in: .whitespacesAndNewlines)

                // Determine the output action based on behavior or simple output
                let layerOutput: String
                if mapping.behavior != nil {
                    // Advanced behavior (tap-hold, tap-dance) - use renderer
                    // Pass hyperLinkedLayerInfos so "hyper" hold action includes linked layer activations
                    let rendered = KanataBehaviorRenderer.render(mapping, hyperLinkedLayerInfos: hyperLinkedLayerInfos)
                    // Create alias for complex behaviors to keep deflayer clean
                    let aliasName = behaviorAliasName(for: mapping, layer: collection.targetLayer)
                    aliasDefinitions.append(AliasDefinition(aliasName: aliasName, definition: rendered))
                    layerOutput = "@\(aliasName)"
                } else if mapping.requiresFork {
                    // Generate fork alias for mappings with modifier-specific outputs
                    let aliasName = forkAliasName(for: mapping, layer: collection.targetLayer)
                    let forkDef = buildForkDefinition(for: mapping)
                    aliasDefinitions.append(AliasDefinition(aliasName: aliasName, definition: forkDef))
                    layerOutput = "@\(aliasName)"
                } else if trimmedOutput.hasPrefix("("), trimmedOutput.count > 1 {
                    // Complex action (push-msg, multi, etc.) - needs alias
                    let aliasName = actionAliasName(for: mapping, layer: collection.targetLayer)
                    aliasDefinitions.append(AliasDefinition(aliasName: aliasName, definition: trimmedOutput))
                    layerOutput = "@\(aliasName)"
                } else {
                    // Simple output (key name)
                    layerOutput = KanataKeyConverter.convertToKanataSequence(trimmedOutput)
                }

                if collection.targetLayer != .base {
                    layerOutputs[collection.targetLayer] = layerOutput
                }
                let baseOutput: String =
                    if collection.targetLayer == .base {
                        layerOutput
                    } else {
                        sourceKey
                    }
                return LayerEntry(
                    sourceKey: sourceKey,
                    baseOutput: baseOutput,
                    layerOutputs: layerOutputs
                )
            }

            // For Vim collection: optionally block unmapped keys in navigation layer
            if collection.id == RuleCollectionIdentifier.vimNavigation,
               collection.targetLayer != .base {
                let mappedKeys = layerMappedKeys[collection.targetLayer] ?? Set(entries.map(\.sourceKey))
                let activatorKey = collection.momentaryActivator.map { KanataKeyConverter.convertToKanataKey($0.input) } ?? ""
                // Read user's selected physical layout from UserDefaults
                let selectedLayoutId = UserDefaults.standard.string(forKey: LayoutPreferences.layoutIdKey) ?? LayoutPreferences.defaultLayoutId
                let layout = PhysicalLayout.find(id: selectedLayoutId) ?? .macBookUS
                let extraKeys = Self.navigationUnmappedKeys(
                    excluding: mappedKeys,
                    skipping: activatorKey.isEmpty ? [] : [activatorKey],
                    layout: layout
                )
                let blockedEntries = extraKeys.map { key in
                    LayerEntry(
                        sourceKey: key,
                        baseOutput: key, // base layer keeps normal behavior
                        layerOutputs: [collection.targetLayer: "XX"] // nav layer blocks output
                    )
                }
                entries.append(contentsOf: blockedEntries)
            }

            blocks.append(CollectionBlock(metadata: metadata, entries: entries))
        }

        return (activatorBlocks + blocks, aliasDefinitions, additionalLayers, chordMappings)
    }

    private static func deduplicateBlocks(_ blocks: [CollectionBlock]) -> [CollectionBlock] {
        // Merge entries with the same source key instead of just keeping the first one.
        // This ensures layer-specific mappings (like launcher in launcher layer) aren't lost
        // when another collection (like Vim) also uses the same keys in a different layer.
        var mergedEntries: [String: LayerEntry] = [:]
        var entriesByBlock: [[String]] = [] // Track which keys belong to which block
        var keyOrder: [String] = [] // Preserve insertion order

        for block in blocks {
            var blockKeys: [String] = []
            for entry in block.entries {
                if let existing = mergedEntries[entry.sourceKey] {
                    // Merge layer outputs from this entry into the existing one
                    var combinedLayerOutputs = existing.layerOutputs
                    for (layer, output) in entry.layerOutputs {
                        combinedLayerOutputs[layer] = output
                    }
                    // Keep the base output from the first entry (earlier collection takes precedence)
                    mergedEntries[entry.sourceKey] = LayerEntry(
                        sourceKey: existing.sourceKey,
                        baseOutput: existing.baseOutput,
                        layerOutputs: combinedLayerOutputs
                    )
                } else {
                    // New key - add it
                    mergedEntries[entry.sourceKey] = entry
                    keyOrder.append(entry.sourceKey)
                }
                blockKeys.append(entry.sourceKey)
            }
            entriesByBlock.append(blockKeys)
        }

        // Rebuild blocks with merged entries, keeping original block structure
        var result: [CollectionBlock] = []
        var usedKeys: Set<String> = []

        for (index, block) in blocks.enumerated() {
            let blockKeySet = Set(entriesByBlock[index])
            var uniqueEntries: [LayerEntry] = []
            for key in keyOrder {
                guard blockKeySet.contains(key), !usedKeys.contains(key) else { continue }
                if let entry = mergedEntries[key] {
                    uniqueEntries.append(entry)
                    usedKeys.insert(key)
                }
            }
            result.append(CollectionBlock(metadata: block.metadata, entries: uniqueEntries))
        }

        return result
    }

    /// Formats collection blocks into keyboard-shaped, padded rows for readability.
    private enum KeyboardGridFormatter {
        // Simple 60%/MacBook ANSI-ish layout expressed in Kanata key names
        private static let layoutRows: [[String]] = [
            ["esc", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12", "del"],
            ["grv", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "min", "eql", "bspc"],
            ["tab", "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\"],
            ["caps", "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'", "ret"],
            ["lsft", "z", "x", "c", "v", "b", "n", "m", ",", ".", "/", "rsft"],
            ["lctl", "lalt", "lmet", "spc", "rmet", "ralt", "rctl"]
        ]

        private static let order: [String: Int] = {
            var idx: [String: Int] = [:]
            for (rowIndex, row) in layoutRows.enumerated() {
                for (colIndex, key) in row.enumerated() {
                    idx[key] = rowIndex * 100 + colIndex // wide spacing to keep row priority
                }
            }
            return idx
        }()

        static func renderDefsrc(_ block: CollectionBlock) -> [String] {
            guard !block.entries.isEmpty else {
                return block.metadata + ["  ;; (no mappings)"]
            }
            let sorted = sortEntries(block.entries)
            let body = renderGridLines(sorted) { $0.sourceKey }
            return block.metadata + body
        }

        static func renderLayer(
            _ block: CollectionBlock,
            valueProvider: (LayerEntry) -> String
        ) -> [String] {
            guard !block.entries.isEmpty else {
                return block.metadata + ["  ;; (no mappings)"]
            }
            let sorted = sortEntries(block.entries)
            let body = renderGridLines(sorted, valueProvider: valueProvider)
            return block.metadata + body
        }

        private static func sortEntries(_ entries: [LayerEntry]) -> [LayerEntry] {
            entries.sorted { lhs, rhs in
                let l = order[lhs.sourceKey] ?? Int.max
                let r = order[rhs.sourceKey] ?? Int.max
                if l == r {
                    return lhs.sourceKey < rhs.sourceKey
                }
                return l < r
            }
        }

        /// Render entries grouped into physical rows; rows without entries are skipped.
        private static func renderGridLines(
            _ entries: [LayerEntry],
            valueProvider: (LayerEntry) -> String
        ) -> [String] {
            var rows: [[String]] = []
            var remaining = entries

            for layoutRow in layoutRows {
                var tokens: [String] = []
                for key in layoutRow {
                    if let idx = remaining.firstIndex(where: { $0.sourceKey == key }) {
                        let entry = remaining.remove(at: idx)
                        tokens.append(valueProvider(entry))
                    }
                }
                if !tokens.isEmpty {
                    rows.append(tokens)
                }
            }

            // Anything not in the known layout gets appended in a trailing row
            if !remaining.isEmpty {
                rows.append(remaining.map { valueProvider($0) })
            }

            return rows.map { "  " + padRow($0) }
        }

        private static func padRow(_ tokens: [String]) -> String {
            let width = tokens.map(\.count).max() ?? 0
            let padded = tokens.map { token in
                token.padding(toLength: width, withPad: " ", startingAt: 0)
            }
            return padded.joined(separator: " ")
        }
    }

    /// Build a deterministic list of unmapped keys on the specified physical layout to block in navigation layer.
    /// Excludes modifier keys and any keys already mapped.
    /// - Parameters:
    ///   - mappedKeys: Keys that are already mapped (will not be blocked)
    ///   - extraSkips: Additional keys to skip (e.g., layer activator key)
    ///   - layout: The physical keyboard layout to use for determining available keys
    private static func navigationUnmappedKeys(
        excluding mappedKeys: Set<String>,
        skipping extraSkips: Set<String> = [],
        layout: PhysicalLayout = .macBookUS
    ) -> [String] {
        // Skip modifier/utility keys and any explicitly provided skips (e.g., activator key)
        let defaultSkips: Set<String> = [
            "leftmeta", "rightmeta", "leftctrl", "rightctrl",
            "leftalt", "rightalt", "leftshift", "rightshift",
            "capslock", "fn"
        ]
        let skip = defaultSkips.union(extraSkips)

        let keys = layout.keys.compactMap { key -> String? in
            // Skip invalid keycodes (e.g., Touch ID uses 0xFFFF as placeholder)
            guard key.keyCode != 0xFFFF else { return nil }
            let name = OverlayKeyboardView.keyCodeToKanataName(key.keyCode).lowercased()
            // Skip unknown keycodes
            guard !name.hasPrefix("unknown-") else { return nil }
            guard !skip.contains(name) else { return nil }
            let kanata = KanataKeyConverter.convertToKanataKey(name)
            guard !mappedKeys.contains(kanata) else { return nil }
            return kanata
        }

        return Array(Set(keys)).sorted()
    }

    private static func aliasSafeName(layer: RuleCollectionLayer, key: String) -> String {
        let sanitized =
            key
                .replacingOccurrences(of: "-", with: "_")
                .replacingOccurrences(of: " ", with: "_")
        return "layer_\(layer.kanataName)_\(sanitized)"
    }

    /// Generate alias name for fork-based modifier detection
    private static func forkAliasName(for mapping: KeyMapping, layer: RuleCollectionLayer) -> String {
        let sanitized =
            mapping.input
                .replacingOccurrences(of: "-", with: "_")
                .replacingOccurrences(of: " ", with: "_")
        return "fork_\(layer.kanataName)_\(sanitized)"
    }

    /// Generate alias name for advanced behavior (tap-hold, tap-dance)
    private static func behaviorAliasName(for mapping: KeyMapping, layer: RuleCollectionLayer) -> String {
        let sanitized =
            mapping.input
                .replacingOccurrences(of: "-", with: "_")
                .replacingOccurrences(of: " ", with: "_")
        return "beh_\(layer.kanataName)_\(sanitized)"
    }

    /// Generate alias name for complex actions (push-msg, multi, etc.)
    private static func actionAliasName(for mapping: KeyMapping, layer: RuleCollectionLayer) -> String {
        let sanitized =
            mapping.input
                .replacingOccurrences(of: "-", with: "_")
                .replacingOccurrences(of: " ", with: "_")
        return "act_\(layer.kanataName)_\(sanitized)"
    }

    /// Build fork definition for modifier-aware mappings
    /// Fork syntax: (fork default-action alternate-action (trigger-keys))
    /// Note: Inside fork, modifier prefixes like m-right must be (multi lmet right)
    private static func buildForkDefinition(for mapping: KeyMapping) -> String {
        let defaultOutput = convertToForkAction(mapping.output)

        // Shift modifier takes precedence
        if let shiftedOutput = mapping.shiftedOutput {
            let shiftOutput = convertToForkAction(shiftedOutput)
            return "(fork \(defaultOutput) \(shiftOutput) (lsft rsft))"
        }

        // Ctrl modifier
        if let ctrlOutput = mapping.ctrlOutput {
            let ctrlOutputConverted = convertToForkAction(ctrlOutput)
            return "(fork \(defaultOutput) \(ctrlOutputConverted) (lctl rctl))"
        }

        // Fallback (shouldn't reach here if requiresFork is true)
        return defaultOutput
    }

    /// Convert a key output to a fork-compatible action
    /// - Single keys with modifiers: (multi modifier key) format
    /// - Multi-key sequences: (macro ...) with chord syntax inside
    private static func convertToForkAction(_ output: String) -> String {
        let tokens = output.split(separator: " ").map(String.init)

        if tokens.count > 1 {
            // Multi-key sequence -> wrap in macro
            // Inside macro, chord syntax (M-right) works and requires UPPERCASE prefixes
            let converted = tokens.map { KanataKeyConverter.convertToKanataKeyForMacro($0) }
            return "(macro \(converted.joined(separator: " ")))"
        } else if let single = tokens.first {
            // Single key - must use (multi ...) format for modifiers inside fork
            return convertSingleKeyToForkFormat(single)
        }
        return output
    }

    /// Convert a single key (possibly with modifiers) to fork-compatible format
    /// e.g., "M-right" -> "(multi lmet right)", "pgup" -> "pgup"
    /// Note: Inside fork actions (not inside macro), modifier prefixes must be (multi ...)
    /// Generate KeyMapping instances from HomeRowModsConfig
    private static func generateHomeRowModsMappings(from config: HomeRowModsConfig) -> [KeyMapping] {
        var mappings: [KeyMapping] = []

        for key in config.enabledKeys {
            guard let modifier = config.modifierAssignments[key] else { continue }

            let tapTimeout = max(
                1,
                config.timing.tapWindow
                    + (config.timing.tapOffsets[key] ?? 0)
                    + (config.timing.quickTapEnabled ? config.timing.quickTapTermMs : 0)
            )
            let holdTimeout = max(1, config.timing.holdDelay)

            // Create dual-role behavior: tap = letter, hold = modifier
            let behavior = DualRoleBehavior(
                tapAction: key,
                holdAction: modifier,
                tapTimeout: tapTimeout,
                holdTimeout: holdTimeout,
                activateHoldOnOtherKey: true, // Best for home-row mods
                quickTap: config.timing.quickTapEnabled,
                customTapKeys: []
            )

            let mapping = KeyMapping(
                input: key,
                output: key, // Fallback, but behavior takes precedence
                behavior: .dualRole(behavior)
            )
            mappings.append(mapping)
        }

        return mappings
    }

    /// Generate mappings for a tap-hold picker collection (e.g., Caps Lock Remap)
    private static func generateTapHoldPickerMappings(from collection: RuleCollection) -> [KeyMapping] {
        guard case let .tapHoldPicker(config) = collection.configuration else {
            return []
        }

        let tapOutput = config.selectedTapOutput ?? config.tapOptions.first?.output ?? "esc"
        let holdOutput = config.selectedHoldOutput ?? config.holdOptions.first?.output ?? "XX"

        // Create dual-role behavior: tap = tapOutput, hold = holdOutput
        let behavior = DualRoleBehavior(
            tapAction: tapOutput,
            holdAction: holdOutput,
            tapTimeout: 200,
            holdTimeout: 200,
            activateHoldOnOtherKey: true,
            quickTap: false,
            customTapKeys: []
        )

        let mapping = KeyMapping(
            input: config.inputKey,
            output: tapOutput, // Fallback, but behavior takes precedence
            behavior: .dualRole(behavior)
        )

        return [mapping]
    }

    /// Generate mappings for a layer preset picker collection (e.g., Symbol Layer)
    private static func generateLayerPresetMappings(from collection: RuleCollection) -> [KeyMapping] {
        guard case let .layerPresetPicker(config) = collection.configuration else {
            return collection.mappings
        }

        guard !config.presets.isEmpty else {
            return collection.mappings
        }

        return config.selectedMappings.isEmpty ? (config.presets.first?.mappings ?? []) : config.selectedMappings
    }

    /// Generate key mappings from launcher grid configuration
    private static func generateLauncherGridMappings(from config: LauncherGridConfig) -> [KeyMapping] {
        var mappings = config.mappings
            .filter(\.isEnabled)
            // In tap mode, ESC is reserved for canceling the one-shot, so filter it out
            .filter { config.hyperTriggerMode != .tap || $0.key.lowercased() != "esc" }
            .map { mapping in
                KeyMapping(
                    input: mapping.key,
                    output: mapping.target.kanataOutput
                )
            }

        // In tap mode, add ESC → XX (no output) to cancel one-shot without side effects
        if config.hyperTriggerMode == .tap {
            mappings.append(KeyMapping(input: "esc", output: "XX"))
        }

        return mappings
    }

    private static func convertSingleKeyToForkFormat(_ key: String) -> String {
        // Map modifier prefixes to their key names
        let modifierMap: [(prefix: String, key: String)] = [
            ("M-S-", "lmet lsft"), // Meta+Shift
            ("C-S-", "lctl lsft"), // Ctrl+Shift
            ("A-S-", "lalt lsft"), // Alt+Shift
            ("M-", "lmet"), // Meta/Command
            ("A-", "lalt"), // Alt/Option
            ("C-", "lctl"), // Control
            ("S-", "lsft") // Shift
        ]

        var remainingKey = key
        var modifiers: [String] = []

        // Extract all modifier prefixes
        for (prefix, modKey) in modifierMap {
            if remainingKey.hasPrefix(prefix) {
                modifiers.append(contentsOf: modKey.split(separator: " ").map(String.init))
                remainingKey = String(remainingKey.dropFirst(prefix.count))
                break // Only match one combined prefix
            }
        }

        if modifiers.isEmpty {
            // No modifiers - return as-is (convert to kanata key format)
            return KanataKeyConverter.convertToKanataKey(remainingKey)
        }

        // Has modifiers - wrap in (multi ...)
        let baseKey = KanataKeyConverter.convertToKanataKey(remainingKey)
        return "(multi \(modifiers.joined(separator: " ")) \(baseKey))"
    }

    private struct CollectionBlock {
        let metadata: [String]
        let entries: [LayerEntry]
    }

    private struct LayerEntry {
        let sourceKey: String
        let baseOutput: String
        let layerOutputs: [RuleCollectionLayer: String]
    }

    private struct AliasDefinition {
        let aliasName: String
        let definition: String
    }
}

// MARK: - Configuration Service

/// Centralized configuration management service for Kanata
///
/// This service handles all configuration-related operations:
/// - Loading and saving configuration files
/// - Validation via TCP and file-based checks
/// - File watching and change detection
/// - Key mapping generation and conversion
public final class ConfigurationService: FileConfigurationProviding {
    public typealias Config = KanataConfiguration

    // MARK: - Properties

    public let configurationPath: String
    public let configDirectory: String
    public let configFileName = KeyPathConstants.Config.fileName

    private var currentConfiguration: KanataConfiguration?
    private var fileWatcher: FileWatcher?
    private var observers: [@Sendable (Config) async -> Void] = []

    // Perform blocking file I/O off the main actor
    private let ioQueue = DispatchQueue(label: "com.keypath.configservice.io", qos: .utility)
    // Protect shared state when accessed from multiple threads
    private let stateLock = NSLock()

    // MARK: - Initialization

    public init(configDirectory: String? = nil) {
        if let customDirectory = configDirectory {
            self.configDirectory = customDirectory
        } else {
            self.configDirectory = KeyPathConstants.Config.directory
        }
        configurationPath = "\(self.configDirectory)/\(configFileName)"
    }

    // MARK: - ConfigurationProviding Protocol

    public func current() async -> KanataConfiguration {
        // Fast path: return cached config if available
        if let cached = withLockedCurrentConfig() { return cached }

        // Try to load existing configuration, fallback to empty if not found
        do {
            let config = try await reload()
            return config
        } catch {
            AppLogger.shared.log("⚠️ [ConfigService] Failed to load current config, using empty: \(error)")
            let emptyConfig = KanataConfiguration(
                content: KanataConfiguration.generateFromMappings([]),
                keyMappings: [],
                lastModified: Date(),
                path: configurationPath
            )
            setCurrentConfiguration(emptyConfig)
            return emptyConfig
        }
    }

    public func reload() async throws -> KanataConfiguration {
        var exists = await fileExistsAsync(path: configurationPath)

        if !exists {
            AppLogger.shared.log(
                "⚠️ [ConfigService] Config missing at \(configurationPath) – creating default before reload")
            do {
                try await createInitialConfigIfNeeded()
                exists = await fileExistsAsync(path: configurationPath)
            } catch {
                AppLogger.shared.log(
                    "❌ [ConfigService] Failed to create default config during reload: \(error)")
            }
        }

        guard exists else {
            throw KeyPathError.configuration(.fileNotFound(path: configurationPath))
        }

        do {
            let content = try await readFileAsync(path: configurationPath)
            let config = try validate(content: content)
            setCurrentConfiguration(config)

            // Notify observers on main actor
            let snapshot = observersSnapshot()
            let tasks = snapshot.map { observer in
                Task { @MainActor in await observer(config) }
            }
            for t in tasks {
                await t.value
            }

            return config
        } catch let error as KeyPathError {
            throw error
        } catch {
            throw KeyPathError.configuration(.loadFailed(reason: error.localizedDescription))
        }
    }

    public func observe(_ onChange: @Sendable @escaping (Config) async -> Void)
        -> ConfigurationObservationToken {
        var index = 0
        stateLock.lock()
        observers.append(onChange)
        index = observers.count - 1
        stateLock.unlock()

        return ConfigurationObservationToken {
            self.stateLock.lock()
            if index < self.observers.count { self.observers.remove(at: index) }
            self.stateLock.unlock()
        }
    }

    // MARK: - FileConfigurationProviding Protocol

    public func validate(content: String) throws -> KanataConfiguration {
        // Basic validation - ensure content is not empty
        guard !content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            throw KeyPathError.configuration(.invalidFormat(reason: "Configuration content is empty"))
        }

        // Get file modification date
        let attributes = try? FileManager.default.attributesOfItem(atPath: configurationPath)
        let lastModified = (attributes?[.modificationDate] as? Date) ?? Date()

        // Extract key mappings from content (simplified - could be enhanced)
        let keyMappings = extractKeyMappingsFromContent(content)

        return KanataConfiguration(
            content: content,
            keyMappings: keyMappings,
            lastModified: lastModified,
            path: configurationPath
        )
    }

    public func startFileMonitoring() -> ConfigurationObservationToken {
        guard fileWatcher == nil else {
            // Already monitoring
            return ConfigurationObservationToken { /* no-op */ }
        }

        fileWatcher = FileWatcher(path: configurationPath) { [weak self] in
            Task { @MainActor in
                await self?.handleFileChange()
            }
        }

        return ConfigurationObservationToken { [weak self] in
            self?.stopFileMonitoring()
        }
    }

    // MARK: - Configuration Management

    /// Create the configuration directory and initial config if needed
    public func createInitialConfigIfNeeded() async throws {
        // Create config directory if it doesn't exist (off-main)
        try await createDirectoryAsync(path: configDirectory)
        AppLogger.shared.log("✅ [ConfigService] Config directory created at \(configDirectory)")

        // Check if config file exists
        let exists = await fileExistsAsync(path: configurationPath)
        if !exists {
            AppLogger.shared.log("⚠️ [ConfigService] No existing config found at \(configurationPath)")

            // Rehydrate from persisted rule/custom stores so user state survives file deletion/reset
            let storedCollections = await RuleCollectionStore.shared.loadCollections()
            let storedCustomRules = await CustomRulesStore.shared.loadRules()
            let collectionsToSave = storedCollections.isEmpty
                ? RuleCollectionCatalog().defaultCollections()
                : storedCollections

            AppLogger.shared.log(
                "🆕 [ConfigService] Creating initial config from stores: \(collectionsToSave.count) collections, \(storedCustomRules.count) custom rules"
            )

            try await saveConfiguration(
                ruleCollections: collectionsToSave,
                customRules: storedCustomRules
            )
            AppLogger.shared.log(
                "✅ [ConfigService] Created initial configuration with \(collectionsToSave.count) collections"
            )
        } else {
            AppLogger.shared.log("✅ [ConfigService] Existing config found at \(configurationPath)")
        }
    }

    /// Save configuration using rule collections.
    /// IMPORTANT: Validates config before saving - will throw on invalid config
    public func saveConfiguration(
        ruleCollections: [RuleCollection],
        customRules: [CustomRule] = []
    ) async throws {
        // Custom rules come first so they take priority over preset collections
        let allCollections = customRules.asRuleCollections() + ruleCollections

        // DETECT CONFLICTS BEFORE DEDUPLICATION
        // This catches cases where multiple collections map the same key
        let conflicts = RuleCollectionDeduplicator.detectConflicts(in: allCollections)
        if !conflicts.isEmpty {
            AppLogger.shared.log(
                "⚠️ [ConfigService] Mapping conflicts detected: \(conflicts.map(\.description).joined(separator: "; "))"
            )
            throw KeyPathError.configuration(.mappingConflicts(conflicts: conflicts))
        }
        AppLogger.shared.debug("✅ [ConfigService] No mapping conflicts detected")

        let combinedCollections = RuleCollectionDeduplicator.dedupe(allCollections)
        let mappings = combinedCollections.enabledMappings()
        let configContent = KanataConfiguration.generateFromCollections(combinedCollections)

        // VALIDATE BEFORE SAVING - prevent writing broken configs
        AppLogger.shared.log("🔍 [ConfigService] Validating config before save...")
        let validation = await validateConfiguration(configContent)

        if !validation.isValid {
            AppLogger.shared.log(
                "❌ [ConfigService] Config validation failed: \(validation.errors.joined(separator: ", "))")
            throw KeyPathError.configuration(.validationFailed(errors: validation.errors))
        }

        AppLogger.shared.log("✅ [ConfigService] Config validation passed")

        try await writeFileAsync(string: configContent, to: configurationPath)

        // Update current configuration
        let newConfig = KanataConfiguration(
            content: configContent,
            keyMappings: mappings,
            lastModified: Date(),
            path: configurationPath
        )
        setCurrentConfiguration(newConfig)

        // Notify observers on main actor
        let snapshot = observersSnapshot()
        let tasks = snapshot.map { observer in
            Task { @MainActor in await observer(newConfig) }
        }
        for t in tasks {
            await t.value
        }

        AppLogger.shared.log("✅ [ConfigService] Configuration saved with \(mappings.count) mappings")
    }

    /// Save configuration with key mappings (legacy helper)
    public func saveConfiguration(keyMappings: [KeyMapping]) async throws {
        let collections = [RuleCollection].collection(
            named: "Custom Mappings",
            mappings: keyMappings,
            category: .custom
        )
        try await saveConfiguration(ruleCollections: collections)
    }

    /// Save configuration with specific input/output mapping
    public func saveConfiguration(input: String, output: String) async throws {
        let keyMapping = KeyMapping(input: input, output: output)
        try await saveConfiguration(keyMappings: [keyMapping])
    }

    /// Write raw configuration content to file (for restoration/repair)
    public func writeConfigurationContent(_ content: String) async throws {
        try await writeFileAsync(string: content, to: configurationPath)
        // Update current configuration
        let newConfig = try validate(content: content)
        setCurrentConfiguration(newConfig)
    }

    // MARK: - Validation

    /// Validate configuration via file-based check
    public func validateConfigViaFile() async -> (isValid: Bool, errors: [String]) {
        if TestEnvironment.isTestMode {
            AppLogger.shared.log("🧪 [ConfigService] Test mode: Skipping file validation")
            return (true, [])
        }

        let binaryPath = WizardSystemPaths.kanataActiveBinary
        guard FileManager.default.isExecutableFile(atPath: binaryPath) else {
            let message = "Kanata binary missing at \(binaryPath)"
            AppLogger.shared.log("❌ [ConfigService] File validation skipped: \(message)")
            return (false, [message])
        }

        var errors: [String] = []

        do {
            let result = try await SubprocessRunner.shared.run(
                binaryPath,
                args: buildKanataArguments(checkOnly: true),
                timeout: 30
            )
            let output = result.stdout + result.stderr

            if result.exitCode == 0 {
                AppLogger.shared.log("✅ [ConfigService] File validation passed")
                return (true, [])
            } else {
                // Parse errors from output
                let lines = output.components(separatedBy: .newlines)
                for line in lines where !line.isEmpty && (line.contains("error") || line.contains("Error")) {
                    errors.append(line.trimmingCharacters(in: .whitespaces))
                }

                if errors.isEmpty {
                    errors.append("Configuration validation failed (exit code: \(result.exitCode))")
                }

                AppLogger.shared.log("❌ [ConfigService] File validation failed: \(errors)")
                return (false, errors)
            }

        } catch {
            AppLogger.shared.log("❌ [ConfigService] File validation error: \(error)")
            return (false, ["Failed to validate configuration file: \(error.localizedDescription)"])
        }
    }

    /// Validate configuration content using TCP if available, else CLI
    public func validateConfiguration(_ config: String) async -> (isValid: Bool, errors: [String]) {
        AppLogger.shared.log("🔍 [Validation] ========== CONFIG VALIDATION START ==========")
        AppLogger.shared.log("🔍 [Validation] Config size: \(config.count) characters")

        if TestEnvironment.isTestMode {
            AppLogger.shared.log("🧪 [Validation] Test mode detected – using lightweight validation")
            let result = validateConfigurationInTestMode(config)
            AppLogger.shared.log("🔍 [Validation] ========== CONFIG VALIDATION END ==========")
            return result
        }

        // If the service isn't managed/approved yet, skip TCP to avoid long timeouts
        let managementState = await KanataDaemonManager.shared.refreshManagementState()
        let tcpCapableStates: Set<KanataDaemonManager.ServiceManagementState> = [
            .smappserviceActive, .legacyActive, .conflicted
        ]
        if !tcpCapableStates.contains(managementState) {
            AppLogger.shared.log(
                "🌐 [Validation] TCP validation skipped (service state=\(managementState)); using CLI"
            )
            let cliResult = await validateConfigWithCLI(config)
            AppLogger.shared.log("🔍 [Validation] ========== CONFIG VALIDATION END ==========")
            return cliResult
        }

        // Give the service a brief warmup after (re)install before attempting TCP
        if managementState == .smappserviceActive {
            try? await Task.sleep(nanoseconds: 500_000_000) // 0.5s
        }

        // Skip TCP if Kanata service isn't healthy yet (avoid connection-refused storm)
        let daemonStatus = await InstallerEngine().getServiceStatus()
        if !daemonStatus.kanataServiceHealthy {
            AppLogger.shared.log(
                "🌐 [Validation] TCP validation skipped (kanata not healthy yet); using CLI"
            )
            let cliResult = await validateConfigWithCLI(config)
            AppLogger.shared.log("🔍 [Validation] ========== CONFIG VALIDATION END ==========")
            return cliResult
        }

        // Try TCP validation first
        let tcpPort = PreferencesService.shared.tcpServerPort
        let tcpClient = KanataTCPClient(port: tcpPort)

        let tcpResult = await tcpClient.validateConfig(config)

        // FIX #1: Explicitly close connection to prevent file descriptor leak
        await tcpClient.cancelInflightAndCloseConnection()

        switch tcpResult {
        case .success:
            AppLogger.shared.log("🌐 [Validation] TCP validation PASSED")
            AppLogger.shared.log("🔍 [Validation] ========== CONFIG VALIDATION END ==========")
            return (true, [])
        case let .failure(errors):
            AppLogger.shared.log("🌐 [Validation] TCP validation FAILED with \(errors.count) errors")
            if shouldFallbackToCLIForTCPParseErrors(errors) {
                AppLogger.shared.log(
                    "🌐 [Validation] TCP error requires CLI fallback; using CLI validation"
                )
                let cliResult = await validateConfigWithCLI(config)
                AppLogger.shared.log("🔍 [Validation] ========== CONFIG VALIDATION END ==========")
                // Use CLI result entirely - TCP error was a protocol issue, not config issue
                return cliResult
            }
            AppLogger.shared.log("🔍 [Validation] ========== CONFIG VALIDATION END ==========")
            return (false, errors)
        case .networkError:
            AppLogger.shared.log("🌐 [Validation] TCP validation unavailable, falling back to CLI")
            let cliResult = await validateConfigWithCLI(config)
            AppLogger.shared.log("🔍 [Validation] ========== CONFIG VALIDATION END ==========")
            return cliResult
        }
    }

    private func shouldFallbackToCLIForTCPParseErrors(_ errors: [String]) -> Bool {
        // Config parse errors that need CLI for better error messages
        let parseErrorNeedles = ["error in configuration", "config_parse", "parse error"]
        // Protocol errors indicate Kanata doesn't support the Validate command
        let protocolErrorNeedles = ["unknown variant", "failed to deserialize command"]

        return errors.contains { error in
            let lowercased = error.lowercased()
            let isParseError = parseErrorNeedles.contains { lowercased.contains($0) }
            let isProtocolError = protocolErrorNeedles.contains { lowercased.contains($0) }
            return isParseError || isProtocolError
        }
    }

    /// Validate configuration via CLI (kanata --check)
    private func validateConfigWithCLI(_ config: String) async -> (isValid: Bool, errors: [String]) {
        AppLogger.shared.log("🖥️ [Validation-CLI] Starting CLI validation process...")
        let keepFailedConfig =
            ProcessInfo.processInfo.environment["KEYPATH_KEEP_FAILED_CONFIG"] == "1"

        // Write config to a unique temporary file for validation (UUID prevents race conditions)
        let uniqueID = UUID().uuidString.prefix(8)
        let tempConfigPath = "\(configDirectory)/temp_validation_\(uniqueID).kbd"
        AppLogger.shared.log("📝 [Validation-CLI] Creating temp config file: \(tempConfigPath)")

        do {
            let tempConfigURL = URL(fileURLWithPath: tempConfigPath)
            let configDir = URL(fileURLWithPath: configDirectory)
            try FileManager.default.createDirectory(at: configDir, withIntermediateDirectories: true)
            try await writeFileURLAsync(string: config, to: tempConfigURL)
            AppLogger.shared.log(
                "📝 [Validation-CLI] Temp config written successfully (\(config.count) characters)")

            // Use kanata --check to validate
            let kanataBinary = WizardSystemPaths.kanataActiveBinary
            AppLogger.shared.log("🔧 [Validation-CLI] Using kanata binary: \(kanataBinary)")

            guard FileManager.default.isExecutableFile(atPath: kanataBinary) else {
                let message = "Kanata binary missing at \(kanataBinary)"
                AppLogger.shared.log("❌ [Validation-CLI] \(message)")
                if TestEnvironment.isTestMode {
                    AppLogger.shared.log("🧪 [Validation-CLI] Skipping CLI validation in tests")
                    try? FileManager.default.removeItem(at: tempConfigURL)
                    return (true, [])
                }
                try? FileManager.default.removeItem(at: tempConfigURL)
                return (false, [message])
            }

            let arguments = ["--cfg", tempConfigPath, "--check"]
            AppLogger.shared.log(
                "🔧 [Validation-CLI] Command: \(kanataBinary) \(arguments.joined(separator: " "))")

            let cliStart = Date()
            let result = try await SubprocessRunner.shared.run(
                kanataBinary,
                args: arguments,
                timeout: 30
            )
            let cliDuration = Date().timeIntervalSince(cliStart)
            AppLogger.shared.log(
                "⏱️ [Validation-CLI] CLI validation completed in \(String(format: "%.3f", cliDuration)) seconds"
            )

            let output = result.stdout + result.stderr

            AppLogger.shared.log("📋 [Validation-CLI] Exit code: \(result.exitCode)")
            if !output.isEmpty {
                AppLogger.shared.log("📋 [Validation-CLI] Output: \(output.prefix(500))...")
            }

            if result.exitCode == 0 {
                AppLogger.shared.log("✅ [Validation-CLI] CLI validation PASSED")
                try? FileManager.default.removeItem(at: tempConfigURL)
                return (true, [])
            } else {
                let errors = parseKanataErrors(output)
                if keepFailedConfig {
                    AppLogger.shared.log(
                        "🧪 [Validation-CLI] Keeping temp config for debugging at \(tempConfigPath)"
                    )
                } else {
                    try? FileManager.default.removeItem(at: tempConfigURL)
                }
                AppLogger.shared.log(
                    "❌ [Validation-CLI] CLI validation FAILED with \(errors.count) errors:")
                for (index, error) in errors.enumerated() {
                    AppLogger.shared.log("   Error \(index + 1): \(error)")
                }
                return (false, errors)
            }
        } catch {
            // Clean up temp file on error
            if keepFailedConfig {
                AppLogger.shared.log(
                    "🧪 [Validation-CLI] Keeping temp config for debugging at \(tempConfigPath)"
                )
            } else {
                try? FileManager.default.removeItem(atPath: tempConfigPath)
            }
            AppLogger.shared.log("❌ [Validation-CLI] Validation process failed: \(error)")
            AppLogger.shared.log("❌ [Validation-CLI] Error type: \(type(of: error))")
            return (false, ["Validation failed: \(error.localizedDescription)"])
        }
    }

    private func validateConfigurationInTestMode(_ config: String) -> (
        isValid: Bool, errors: [String]
    ) {
        guard !config.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            return (false, ["Configuration content is empty"])
        }

        do {
            _ = try parseConfigurationFromString(config)
            return (true, [])
        } catch {
            return (false, ["Mock validation failed: \(error.localizedDescription)"])
        }
    }

    // MARK: - Backup and Recovery

    /// Backs up a failed config and applies safe default, returning backup path
    public func backupFailedConfigAndApplySafe(failedConfig: String, mappings: [KeyMapping])
        async throws
        -> String {
        AppLogger.shared.log("🛡️ [Config] Backing up failed config and applying safe default")

        // Create backup directory if it doesn't exist
        let backupDir = "\(configDirectory)/backups"
        let backupDirURL = URL(fileURLWithPath: backupDir)
        try FileManager.default.createDirectory(at: backupDirURL, withIntermediateDirectories: true)

        // Create timestamped backup filename
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        let timestamp = formatter.string(from: Date())

        let backupPath = "\(backupDir)/failed_config_\(timestamp).kbd"
        let backupURL = URL(fileURLWithPath: backupPath)

        // Write the failed config to backup
        let backupContent = """
        ;; FAILED CONFIG - AUTOMATICALLY BACKED UP
        ;; Timestamp: \(timestamp)
        ;; Errors: \(mappings.count) mapping(s) could not be applied

        \(failedConfig)
        """
        try await writeFileURLAsync(string: backupContent, to: backupURL)

        AppLogger.shared.log("💾 [Config] Failed config backed up to: \(backupPath)")

        // Apply safe default config using the standard generator
        let safeConfig = KanataConfiguration.generateFromMappings(mappings)

        let configURL = URL(fileURLWithPath: configurationPath)
        try await writeFileURLAsync(string: safeConfig, to: configURL)

        AppLogger.shared.log("✅ [Config] Safe default config applied")

        // Update current configuration
        setCurrentConfiguration(
            KanataConfiguration(
                content: safeConfig,
                keyMappings: [KeyMapping(input: "caps", output: "escape")],
                lastModified: Date(),
                path: configurationPath
            ))

        return backupPath
    }

    /// Repair configuration using rule-based strategies (keeps output Kanata-compatible).
    public func repairConfiguration(config: String, errors: [String], mappings: [KeyMapping])
        async throws
        -> String {
        AppLogger.shared.log("🔧 [Config] Performing rule-based repair for \(errors.count) errors")

        // Common repair strategies
        var repairedConfig = config

        for error in errors {
            let lowerError = error.lowercased()

            // Fix common syntax errors
            if lowerError.contains("missing"), lowerError.contains("defcfg") {
                // Add missing defcfg using the same safe defaults as our generator
                if !repairedConfig.contains("(defcfg") {
                    let defcfgSection = """
                    (defcfg
                      process-unmapped-keys yes
                      danger-enable-cmd yes
                    )

                    """
                    repairedConfig = defcfgSection + repairedConfig
                }
            }

            // Fix empty parentheses issues
            if lowerError.contains("()") || lowerError.contains("empty") {
                repairedConfig = repairedConfig.replacingOccurrences(of: "()", with: "_")
                repairedConfig = repairedConfig.replacingOccurrences(of: "( )", with: "_")
            }

            // Fix mismatched defsrc/deflayer lengths
            if lowerError.contains("mismatch") || lowerError.contains("length") {
                // Regenerate from scratch using our proven template
                return KanataConfiguration.generateFromMappings(mappings)
            }
        }

        return repairedConfig
    }

    // MARK: - Private Methods

    private func handleFileChange() async {
        AppLogger.shared.log("📁 [ConfigService] Configuration file changed - reloading")
        do {
            _ = try await reload()
            AppLogger.shared.log("✅ [ConfigService] Configuration reloaded successfully")
        } catch {
            AppLogger.shared.log("❌ [ConfigService] Failed to reload configuration: \(error)")
        }
    }

    private func stopFileMonitoring() {
        fileWatcher = nil
        AppLogger.shared.log("🛑 [ConfigService] File monitoring stopped")
    }

    /// Extract key mappings from Kanata configuration content
    private func extractKeyMappingsFromContent(_ configContent: String) -> [KeyMapping] {
        var mappings: [KeyMapping] = []
        let lines = configContent.components(separatedBy: .newlines)

        var inDefsrc = false
        var inDeflayer = false
        var srcKeys: [String] = []
        var layerKeys: [String] = []

        for line in lines {
            let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)

            if trimmed.hasPrefix("(defsrc") {
                inDefsrc = true
                inDeflayer = false
                continue
            } else if trimmed.hasPrefix("(deflayer") {
                inDefsrc = false
                inDeflayer = true
                continue
            } else if trimmed == ")" {
                inDefsrc = false
                inDeflayer = false
                continue
            }

            if inDefsrc, !trimmed.isEmpty, !trimmed.hasPrefix(";") {
                srcKeys.append(
                    contentsOf: trimmed.components(separatedBy: .whitespaces).filter { !$0.isEmpty })
            } else if inDeflayer, !trimmed.isEmpty, !trimmed.hasPrefix(";") {
                layerKeys.append(
                    contentsOf: trimmed.components(separatedBy: .whitespaces).filter { !$0.isEmpty })
            }
        }

        // Match up src and layer keys, filtering out invalid keys
        var tempMappings: [KeyMapping] = []
        for (index, srcKey) in srcKeys.enumerated() where index < layerKeys.count {
            // Skip obviously invalid keys
            if srcKey != "invalid", !srcKey.isEmpty {
                tempMappings.append(KeyMapping(input: srcKey, output: layerKeys[index]))
            }
        }

        // Deduplicate mappings - keep only the last mapping for each input key
        var seenInputs: Set<String> = []
        for mapping in tempMappings.reversed() where !seenInputs.contains(mapping.input) {
            mappings.insert(mapping, at: 0)
            seenInputs.insert(mapping.input)
        }

        AppLogger.shared.log(
            "🔍 [Parse] Found \(srcKeys.count) src keys, \(layerKeys.count) layer keys, deduplicated to \(mappings.count) unique mappings"
        )
        return mappings
    }

    private func buildKanataArguments(checkOnly: Bool = false) -> [String] {
        var args = ["--cfg", configurationPath]
        if checkOnly {
            args.append("--check")
        }

        // Add TCP port argument for actual runs (not validation checks)
        if !checkOnly {
            let tcpPort = PreferencesService.shared.tcpServerPort
            args.append(contentsOf: ["--port", "\(tcpPort)"])
            AppLogger.shared.log("📡 [ConfigService] Added TCP port argument: --port \(tcpPort)")
        }

        return args
    }

    /// Parse configuration from string content
    public func parseConfigurationFromString(_ content: String) throws -> KanataConfiguration {
        // Use the existing validate method which handles parsing
        try validate(content: content)
    }

    /// Parse Kanata error output to extract error messages
    /// Kanata uses miette for rich error formatting, which outputs:
    /// - [ERROR] line with brief description
    /// - Code context with arrows pointing to the error
    /// - "help:" line with actionable description (e.g., "Unknown key in defsrc: \"hangeul\"")
    public func parseKanataErrors(_ output: String) -> [String] {
        var errors: [String] = []
        let lines = output.components(separatedBy: .newlines)

        // Extract [ERROR] lines
        for line in lines where line.contains("[ERROR]") {
            if let errorRange = line.range(of: "[ERROR]") {
                let errorMessage = String(line[errorRange.upperBound...]).trimmingCharacters(
                    in: .whitespaces)
                errors.append(errorMessage)
            }
        }

        // Also extract "help:" lines - these contain the most actionable information
        // e.g., "help: Unknown key in defsrc: \"hangeul\""
        for line in lines {
            let trimmed = line.trimmingCharacters(in: .whitespaces)
            if trimmed.hasPrefix("help:") {
                let helpMessage = String(trimmed.dropFirst(5)).trimmingCharacters(in: .whitespaces)
                if !helpMessage.isEmpty {
                    errors.append("💡 \(helpMessage)")
                }
            }
        }

        // Don't return empty strings - if no specific errors found and output is empty/whitespace,
        // return empty array instead of an array with empty string
        if errors.isEmpty {
            let trimmedOutput = output.trimmingCharacters(in: .whitespacesAndNewlines)
            if !trimmedOutput.isEmpty {
                // If there's non-empty output but no [ERROR] tags, include the full output as error
                errors.append(trimmedOutput)
            }
        }

        return errors
    }
}

// MARK: - Private helpers (I/O and state)

private extension ConfigurationService {
    func withLockedCurrentConfig() -> KanataConfiguration? {
        stateLock.lock()
        defer { stateLock.unlock() }
        return currentConfiguration
    }

    func setCurrentConfiguration(_ config: KanataConfiguration) {
        stateLock.lock()
        defer { stateLock.unlock() }
        currentConfiguration = config
    }

    func observersSnapshot() -> [@Sendable (Config) async -> Void] {
        stateLock.lock()
        defer { stateLock.unlock() }
        return observers
    }

    func readFileAsync(path: String) async throws -> String {
        try await withCheckedThrowingContinuation { cont in
            ioQueue.async {
                do {
                    let content = try String(contentsOfFile: path, encoding: .utf8)
                    cont.resume(returning: content)
                } catch {
                    cont.resume(throwing: error)
                }
            }
        }
    }

    func writeFileAsync(string: String, to path: String) async throws {
        // SAFETY: Prevent writing empty config files - this is a critical guard
        // against bugs that could wipe the user's config
        let trimmed = string.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else {
            AppLogger.shared.error("🛑 [ConfigService] BLOCKED: Attempted to write empty content to \(path)")
            throw KeyPathError.configuration(.invalidFormat(reason: "Cannot write empty configuration"))
        }

        // Additional safety: config files must have minimum required structure
        if path.hasSuffix(".kbd") {
            guard trimmed.contains("defsrc") || trimmed.contains("deflayer") else {
                AppLogger.shared.error("🛑 [ConfigService] BLOCKED: Config missing required defsrc/deflayer: \(path)")
                throw KeyPathError.configuration(.invalidFormat(reason: "Configuration missing required defsrc or deflayer block"))
            }
        }

        try await withCheckedThrowingContinuation { cont in
            ioQueue.async {
                do {
                    try string.write(toFile: path, atomically: true, encoding: .utf8)
                    cont.resume()
                } catch {
                    cont.resume(throwing: error)
                }
            }
        }
    }

    func writeFileURLAsync(string: String, to url: URL) async throws {
        try await withCheckedThrowingContinuation { cont in
            ioQueue.async {
                do {
                    try string.write(to: url, atomically: true, encoding: .utf8)
                    cont.resume()
                } catch {
                    cont.resume(throwing: error)
                }
            }
        }
    }

    func createDirectoryAsync(path: String) async throws {
        try await withCheckedThrowingContinuation { cont in
            ioQueue.async {
                do {
                    try FileManager.default.createDirectory(
                        atPath: path,
                        withIntermediateDirectories: true,
                        attributes: [.posixPermissions: 0o755]
                    )
                    cont.resume()
                } catch {
                    cont.resume(throwing: error)
                }
            }
        }
    }

    func fileExistsAsync(path: String) async -> Bool {
        await withCheckedContinuation { cont in
            ioQueue.async {
                cont.resume(returning: FileManager.default.fileExists(atPath: path))
            }
        }
    }
}

// MARK: - Key Conversion Utilities

/// Utility class for converting keys between KeyPath and Kanata formats
public enum KanataKeyConverter {
    /// Convert KeyPath key to Kanata key format for use inside macros
    /// Inside macros, chord syntax like M-right requires UPPERCASE modifier prefixes
    /// This method preserves the case of modifier prefixes (M-, A-, C-, S-)
    public static func convertToKanataKeyForMacro(_ input: String) -> String {
        // Known modifier prefixes that must remain uppercase in macro context
        // Order matters - check longer prefixes first
        let modifierPrefixes = ["M-S-", "C-S-", "A-S-", "M-", "A-", "C-", "S-"]

        for prefix in modifierPrefixes {
            if input.hasPrefix(prefix) {
                // Preserve uppercase prefix, convert base key
                let baseKey = String(input.dropFirst(prefix.count))
                let convertedBase = convertToKanataKey(baseKey)
                return prefix + convertedBase
            }
        }

        // No modifier prefix - use standard conversion
        return convertToKanataKey(input)
    }

    /// Convert KeyPath input key to Kanata key format
    public static func convertToKanataKey(_ input: String) -> String {
        // Use the same key mapping logic as the original RuntimeCoordinator
        let keyMap: [String: String] = [
            "caps": "caps",
            "capslock": "caps",
            "caps lock": "caps",
            "space": "spc",
            "spacebar": "spc",
            "enter": "ret",
            "return": "ret",
            "tab": "tab",
            "escape": "esc",
            "esc": "esc",
            "backspace": "bspc",
            "delete": "del",
            "cmd": "lmet",
            "command": "lmet",
            "lcmd": "lmet",
            "rcmd": "rmet",
            "leftcmd": "lmet",
            "rightcmd": "rmet",
            "left command": "lmet",
            "right command": "rmet",
            "left shift": "lsft",
            "lshift": "lsft",
            "right shift": "rsft",
            "rshift": "rsft",
            "left control": "lctl",
            "lctrl": "lctl",
            "ctrl": "lctl",
            "right control": "rctl",
            "rctrl": "rctl",
            "left option": "lalt",
            "lalt": "lalt",
            "right option": "ralt",
            "ralt": "ralt",
            "(": "lpar",
            ")": "rpar",
            // Punctuation keys - must be converted to kanata's abbreviated names
            "apostrophe": "'",
            "semicolon": ";",
            "comma": ",",
            "dot": ".",
            "period": ".",
            "slash": "/",
            "minus": "min",
            "equal": "eql",
            "equals": "eql",
            "grave": "grv",
            "backslash": "\\",
            "leftbrace": "[",
            "rightbrace": "]",
            "leftbracket": "[",
            "rightbracket": "]",
            // International/locale-specific keys
            // Korean keyboard keys
            "hangeul": "kana", // Korean Hanja key → maps to Japanese kana (similar input mode toggle)
            "hanja": "eisu", // Korean Han/Eng toggle → maps to Japanese eisu (alphanumeric mode)
            // ISO/International keys
            "intlbackslash": "nubs", // ISO key between Left Shift and Z (Non-US Backslash)
            "intlro": "ro", // ABNT2/JIS Ro key (extra key between slash and right shift)
            // JIS keys (already have native Kanata names, but add aliases)
            "eisu": "eisu", // Japanese alphanumeric key
            "kana": "kana" // Japanese kana key
        ]

        let lowercased = input.lowercased()

        // Check if we have a specific mapping
        if let mapped = keyMap[lowercased] {
            return mapped
        }

        // For single characters, return as-is
        if lowercased.count == 1 {
            return lowercased
        }

        // For tokens that would break Kanata syntax, replace parens explicitly
        if lowercased.contains("(") { return "lpar" }
        if lowercased.contains(")") { return "rpar" }

        // For function keys and others, return as-is but lowercased
        return lowercased
    }

    /// Convert KeyPath output sequence to Kanata output format
    public static func convertToKanataSequence(_ output: String) -> String {
        let trimmed = output.trimmingCharacters(in: .whitespacesAndNewlines)

        // Split on any whitespace
        let tokens = trimmed.components(separatedBy: .whitespacesAndNewlines).filter { !$0.isEmpty }

        // No tokens -> nothing to emit (avoid indexing empty array)
        if tokens.isEmpty {
            return ""
        }

        // Multiple whitespace-separated tokens (e.g., "cmd space") → chord/sequence
        if tokens.count > 1 {
            // Use convertToKanataKeyForMacro to preserve uppercase modifier prefixes
            let kanataKeys = tokens.map { convertToKanataKeyForMacro($0) }
            return "(\(kanataKeys.joined(separator: " ")))"
        }

        // Single token - check if it's a text sequence to type (e.g., "123", "hello")
        let singleToken = tokens[0]

        // If it's a multi-character string that looks like text to type (not a key name)
        // Convert to macro for typing each character
        if singleToken.count > 1, shouldConvertToMacro(singleToken) {
            // Split into individual characters and convert each to a key
            let characters = Array(singleToken)
            let keys = characters.map { String($0) }
            return "(macro \(keys.joined(separator: " ")))"
        }

        // Single key: use convertToKanataKeyForMacro to preserve uppercase modifier prefixes
        // (e.g., A-right, M-left, M-S-g) which are valid in both macro and deflayer contexts
        return convertToKanataKeyForMacro(singleToken)
    }

    /// Determine if a string should be converted to a macro (typed character by character)
    /// vs treated as a single key name like "escape" or "tab"
    private static func shouldConvertToMacro(_ token: String) -> Bool {
        // Check for Kanata modifier prefixes (e.g., A-right, M-left, C-S-a)
        // These should NOT be converted to macros - they are valid Kanata modified key outputs
        let modifierPattern = #"^(A-|M-|C-|S-|RA-|RM-|RC-|RS-|AG-)+"#
        if let regex = try? NSRegularExpression(pattern: modifierPattern, options: .caseInsensitive) {
            let range = NSRange(token.startIndex..., in: token)
            if regex.firstMatch(in: token, options: [], range: range) != nil {
                return false
            }
        }

        // Known key names that shouldn't be split into macros
        let keyNames: Set<String> = [
            "escape", "esc", "return", "ret", "enter",
            "backspace", "bspc", "delete", "del",
            "tab", "space", "spc",
            "capslock", "caps", "capslk",
            "leftshift", "lsft", "rightshift", "rsft",
            "leftctrl", "lctl", "rightctrl", "rctl", "ctrl",
            "leftalt", "lalt", "rightalt", "ralt",
            "leftmeta", "lmet", "rightmeta", "rmet",
            "leftcmd", "rightcmd", "cmd", "command", "lcmd", "rcmd",
            "up", "down", "left", "right",
            "home", "end", "pageup", "pgup", "pagedown", "pgdn",
            "f1", "f2", "f3", "f4", "f5", "f6",
            "f7", "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
            "f16", "f17", "f18", "f19", "f20",
            // Kanata media/system outputs
            "brdn", "brup", "mission_control", "launchpad",
            "prev", "pp", "next", "mute", "vold", "volu"
        ]

        // If it's a known key name, don't convert to macro
        if keyNames.contains(token.lowercased()) {
            return false
        }

        // If it contains multiple alphanumeric characters or symbols, treat as text to type
        return token.count > 1
    }
}

// MARK: - File Watcher (Simplified)

/// Simple file watcher for configuration changes
private class FileWatcher {
    private let path: String
    private let callback: () -> Void
    private var source: DispatchSourceFileSystemObject?

    init(path: String, callback: @escaping () -> Void) {
        self.path = path
        self.callback = callback
        startWatching()
    }

    deinit {
        stopWatching()
    }

    private func startWatching() {
        let fileDescriptor = open(path, O_RDONLY)
        guard fileDescriptor >= 0 else {
            AppLogger.shared.log("❌ [FileWatcher] Could not open file for watching: \(path)")
            return
        }

        source = DispatchSource.makeFileSystemObjectSource(
            fileDescriptor: fileDescriptor,
            eventMask: [.write, .delete, .rename],
            queue: DispatchQueue.global(qos: .utility)
        )

        source?.setEventHandler { [weak self] in
            self?.callback()
        }

        source?.setCancelHandler {
            close(fileDescriptor)
        }

        source?.resume()
    }

    private func stopWatching() {
        source?.cancel()
        source = nil
    }
}
