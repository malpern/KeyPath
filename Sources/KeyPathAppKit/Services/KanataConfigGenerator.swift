import Foundation
import KeyPathCore

/// Service for generating Kanata configuration using Claude API
public class KanataConfigGenerator {
    private let kanataManager: RuntimeCoordinator

    init(kanataManager: RuntimeCoordinator) {
        self.kanataManager = kanataManager
    }

    /// Generate Kanata configuration for a key mapping using Claude API
    public func generateMapping(input: KeySequence, output: KeySequence) async throws -> String {
        let configGuide = try await loadKanataConfigGuide()

        let prompt = buildPrompt(input: input, output: output, configGuide: configGuide)

        AppLogger.shared.log("ü§ñ [ConfigGenerator] Generating Kanata config via Claude API")
        AppLogger.shared.log("üîç [ConfigGenerator] Input: \(input.technicalDescription)")
        AppLogger.shared.log("üîç [ConfigGenerator] Output: \(output.technicalDescription)")

        do {
            let result = try await callClaudeAPIDirectly(prompt: prompt)
            AppLogger.shared.log("‚úÖ [ConfigGenerator] Successfully generated config via Claude API")
            return result
        } catch {
            AppLogger.shared.log("‚ùå [ConfigGenerator] Claude API failed: \(error)")
            // Fallback to basic generation if Claude API fails
            return generateBasicMapping(input: input, output: output)
        }
    }

    /// Load the Kanata configuration guide from the bundled kanata repository
    private func loadKanataConfigGuide() async throws -> String {
        let configPath = "External/kanata/docs/config.adoc"

        // Try to load from the project directory
        if let projectRoot = getProjectRoot(),
           let content = try? String(contentsOfFile: "\(projectRoot)/\(configPath)", encoding: .utf8)
        {
            AppLogger.shared.log("‚úÖ [ConfigGenerator] Loaded Kanata config guide from project")
            return content
        }

        // If that fails, try relative to the current working directory
        if let content = try? String(contentsOfFile: configPath, encoding: .utf8) {
            AppLogger.shared.log("‚úÖ [ConfigGenerator] Loaded Kanata config guide from working directory")
            return content
        }

        // Final fallback - use a minimal config guide
        AppLogger.shared.log(
            "‚ö†Ô∏è [ConfigGenerator] Could not load full config guide, using basic version"
        )
        return basicConfigGuide
    }

    /// Build the prompt for Claude API including the captured sequences and config guide
    private func buildPrompt(input: KeySequence, output: KeySequence, configGuide: String) -> String {
        """
        I need to generate a Kanata keyboard configuration for macOS that maps captured key sequences to output sequences.

        INPUT SEQUENCE:
        \(input.technicalDescription)
        Display: "\(input.displayString)"

        OUTPUT SEQUENCE:
        \(output.technicalDescription)
        Display: "\(output.displayString)"

        KANATA CONFIGURATION REFERENCE:
        \(configGuide)

        Please generate ONLY the Kanata configuration code (the .kbd file content) that maps the input sequence to the output sequence. Follow these requirements:

        1. Use proper Kanata syntax as shown in the reference guide
        2. For single keys, use simple mapping in deflayer
        3. For key combinations (chords), use appropriate chord notation (C- for Control, S- for Shift, M- for Command/Meta, A- for Alt/Option)
        4. For sequences, use macro actions with appropriate timing
        5. Include proper defcfg with process-unmapped-keys no for safety
        6. Include necessary defsrc and deflayer sections
        7. Add brief comments explaining the mapping

        Return ONLY the Kanata configuration code, no explanations or extra text.
        """
    }

    /// Fallback method to generate basic mapping without Claude API
    private func generateBasicMapping(input: KeySequence, output: KeySequence) -> String {
        AppLogger.shared.log("üîß [ConfigGenerator] Generating basic config mapping")

        let inputKey = convertSequenceToKanataKey(input)
        let outputKey = convertSequenceToKanataOutput(output)

        return """
        ;; Generated by KeyPath - Basic mapping
        ;; Input: \(input.displayString) ‚Üí Output: \(output.displayString)

        (defcfg
          process-unmapped-keys yes
        )

        (defsrc
          \(inputKey)
        )

        (deflayer base
          \(outputKey)
        )
        """
    }

    /// Convert KeySequence to Kanata key forma
    private func convertSequenceToKanataKey(_ sequence: KeySequence) -> String {
        guard let firstKey = sequence.keys.first else { return "spc" }

        var result = firstKey.baseKey.lowercased()

        // Handle special key names
        let keyMap: [String: String] = [
            "space": "spc",
            "return": "ret",
            "enter": "ret",
            "escape": "esc",
            "backspace": "bspc",
            "delete": "del",
            "caps": "caps",
            "capslock": "caps"
        ]

        if let mapped = keyMap[result] {
            result = mapped
        }

        return result
    }

    /// Convert KeySequence to Kanata output format (may include chords or macros)
    private func convertSequenceToKanataOutput(_ sequence: KeySequence) -> String {
        if sequence.keys.count == 1 {
            let keyPress = sequence.keys[0]
            if keyPress.modifiers.isEmpty {
                return convertSequenceToKanataKey(sequence)
            } else {
                // Single key with modifiers - use chord notation
                var modifierStr = ""
                if keyPress.modifiers.contains(.control) { modifierStr += "C-" }
                if keyPress.modifiers.contains(.option) { modifierStr += "A-" }
                if keyPress.modifiers.contains(.shift) { modifierStr += "S-" }
                if keyPress.modifiers.contains(.command) { modifierStr += "M-" }

                return modifierStr + keyPress.baseKey.lowercased()
            }
        } else {
            // Multiple keys - use macro
            let keyStrings = sequence.keys.map { keyPress in
                var result = keyPress.baseKey.lowercased()
                if keyPress.modifiers.contains(.control) { result = "C-" + result }
                if keyPress.modifiers.contains(.option) { result = "A-" + result }
                if keyPress.modifiers.contains(.shift) { result = "S-" + result }
                if keyPress.modifiers.contains(.command) { result = "M-" + result }
                return result
            }
            return "(macro \(keyStrings.joined(separator: " ")))"
        }
    }

    /// Get the project root directory
    private func getProjectRoot() -> String? {
        let fileManager = FileManager.default
        var currentPath = fileManager.currentDirectoryPath

        // Look for characteristic files that indicate project roo
        let markers = ["Package.swift", "CLAUDE.md", "External/kanata"]

        for _ in 0 ..< 10 { // Limit search depth
            for marker in markers {
                let markerPath = "\(currentPath)/\(marker)"
                if fileManager.fileExists(atPath: markerPath) {
                    return currentPath
                }
            }

            // Go up one directory
            let parentPath = (currentPath as NSString).deletingLastPathComponent
            if parentPath == currentPath {
                break // Reached roo
            }
            currentPath = parentPath
        }

        return nil
    }

    /// Basic configuration guide as fallback
    private let basicConfigGuide = """
    KANATA CONFIGURATION BASICS:

    1. Configuration Structure:
    (defcfg
      process-unmapped-keys no  ; Only process mapped keys for safety
    )

    (defsrc
      key1 key2 key3  ; Physical keys to intercep
    )

    (deflayer base
      out1 out2 out3  ; What those keys should outpu
    )

    2. Key Names:
    - Letters: a b c ... z
    - Numbers: 1 2 3 ... 0
    - Special: spc (space), ret (enter), esc (escape), bspc (backspace), tab, caps
    - Modifiers: lctl rctl lalt ralt lsft rsft lmet rme

    3. Chord Notation:
    - C-a = Control+A
    - S-a = Shift+A
    - M-a = Meta/Command+A
    - A-a = Alt/Option+A
    - C-S-a = Control+Shift+A

    4. Macros for Sequences:
    (macro key1 key2 key3)  ; Press keys in sequence
    (macro key1 100 key2)   ; With 100ms delay

    5. Multi Actions:
    (multi key1 key2)       ; Press keys simultaneously
    """

    /// Error thrown when user cancels biometric authentication
    public enum ConfigGeneratorError: Error, LocalizedError {
        case authenticationCancelled
        case noAPIKey

        public var errorDescription: String? {
            switch self {
            case .authenticationCancelled:
                "Authentication was cancelled"
            case .noAPIKey:
                "Claude API key not found. Set ANTHROPIC_API_KEY environment variable or add in Settings."
            }
        }
    }

    /// Direct Claude API call with biometric auth and cost tracking
    private func callClaudeAPIDirectly(prompt: String) async throws -> String {
        // Get API key using KeychainService (static method for non-MainActor access)
        guard let apiKey = KeychainService.getClaudeAPIKeyStatic() else {
            throw ConfigGeneratorError.noAPIKey
        }

        // Biometric authentication before expensive API call
        let authResult = await BiometricAuthService.shared.authenticate(
            reason: "This AI generation will use your Anthropic API quota and cost approximately $0.01-0.03. Authenticate to proceed?"
        )

        switch authResult {
        case .cancelled:
            throw ConfigGeneratorError.authenticationCancelled
        case let .failed(errorMessage):
            AppLogger.shared.log("‚ö†Ô∏è [ConfigGenerator] Auth failed: \(errorMessage), proceeding anyway")
        // Continue - biometric failure shouldn't block if user has API key
        case .authenticated, .notRequired:
            break // Continue with API call
        }

        let url = URL(string: "https://api.anthropic.com/v1/messages")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue(apiKey, forHTTPHeaderField: "x-api-key")
        request.addValue("2023-06-01", forHTTPHeaderField: "anthropic-version")

        let requestBody: [String: Any] = [
            "model": "claude-3-5-sonnet-20241022",
            "max_tokens": 4096,
            "messages": [
                [
                    "role": "user",
                    "content": prompt
                ]
            ]
        ]

        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        let (data, response) = try await URLSession.shared.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw NSError(
                domain: "ClaudeAPI", code: 2, userInfo: [NSLocalizedDescriptionKey: "Invalid response"]
            )
        }

        guard 200 ... 299 ~= httpResponse.statusCode else {
            let errorMessage = String(data: data, encoding: .utf8) ?? "Unknown error"
            throw NSError(
                domain: "ClaudeAPI", code: httpResponse.statusCode,
                userInfo: [
                    NSLocalizedDescriptionKey:
                        "API request failed (\(httpResponse.statusCode)): \(errorMessage)"
                ]
            )
        }

        guard let jsonResponse = try JSONSerialization.jsonObject(with: data) as? [String: Any],
              let content = jsonResponse["content"] as? [[String: Any]],
              let firstContent = content.first,
              let text = firstContent["text"] as? String
        else {
            throw NSError(
                domain: "ClaudeAPI", code: 3,
                userInfo: [NSLocalizedDescriptionKey: "Failed to parse Claude API response"]
            )
        }

        // Extract and log usage for cost tracking
        if let usage = jsonResponse["usage"] as? [String: Any],
           let inputTokens = usage["input_tokens"] as? Int,
           let outputTokens = usage["output_tokens"] as? Int
        {
            await AICostTracker.shared.trackUsage(
                inputTokens: inputTokens,
                outputTokens: outputTokens,
                source: .configGenerator,
                logPrefix: "ConfigGenerator"
            )
        }

        return text.trimmingCharacters(in: .whitespacesAndNewlines)
    }
}
