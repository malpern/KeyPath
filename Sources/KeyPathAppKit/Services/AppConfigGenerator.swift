import Foundation
import KeyPathCore

// MARK: - Error Types

/// Errors that can occur during app config generation
public enum AppConfigError: LocalizedError, Equatable {
    /// Generated config failed Kanata validation
    case validationFailed(errors: [String])
    /// Failed to write config file
    case writeFailed(path: String, underlying: String)
    /// No ConfigurationService available for validation
    case validationUnavailable

    public var errorDescription: String? {
        switch self {
        case let .validationFailed(errors):
            "App config validation failed: \(errors.joined(separator: "; "))"
        case let .writeFailed(path, underlying):
            "Failed to write app config to \(path): \(underlying)"
        case .validationUnavailable:
            "Config validation service unavailable"
        }
    }

    /// User-facing message for UI display
    public var userFacingMessage: String {
        switch self {
        case let .validationFailed(errors):
            if errors.isEmpty {
                return "Config validation failed"
            }
            return errors.first ?? "Config validation failed"
        case let .writeFailed(path, _):
            return "Could not save config to \(path)"
        case .validationUnavailable:
            return "Validation service unavailable"
        }
    }
}

// MARK: - Kanata Keywords (Compile-Time Safety)

/// Type-safe constants for Kanata keywords to prevent typos like "nop" vs "XX"
public enum KanataKeyword {
    /// Blocked key - no output (use instead of invalid "nop")
    public static let blocked = "XX"
    /// Transparent - pass through to lower layer
    public static let transparent = "_"
    /// Switch expression keyword
    public static let switchExpr = "switch"
    /// Input virtual key condition
    public static let inputVirtual = "input virtual"
}

/// Generates Kanata configuration for app-specific keymaps.
///
/// Outputs: `keypath-apps.kbd`
///
/// This file contains:
/// - `defvirtualkeys` block with app virtual keys (e.g., `vk_safari`)
/// - `defalias` block with switch expressions for app-specific overrides
///
/// See ADR-027 for the full architecture.
///
/// ## Example Output
/// ```lisp
/// ;; Generated by KeyPath - App-Specific Keymaps
/// ;; DO NOT EDIT - Regenerated when app keymaps change
///
/// (defvirtualkeys
///   vk_safari XX
///   vk_vs_code XX
/// )
///
/// (defalias
///   kp-j (switch ((input virtual vk_safari)) down break
///                ((input virtual vk_vs_code)) down break
///                () j break)
///   kp-k (switch ((input virtual vk_safari)) up break
///                () k break)
/// )
/// ```
public enum AppConfigGenerator {
    // MARK: - File Paths

    /// The output file for app-specific config
    public static var appConfigPath: String {
        let configDir = WizardSystemPaths.userConfigDirectory
        return (configDir as NSString).appendingPathComponent("keypath-apps.kbd")
    }

    // MARK: - Generation

    /// Generate the complete app-specific config file content.
    ///
    /// - Parameter keymaps: The app keymaps to generate config for.
    /// - Returns: The generated Kanata config content.
    public static func generate(from keymaps: [AppKeymap]) -> String {
        let enabledKeymaps = keymaps.filter(\.mapping.isEnabled)

        guard !enabledKeymaps.isEmpty else {
            return generateEmptyConfig()
        }

        var sections: [String] = []

        // Header
        sections.append(generateHeader(keymaps: enabledKeymaps))

        // Virtual keys block
        sections.append(generateVirtualKeysBlock(keymaps: enabledKeymaps))

        // Aliases block (switch expressions)
        let aliasBlock = generateAliasBlock(keymaps: enabledKeymaps)
        if !aliasBlock.isEmpty {
            sections.append(aliasBlock)
        }

        return sections.joined(separator: "\n")
    }

    /// Generate and write the app config file to disk.
    ///
    /// - Parameter keymaps: The app keymaps to generate config for.
    /// - Parameter configService: Configuration service for validation (uses shared instance if nil)
    /// - Throws: `AppConfigError` if validation fails or file cannot be written.
    public static func generateAndSave(
        from keymaps: [AppKeymap],
        configService: ConfigurationService? = nil
    ) async throws {
        let content = generate(from: keymaps)
        let path = appConfigPath

        // Ensure directory exists
        let directory = (path as NSString).deletingLastPathComponent
        try FileManager.default.createDirectory(
            atPath: directory,
            withIntermediateDirectories: true,
            attributes: nil
        )

        // VALIDATE BEFORE WRITING - prevent broken configs from being saved
        // This is the key fix: we validate generated configs just like we validate user configs
        //
        // NOTE: keypath-apps.kbd is an INCLUDE file, not a standalone config.
        // Kanata requires defsrc/deflayer for validation, so we wrap the content
        // in a minimal valid config context for validation purposes only.
        let service: ConfigurationService = if let provided = configService {
            provided
        } else {
            await ConfigurationService(configDirectory: WizardSystemPaths.userConfigDirectory)
        }
        AppLogger.shared.log("üîç [AppConfigGenerator] Validating generated config before save...")

        // Wrap content in minimal valid config for validation (include files need context)
        let validationWrapper = wrapForValidation(content)
        let validation = await service.validateConfiguration(validationWrapper)

        if !validation.isValid {
            AppLogger.shared.error(
                "‚ùå [AppConfigGenerator] Validation failed with \(validation.errors.count) errors: \(validation.errors)"
            )
            throw AppConfigError.validationFailed(errors: validation.errors)
        }

        AppLogger.shared.log("‚úÖ [AppConfigGenerator] Validation passed, writing config...")

        // Write validated file
        do {
            try content.write(toFile: path, atomically: true, encoding: .utf8)
        } catch {
            throw AppConfigError.writeFailed(path: path, underlying: error.localizedDescription)
        }

        AppLogger.shared.log("üíæ [AppConfigGenerator] Saved app config to \(path)")
        AppLogger.shared.log("üíæ [AppConfigGenerator] Content:\n\(content.prefix(500))...")
    }

    /// Load keymaps from store and regenerate the config file.
    /// - Throws: `AppConfigError` if validation fails or file cannot be written.
    public static func regenerateFromStore() async throws {
        let keymaps = await AppKeymapStore.shared.loadKeymaps()
        try await generateAndSave(from: keymaps)
    }

    // MARK: - Private Helpers

    /// Wrap app config content in a minimal valid Kanata config for validation.
    ///
    /// Since keypath-apps.kbd is an include file (not standalone), Kanata's --check
    /// requires defsrc/deflayer context. This wrapper provides that context for
    /// validation only - the actual file written is just the app config content.
    private static func wrapForValidation(_ content: String) -> String {
        """
        ;; Validation wrapper - provides minimal context for include file validation
        (defcfg
          process-unmapped-keys yes
        )

        (defsrc a b c d e f g h i j k l m n o p q r s t u v w x y z)

        (deflayer base a b c d e f g h i j k l m n o p q r s t u v w x y z)

        ;; === BEGIN APP CONFIG CONTENT ===
        \(content)
        ;; === END APP CONFIG CONTENT ===
        """
    }

    private static func generateEmptyConfig() -> String {
        """
        ;; Generated by KeyPath - App-Specific Keymaps
        ;; No app keymaps configured.
        ;; Use the KeyPath UI to add app-specific key bindings.

        ;; To use app-specific keymaps, create keymaps in KeyPath's UI
        ;; and this file will be regenerated with the appropriate
        ;; virtual keys and aliases.

        """
    }

    private static func generateHeader(keymaps: [AppKeymap]) -> String {
        let appNames = keymaps.map(\.mapping.displayName).joined(separator: ", ")
        let timestamp = ISO8601DateFormatter().string(from: Date())

        return """
        ;; Generated by KeyPath - App-Specific Keymaps
        ;; DO NOT EDIT - Regenerated when app keymaps change
        ;;
        ;; Apps: \(appNames)
        ;; Generated: \(timestamp)
        ;;
        ;; Include this file in your main config:
        ;;   (include keypath-apps.kbd)
        ;;
        ;; Use the generated aliases (kp-j, kp-k, etc.) in your layers
        ;; for app-specific behavior.

        """
    }

    private static func generateVirtualKeysBlock(keymaps: [AppKeymap]) -> String {
        var lines: [String] = []
        lines.append(";; Virtual keys for app detection (activated via TCP)")
        lines.append("(defvirtualkeys")

        for keymap in keymaps {
            let vkName = keymap.mapping.virtualKeyName
            let appName = keymap.mapping.displayName
            // Use KanataKeyword.blocked for type-safety (prevents "nop" typo bug)
            lines.append("  \(vkName) \(KanataKeyword.blocked)  ;; \(appName)")
        }

        lines.append(")")
        lines.append("")

        return lines.joined(separator: "\n")
    }

    private static func generateAliasBlock(keymaps: [AppKeymap]) -> String {
        // Collect all unique input keys across all keymaps
        var keyToOverrides: [String: [(keymap: AppKeymap, override: AppKeyOverride)]] = [:]

        for keymap in keymaps {
            for override in keymap.overrides {
                let key = override.inputKey.lowercased()
                keyToOverrides[key, default: []].append((keymap, override))
            }
        }

        guard !keyToOverrides.isEmpty else {
            return ""
        }

        var lines: [String] = []
        lines.append(";; Aliases with app-specific switch expressions")
        lines.append(";; Use these in your layers: @kp-j, @kp-k, etc.")
        lines.append("(defalias")

        // Sort keys for deterministic output
        for inputKey in keyToOverrides.keys.sorted() {
            guard let overrides = keyToOverrides[inputKey] else { continue }

            let aliasName = "kp-\(sanitizeKeyName(inputKey))"
            let switchExpr = generateSwitchExpression(
                inputKey: inputKey,
                overrides: overrides
            )

            lines.append("  \(aliasName) \(switchExpr)")
        }

        lines.append(")")
        lines.append("")

        return lines.joined(separator: "\n")
    }

    /// Generate a switch expression for a key with app-specific overrides.
    ///
    /// Kanata switch requires triples: <condition> <action> <break|fallthrough>
    ///
    /// Example output:
    /// ```
    /// (switch ((input virtual vk_safari)) down break
    ///         ((input virtual vk_vs_code)) pgdn break
    ///         () j break)
    /// ```
    private static func generateSwitchExpression(
        inputKey: String,
        overrides: [(keymap: AppKeymap, override: AppKeyOverride)]
    ) -> String {
        var parts = ["(switch"]

        // Add each app-specific case (Kanata switch requires: condition action break/fallthrough)
        for (keymap, override) in overrides {
            let vkName = keymap.mapping.virtualKeyName
            let output = escapeOutputAction(override.outputAction)
            parts.append("((\(KanataKeyword.inputVirtual) \(vkName))) \(output) break")
        }

        // Default case: pass through the original key
        let safeInputKey = escapeOutputAction(inputKey)
        parts.append("() \(safeInputKey) break)")

        // Format based on number of cases
        if overrides.count == 1 {
            // Single case: one line
            return parts.joined(separator: " ")
        } else {
            // Multiple cases: multi-line for readability
            var formatted = "(switch\n"
            for (keymap, override) in overrides {
                let vkName = keymap.mapping.virtualKeyName
                let output = escapeOutputAction(override.outputAction)
                formatted += "            ((\(KanataKeyword.inputVirtual) \(vkName))) \(output) break\n"
            }
            formatted += "            () \(safeInputKey) break)"
            return formatted
        }
    }

    /// Sanitize a key name for use in an alias name.
    /// Returns a valid identifier even for edge cases like empty strings or special chars only.
    private static func sanitizeKeyName(_ key: String) -> String {
        let sanitized = key.lowercased()
            .replacingOccurrences(of: " ", with: "-")
            .filter { $0.isLetter || $0.isNumber || $0 == "-" }

        // Handle empty result
        guard !sanitized.isEmpty else {
            // Use a hash of the original key as fallback
            let hash = stableKeyHash(key)
            return "key-\(hash)"
        }

        // Ensure it starts with a letter
        if let first = sanitized.first, !first.isLetter {
            return "key-\(sanitized)"
        }

        return sanitized
    }

    /// Generate a stable hash for a key name (for edge cases).
    private static func stableKeyHash(_ input: String) -> String {
        // Simple deterministic hash - sum of character values mod a prime
        let sum = input.unicodeScalars.reduce(0) { $0 + Int($1.value) }
        return String(format: "%04x", sum % 65521)
    }

    /// Escape special characters in Kanata output actions.
    /// Wraps complex actions in parentheses if needed.
    /// Sequences of multiple keys are wrapped in (macro ...).
    static func escapeOutputAction(_ action: String) -> String {
        let trimmed = action.trimmingCharacters(in: .whitespaces)

        // Already wrapped in parens - assume it's a valid expression
        if trimmed.hasPrefix("("), trimmed.hasSuffix(")") {
            return trimmed
        }

        // Already an alias reference
        if trimmed.hasPrefix("@") {
            return trimmed
        }

        // Check if this is a sequence of multiple keys (space-separated)
        let parts = trimmed.split(separator: " ")
        if parts.count > 1 {
            // Multiple keys = wrap in macro
            return "(macro \(trimmed))"
        }

        return trimmed
    }
}

// MARK: - Convenience Extensions

public extension AppConfigGenerator {
    /// Check if the app config file exists
    static var configFileExists: Bool {
        FileManager.default.fileExists(atPath: appConfigPath)
    }

    /// Read the current app config file content
    static func readCurrentConfig() -> String? {
        try? String(contentsOfFile: appConfigPath, encoding: .utf8)
    }

    /// Delete the app config file
    static func deleteConfig() throws {
        let path = appConfigPath
        if FileManager.default.fileExists(atPath: path) {
            try FileManager.default.removeItem(atPath: path)
            AppLogger.shared.log("üóëÔ∏è [AppConfigGenerator] Deleted app config at \(path)")
        }
    }

    /// Regenerate the main Kanata config to use @kp-* aliases for app-specific keys.
    /// This must be called after saving app-specific mappings so the base layer
    /// uses the switch expression aliases instead of plain keys.
    static func regenerateMainConfig() async throws {
        AppLogger.shared.log("üîÑ [AppConfigGenerator] Regenerating main config to use app-specific aliases...")

        // Load current rule collections
        let ruleCollectionStore = RuleCollectionStore()
        let ruleCollections = await ruleCollectionStore.loadCollections()

        // Load current custom rules
        let customRulesStore = CustomRulesStore()
        let customRules = await customRulesStore.loadRules()

        // Regenerate and save the main config via ConfigurationService
        // This will pick up the app-specific keys and use @kp-* aliases
        let configService = await ConfigurationService(configDirectory: WizardSystemPaths.userConfigDirectory)
        try await configService.saveConfiguration(
            ruleCollections: ruleCollections,
            customRules: customRules
        )

        AppLogger.shared.log("‚úÖ [AppConfigGenerator] Main config regenerated with app-specific aliases")
    }
}
