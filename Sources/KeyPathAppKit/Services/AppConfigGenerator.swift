import Foundation
import KeyPathCore

/// Generates Kanata configuration for app-specific keymaps.
///
/// Outputs: `keypath-apps.kbd`
///
/// This file contains:
/// - `defvirtualkeys` block with app virtual keys (e.g., `vk_safari`)
/// - `defalias` block with switch expressions for app-specific overrides
///
/// See ADR-027 for the full architecture.
///
/// ## Example Output
/// ```lisp
/// ;; Generated by KeyPath - App-Specific Keymaps
/// ;; DO NOT EDIT - Regenerated when app keymaps change
///
/// (defvirtualkeys
///   vk_safari nop
///   vk_vs_code nop
/// )
///
/// (defalias
///   kp-j (switch ((input virtual vk_safari)) down
///                ((input virtual vk_vs_code)) down
///                () j)
///   kp-k (switch ((input virtual vk_safari)) up
///                () k)
/// )
/// ```
public enum AppConfigGenerator {
    // MARK: - File Paths

    /// The output file for app-specific config
    public static var appConfigPath: String {
        let configDir = WizardSystemPaths.userConfigDirectory
        return (configDir as NSString).appendingPathComponent("keypath-apps.kbd")
    }

    // MARK: - Generation

    /// Generate the complete app-specific config file content.
    ///
    /// - Parameter keymaps: The app keymaps to generate config for.
    /// - Returns: The generated Kanata config content.
    public static func generate(from keymaps: [AppKeymap]) -> String {
        let enabledKeymaps = keymaps.filter(\.mapping.isEnabled)

        guard !enabledKeymaps.isEmpty else {
            return generateEmptyConfig()
        }

        var sections: [String] = []

        // Header
        sections.append(generateHeader(keymaps: enabledKeymaps))

        // Virtual keys block
        sections.append(generateVirtualKeysBlock(keymaps: enabledKeymaps))

        // Aliases block (switch expressions)
        let aliasBlock = generateAliasBlock(keymaps: enabledKeymaps)
        if !aliasBlock.isEmpty {
            sections.append(aliasBlock)
        }

        return sections.joined(separator: "\n")
    }

    /// Generate and write the app config file to disk.
    ///
    /// - Parameter keymaps: The app keymaps to generate config for.
    /// - Throws: If the file cannot be written.
    public static func generateAndSave(from keymaps: [AppKeymap]) throws {
        let content = generate(from: keymaps)
        let path = appConfigPath

        // Ensure directory exists
        let directory = (path as NSString).deletingLastPathComponent
        try FileManager.default.createDirectory(
            atPath: directory,
            withIntermediateDirectories: true,
            attributes: nil
        )

        // Write file
        try content.write(toFile: path, atomically: true, encoding: .utf8)

        AppLogger.shared.log("üíæ [AppConfigGenerator] Saved app config to \(path)")
        AppLogger.shared.log("üíæ [AppConfigGenerator] Content:\n\(content.prefix(500))...")
    }

    /// Load keymaps from store and regenerate the config file.
    public static func regenerateFromStore() async throws {
        let keymaps = await AppKeymapStore.shared.loadKeymaps()
        try generateAndSave(from: keymaps)
    }

    // MARK: - Private Helpers

    private static func generateEmptyConfig() -> String {
        """
        ;; Generated by KeyPath - App-Specific Keymaps
        ;; No app keymaps configured.
        ;; Use the KeyPath UI to add app-specific key bindings.

        ;; To use app-specific keymaps, create keymaps in KeyPath's UI
        ;; and this file will be regenerated with the appropriate
        ;; virtual keys and aliases.

        """
    }

    private static func generateHeader(keymaps: [AppKeymap]) -> String {
        let appNames = keymaps.map(\.mapping.displayName).joined(separator: ", ")
        let timestamp = ISO8601DateFormatter().string(from: Date())

        return """
        ;; Generated by KeyPath - App-Specific Keymaps
        ;; DO NOT EDIT - Regenerated when app keymaps change
        ;;
        ;; Apps: \(appNames)
        ;; Generated: \(timestamp)
        ;;
        ;; Include this file in your main config:
        ;;   (include keypath-apps.kbd)
        ;;
        ;; Use the generated aliases (kp-j, kp-k, etc.) in your layers
        ;; for app-specific behavior.

        """
    }

    private static func generateVirtualKeysBlock(keymaps: [AppKeymap]) -> String {
        var lines: [String] = []
        lines.append(";; Virtual keys for app detection (activated via TCP)")
        lines.append("(defvirtualkeys")

        for keymap in keymaps {
            let vkName = keymap.mapping.virtualKeyName
            let appName = keymap.mapping.displayName
            lines.append("  \(vkName) nop  ;; \(appName)")
        }

        lines.append(")")
        lines.append("")

        return lines.joined(separator: "\n")
    }

    private static func generateAliasBlock(keymaps: [AppKeymap]) -> String {
        // Collect all unique input keys across all keymaps
        var keyToOverrides: [String: [(keymap: AppKeymap, override: AppKeyOverride)]] = [:]

        for keymap in keymaps {
            for override in keymap.overrides {
                let key = override.inputKey.lowercased()
                keyToOverrides[key, default: []].append((keymap, override))
            }
        }

        guard !keyToOverrides.isEmpty else {
            return ""
        }

        var lines: [String] = []
        lines.append(";; Aliases with app-specific switch expressions")
        lines.append(";; Use these in your layers: @kp-j, @kp-k, etc.")
        lines.append("(defalias")

        // Sort keys for deterministic output
        for inputKey in keyToOverrides.keys.sorted() {
            guard let overrides = keyToOverrides[inputKey] else { continue }

            let aliasName = "kp-\(sanitizeKeyName(inputKey))"
            let switchExpr = generateSwitchExpression(
                inputKey: inputKey,
                overrides: overrides
            )

            lines.append("  \(aliasName) \(switchExpr)")
        }

        lines.append(")")
        lines.append("")

        return lines.joined(separator: "\n")
    }

    /// Generate a switch expression for a key with app-specific overrides.
    ///
    /// Example output:
    /// ```
    /// (switch ((input virtual vk_safari)) down
    ///         ((input virtual vk_vs_code)) pgdn
    ///         () j)
    /// ```
    private static func generateSwitchExpression(
        inputKey: String,
        overrides: [(keymap: AppKeymap, override: AppKeyOverride)]
    ) -> String {
        var parts = ["(switch"]

        // Add each app-specific case
        for (keymap, override) in overrides {
            let vkName = keymap.mapping.virtualKeyName
            let output = escapeOutputAction(override.outputAction)
            parts.append("((input virtual \(vkName))) \(output)")
        }

        // Default case: pass through the original key
        let safeInputKey = escapeOutputAction(inputKey)
        parts.append("() \(safeInputKey))")

        // Format based on number of cases
        if overrides.count == 1 {
            // Single case: one line
            return parts.joined(separator: " ")
        } else {
            // Multiple cases: multi-line for readability
            var formatted = "(switch\n"
            for (keymap, override) in overrides {
                let vkName = keymap.mapping.virtualKeyName
                let output = escapeOutputAction(override.outputAction)
                formatted += "            ((input virtual \(vkName))) \(output)\n"
            }
            formatted += "            () \(safeInputKey))"
            return formatted
        }
    }

    /// Sanitize a key name for use in an alias name.
    /// Returns a valid identifier even for edge cases like empty strings or special chars only.
    private static func sanitizeKeyName(_ key: String) -> String {
        let sanitized = key.lowercased()
            .replacingOccurrences(of: " ", with: "-")
            .filter { $0.isLetter || $0.isNumber || $0 == "-" }

        // Handle empty result
        guard !sanitized.isEmpty else {
            // Use a hash of the original key as fallback
            let hash = stableKeyHash(key)
            return "key-\(hash)"
        }

        // Ensure it starts with a letter
        if let first = sanitized.first, !first.isLetter {
            return "key-\(sanitized)"
        }

        return sanitized
    }

    /// Generate a stable hash for a key name (for edge cases).
    private static func stableKeyHash(_ input: String) -> String {
        // Simple deterministic hash - sum of character values mod a prime
        let sum = input.unicodeScalars.reduce(0) { $0 + Int($1.value) }
        return String(format: "%04x", sum % 65521)
    }

    /// Escape special characters in Kanata output actions.
    /// Wraps complex actions in parentheses if needed.
    static func escapeOutputAction(_ action: String) -> String {
        let trimmed = action.trimmingCharacters(in: .whitespaces)

        // Already wrapped in parens - assume it's a valid expression
        if trimmed.hasPrefix("(") && trimmed.hasSuffix(")") {
            return trimmed
        }

        // Already an alias reference
        if trimmed.hasPrefix("@") {
            return trimmed
        }

        // Simple key name - check for special characters
        if trimmed.contains(" ") || trimmed.contains("(") || trimmed.contains(")") {
            // Likely needs to be wrapped or is malformed
            AppLogger.shared.warn("‚ö†Ô∏è [AppConfigGenerator] Potentially malformed action: \(trimmed)")
        }

        return trimmed
    }
}

// MARK: - Convenience Extensions

public extension AppConfigGenerator {
    /// Check if the app config file exists
    static var configFileExists: Bool {
        FileManager.default.fileExists(atPath: appConfigPath)
    }

    /// Read the current app config file content
    static func readCurrentConfig() -> String? {
        try? String(contentsOfFile: appConfigPath, encoding: .utf8)
    }

    /// Delete the app config file
    static func deleteConfig() throws {
        let path = appConfigPath
        if FileManager.default.fileExists(atPath: path) {
            try FileManager.default.removeItem(atPath: path)
            AppLogger.shared.log("üóëÔ∏è [AppConfigGenerator] Deleted app config at \(path)")
        }
    }
}
