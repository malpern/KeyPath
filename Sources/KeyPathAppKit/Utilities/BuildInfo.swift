import Foundation
import KeyPathCore

struct BuildInfo {
    let version: String
    let build: String
    let git: String
    let date: String
    let kanataVersion: String?

    /// Cached Kanata version (fetched once at startup)
    private nonisolated(unsafe) static var cachedKanataVersion: String?
    private nonisolated(unsafe) static var kanataVersionFetched = false

    static func current() -> BuildInfo {
        // Try to read BuildInfo.plist embedded in the app bundle (generated by build script)
        if let url = Bundle.main.url(forResource: "BuildInfo", withExtension: "plist"),
           let data = try? Data(contentsOf: url),
           let dict = try? PropertyListSerialization.propertyList(from: data, options: [], format: nil)
           as? [String: Any] {
            let version =
                (dict["CFBundleShortVersionString"] as? String)
                    ?? (Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String) ?? "1.0.0"
            let build =
                (dict["CFBundleVersion"] as? String)
                    ?? (Bundle.main.infoDictionary?["CFBundleVersion"] as? String) ?? "0"
            let git = (dict["GitCommit"] as? String) ?? "unknown"
            let date = (dict["BuildDate"] as? String) ?? ISO8601DateFormatter().string(from: Date())
            return BuildInfo(
                version: version,
                build: build,
                git: git,
                date: date,
                kanataVersion: cachedKanataVersion
            )
        }

        // Fallback to bundle info
        let version = (Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String) ?? "1.0.0"
        let build = (Bundle.main.infoDictionary?["CFBundleVersion"] as? String) ?? "0"
        let date = ISO8601DateFormatter().string(from: Date())
        return BuildInfo(
            version: version,
            build: build,
            git: "unknown",
            date: date,
            kanataVersion: cachedKanataVersion
        )
    }

    /// Fetch and cache the Kanata version from the installed binary.
    /// Call this once at app startup to populate the cached version.
    static func fetchKanataVersion() async {
        guard !kanataVersionFetched else { return }
        kanataVersionFetched = true

        // Try system install path first, then bundled
        let paths = [
            WizardSystemPaths.kanataSystemInstallPath,
            WizardSystemPaths.bundledKanataPath
        ]

        for path in paths {
            guard FileManager.default.fileExists(atPath: path) else { continue }

            do {
                let result = try await SubprocessRunner.shared.run(
                    path,
                    args: ["--version"],
                    timeout: 5
                )

                let output = result.stdout.trimmingCharacters(in: .whitespacesAndNewlines)
                if !output.isEmpty {
                    // Parse "kanata 1.10.0" to just "1.10.0"
                    let version = output
                        .replacingOccurrences(of: "kanata ", with: "")
                        .trimmingCharacters(in: .whitespacesAndNewlines)
                    cachedKanataVersion = version
                    AppLogger.shared.log("üì¶ [BuildInfo] Kanata version: \(version) (from \(path))")
                    return
                }
            } catch {
                AppLogger.shared.debug("‚ö†Ô∏è [BuildInfo] Failed to get Kanata version from \(path): \(error)")
            }
        }

        AppLogger.shared.debug("‚ö†Ô∏è [BuildInfo] Could not determine Kanata version")
    }

    /// Get the cached Kanata version (nil if not yet fetched or unavailable)
    static var kanataVersionCached: String? {
        cachedKanataVersion
    }
}
