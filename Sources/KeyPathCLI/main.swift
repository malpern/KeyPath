import Foundation

// Simple, dependency-free CLI for KeyPath
// Commands:
//   keypath map --from caps --to esc [--append] [--no-reload]
//   keypath list
//   keypath reload

// MARK: - Models

struct Mapping: Equatable {
    let input: String
    let output: String
}

// MARK: - Paths

func configDirectory() -> String {
    let home = FileManager.default.homeDirectoryForCurrentUser.path
    return "\(home)/.config/keypath"
}

func configPath() -> String { "\(configDirectory())/keypath.kbd" }

// MARK: - I/O

@discardableResult
func ensureConfigDirectory() throws -> String {
    let dir = configDirectory()
    try FileManager.default.createDirectory(atPath: dir, withIntermediateDirectories: true, attributes: [.posixPermissions: 0o755])
    return dir
}

func writeConfig(_ mappings: [Mapping]) throws {
    let content = generateKanataConfig(mappings)
    try ensureConfigDirectory()
    try content.write(toFile: configPath(), atomically: true, encoding: .utf8)
}

func readConfig() -> String? {
    try? String(contentsOfFile: configPath(), encoding: .utf8)
}

// MARK: - Kanata config generation (compatible with app formats)

func normInput(_ s: String) -> String {
    switch s.lowercased() {
    case "escape", "esc": return "esc"
    case "space", "spacebar": return "spc"
    case "return", "enter": return "ret"
    case "caps", "capslock": return "caps"
    case "control", "ctrl": return "lctl"
    case "command", "cmd", "meta": return "lmet"
    default: return s.lowercased()
    }
}

func normOutput(_ s: String) -> String {
    // Allow simple chords like "cmd+c" and map to Kanata-style tokens when trivial
    let v = s.lowercased()
    if v.contains("+") { return v.replacingOccurrences(of: "cmd", with: "C").replacingOccurrences(of: "ctrl", with: "T").replacingOccurrences(of: "alt", with: "A").replacingOccurrences(of: "opt", with: "A").replacingOccurrences(of: "shift", with: "S") }
    return normInput(v)
}

func generateKanataConfig(_ mappings: [Mapping]) -> String {
    if mappings.isEmpty {
        return """
        ;; Generated by KeyPath CLI
        ;; No key mappings configured

        (defcfg
          process-unmapped-keys yes
        )

        (defsrc)
        (deflayer base)
        """
    }

    let src = mappings.map { normInput($0.input) }.joined(separator: " ")
    let dst = mappings.map { normOutput($0.output) }.joined(separator: " ")
    return """
    ;; Generated by KeyPath CLI
    ;; \(mappings.count) key mapping(s)

    (defcfg
      process-unmapped-keys yes
    )

    (defsrc
      \(src)
    )

    (deflayer base
      \(dst)
    )
    """
}

// MARK: - Parse existing config (best effort for our generated format)

func parseMappings(from content: String) -> [Mapping]? {
    // Expect our generated structure; if not, return nil
    func tokens(after keyword: String) -> [String]? {
        guard let range = content.range(of: "(\(keyword)") else { return nil }
        let rest = content[range.lowerBound...]
        guard let end = rest.firstIndex(of: ")") else { return nil }
        let newlineStart = rest.range(of: "\n")?.lowerBound ?? rest.startIndex
        let between = rest[newlineStart ..< end]
        let toks = between
            .replacingOccurrences(of: "\n", with: " ")
            .split(separator: " ")
            .map { String($0).trimmingCharacters(in: .whitespaces) }
            .filter { !$0.isEmpty }
        return toks
    }
    guard let src = tokens(after: "defsrc"), let dst = tokens(after: "deflayer base") else { return nil }
    guard src.count == dst.count else { return nil }
    return zip(src, dst).map { Mapping(input: String($0), output: String($1)) }
}

// MARK: - Reload (best effort)

@discardableResult
func tryRestartService() -> Int32 {
    let task = Process()
    task.launchPath = "/bin/launchctl"
    task.arguments = ["kickstart", "-k", "system/com.keypath.kanata"]
    let pipe = Pipe()
    task.standardError = pipe
    task.standardOutput = pipe
    do { try task.run(); task.waitUntilExit(); return task.terminationStatus } catch { return 127 }
}

// MARK: - CLI

enum Command: String { case help, map, list, reload }

func printHelp() {
    let p = configPath()
    print(
        """
        keypath â€” one-shot KeyPath CLI

        Usage:
          keypath map --from <key> --to <key|chord> [--append] [--no-reload]
          keypath list
          keypath reload

        Examples:
          keypath map --from caps --to esc --append
          keypath map --from caps --to cmd+c
          keypath list

        Notes:
          - Config path: \(p)
          - Reload uses 'launchctl kickstart -k system/com.keypath.kanata' (may require sudo).
        """
    )
}

func main() {
    let args = Array(CommandLine.arguments.dropFirst())
    guard let cmdRaw = args.first, let cmd = Command(rawValue: cmdRaw) else {
        printHelp(); return
    }
    switch cmd {
    case .help:
        printHelp()
    case .list:
        let raw = readConfig()
        guard let content = raw, let maps = parseMappings(from: content) else {
            let p = configPath()
            if FileManager.default.fileExists(atPath: p) { print("No parsable mappings found. Showing raw file:\n\n\(raw ?? "(empty)")") }
            else { print("No config found at \(p)") }
            return
        }
        for m in maps { print("\(m.input) -> \(m.output)") }
    case .map:
        var fromKey: String?
        var toKey: String?
        var append = false
        var reload = true
        var i = 1
        while i < args.count {
            let a = args[i]
            switch a {
            case "--from": i += 1; if i < args.count { fromKey = args[i] }
            case "--to": i += 1; if i < args.count { toKey = args[i] }
            case "--append": append = true
            case "--no-reload": reload = false
            default: break
            }
            i += 1
        }
        guard let f = fromKey, let t = toKey else { print("Missing --from or --to\n"); printHelp(); return }

        let new = Mapping(input: f, output: t)
        if append, let content = readConfig(), let existing = parseMappings(from: content) {
            var merged = existing
            // Replace mapping if same input exists
            if let idx = merged.firstIndex(where: { normInput($0.input) == normInput(new.input) }) {
                merged[idx] = new
            } else {
                merged.append(new)
            }
            try? writeConfig(merged)
        } else {
            try? writeConfig([new])
        }
        print("âœ… Wrote configuration at \(configPath())")
        if reload {
            let status = tryRestartService()
            if status == 0 { print("ðŸ”„ Reload: launchctl kickstart succeeded") }
            else { print("âš ï¸ Reload failed (exit \(status)). Try: sudo launchctl kickstart -k system/com.keypath.kanata") }
        }
    case .reload:
        let status = tryRestartService()
        if status == 0 { print("ðŸ”„ Reload: launchctl kickstart succeeded") }
        else { print("âš ï¸ Reload failed (exit \(status)). Try: sudo launchctl kickstart -k system/com.keypath.kanata") }
    }
}

main()
