import Foundation
import AppKit
import Network

// Simple, dependency-free CLI for KeyPath
// Commands:
//   keypath map --from caps --to esc [--append] [--no-reload]
//   keypath list
//   keypath reload

// MARK: - Models

struct Mapping: Equatable {
    let input: String
    let output: String
}

// MARK: - Paths

func configDirectory() -> String {
    let home = FileManager.default.homeDirectoryForCurrentUser.path
    return "\(home)/.config/keypath"
}

func configPath() -> String { "\(configDirectory())/keypath.kbd" }

// MARK: - I/O

@discardableResult
func ensureConfigDirectory() throws -> String {
    let dir = configDirectory()
    try FileManager.default.createDirectory(atPath: dir, withIntermediateDirectories: true, attributes: [.posixPermissions: 0o755])
    return dir
}

func writeConfig(_ mappings: [Mapping]) throws {
    let content = generateKanataConfig(mappings)
    try ensureConfigDirectory()
    try content.write(toFile: configPath(), atomically: true, encoding: .utf8)
}

func readConfig() -> String? {
    try? String(contentsOfFile: configPath(), encoding: .utf8)
}

// MARK: - Kanata config generation (compatible with app formats)

func normInput(_ s: String) -> String {
    switch s.lowercased() {
    case "escape", "esc": return "esc"
    case "space", "spacebar": return "spc"
    case "return", "enter": return "ret"
    case "caps", "capslock": return "caps"
    case "control", "ctrl": return "lctl"
    case "command", "cmd", "meta": return "lmet"
    default: return s.lowercased()
    }
}

func normOutput(_ s: String) -> String {
    // Allow simple chords like "cmd+c" and map to Kanata-style tokens when trivial
    let v = s.lowercased()
    if v.contains("+") { return v.replacingOccurrences(of: "cmd", with: "C").replacingOccurrences(of: "ctrl", with: "T").replacingOccurrences(of: "alt", with: "A").replacingOccurrences(of: "opt", with: "A").replacingOccurrences(of: "shift", with: "S") }
    return normInput(v)
}

func generateKanataConfig(_ mappings: [Mapping]) -> String {
    if mappings.isEmpty {
        return """
        ;; Generated by KeyPath CLI
        ;; No key mappings configured

        (defcfg
          process-unmapped-keys yes
        )

        (defsrc)
        (deflayer base)
        """
    }

    let src = mappings.map { normInput($0.input) }.joined(separator: " ")
    let dst = mappings.map { normOutput($0.output) }.joined(separator: " ")
    return """
    ;; Generated by KeyPath CLI
    ;; \(mappings.count) key mapping(s)

    (defcfg
      process-unmapped-keys yes
    )

    (defsrc
      \(src)
    )

    (deflayer base
      \(dst)
    )
    """
}

// MARK: - Parse existing config (best effort for our generated format)

func parseMappings(from content: String) -> [Mapping]? {
    // Expect our generated structure; if not, return nil
    func tokens(after keyword: String) -> [String]? {
        guard let range = content.range(of: "(\(keyword)") else { return nil }
        let rest = content[range.lowerBound...]
        guard let end = rest.firstIndex(of: ")") else { return nil }
        let newlineStart = rest.range(of: "\n")?.lowerBound ?? rest.startIndex
        let between = rest[newlineStart ..< end]
        let toks = between
            .replacingOccurrences(of: "\n", with: " ")
            .split(separator: " ")
            .map { String($0).trimmingCharacters(in: .whitespaces) }
            .filter { !$0.isEmpty }
        return toks
    }
    guard let src = tokens(after: "defsrc"), let dst = tokens(after: "deflayer base") else { return nil }
    guard src.count == dst.count else { return nil }
    return zip(src, dst).map { Mapping(input: String($0), output: String($1)) }
}

// MARK: - Reload (best effort)

@discardableResult
func tryRestartService() -> Int32 {
    let task = Process()
    task.launchPath = "/bin/launchctl"
    task.arguments = ["kickstart", "-k", "system/com.keypath.kanata"]
    let pipe = Pipe()
    task.standardError = pipe
    task.standardOutput = pipe
    do { try task.run(); task.waitUntilExit(); return task.terminationStatus } catch { return 127 }
}

// MARK: - Sounds (match GUI semantics)

func playTink() { NSSound(named: "Tink")?.play() }
func playGlass() { NSSound(named: "Glass")?.play() }
func playErrorBeep() { NSSound.beep() }

// MARK: - TCP live reload (like GUI)

struct CommPrefs {
    let enabled: Bool
    let port: Int
}

func readCommPrefs() -> CommPrefs {
    let enabled = UserDefaults.standard.object(forKey: "KeyPath.TCP.ServerEnabled") as? Bool ?? true
    let port = UserDefaults.standard.object(forKey: "KeyPath.TCP.ServerPort") as? Int ?? 37001
    return CommPrefs(enabled: enabled, port: port)
}

/// Send {"Reload":{}} over TCP and wait for a newline-terminated ServerResponse
func reloadViaTCP(timeout seconds: TimeInterval = 3.0) async -> Bool {
    let prefs = readCommPrefs()
    guard prefs.enabled && (1024...65535).contains(prefs.port) else { return false }

    let connection = NWConnection(host: "127.0.0.1", port: NWEndpoint.Port(integerLiteral: UInt16(prefs.port)), using: .tcp)
    connection.start(queue: DispatchQueue.global())

    // Wait for ready or failure
    do {
        try await withThrowingTaskGroup(of: Void.self) { group in
            group.addTask {
                try await withCheckedThrowingContinuation { (cont: CheckedContinuation<Void, Error>) in
                    connection.stateUpdateHandler = { state in
                        switch state {
                        case .ready: cont.resume()
                        case .failed(let err): cont.resume(throwing: err)
                        case .cancelled: cont.resume(throwing: NSError(domain: "cli", code: -1))
                        default: break
                        }
                    }
                }
            }
            group.addTask { try await Task.sleep(nanoseconds: UInt64(seconds * 1_000_000_000)); throw NSError(domain: "cli.timeout", code: 1) }
            try await group.next()
            group.cancelAll()
        }
    } catch {
        connection.cancel(); return false
    }

    // Send JSON line {"Reload":{}}\n
    let payload = "{\"Reload\":{}}\n".data(using: .utf8)!
    do {
        try await withCheckedThrowingContinuation { (cont: CheckedContinuation<Void, Error>) in
            connection.send(content: payload, completion: .contentProcessed { err in
                if let err { cont.resume(throwing: err) } else { cont.resume() }
            })
        }
    } catch {
        connection.cancel(); return false
    }

    // Read lines until we get a JSON with status Ok/Error or timeout
    var buffer = Data()
    let deadline = Date().addingTimeInterval(seconds)
    while Date() < deadline {
        do {
            let chunk: Data? = try await withCheckedThrowingContinuation { (cont: CheckedContinuation<Data?, Error>) in
                connection.receive(minimumIncompleteLength: 1, maximumLength: 4096) { data, _, isComplete, err in
                    if let err { cont.resume(throwing: err); return }
                    if isComplete { cont.resume(returning: nil); return }
                    cont.resume(returning: data)
                }
            }
            if let data = chunk, !data.isEmpty { buffer.append(data) } else { break }

            // Extract complete lines
            while let nl = buffer.firstIndex(of: 0x0A) { // \n
                let line = buffer[0..<nl]
                buffer.removeSubrange(0...nl)
                if let json = try? JSONSerialization.jsonObject(with: Data(line)) as? [String: Any],
                   let status = json["status"] as? String {
                    connection.cancel()
                    if status == "Ok" { return true } else { return false }
                }
            }
        } catch {
            connection.cancel(); return false
        }
    }
    connection.cancel()
    return false
}

// MARK: - CLI

enum Command: String { case help, map, list, reload }

func printHelp() {
    let p = configPath()
    print(
        """
        keypath — one-shot KeyPath CLI

        Usage:
          keypath map --from <key> --to <key|chord> [--append] [--no-reload]
          keypath list
          keypath reload

        Examples:
          keypath map --from caps --to esc --append
          keypath map --from caps --to cmd+c
          keypath list

        Notes:
          - Config path: \(p)
          - Reload uses 'launchctl kickstart -k system/com.keypath.kanata' (may require sudo).
        """
    )
}

func main() {
    let args = Array(CommandLine.arguments.dropFirst())
    guard let cmdRaw = args.first, let cmd = Command(rawValue: cmdRaw) else {
        printHelp(); return
    }
    switch cmd {
    case .help:
        printHelp()
    case .list:
        let raw = readConfig()
        guard let content = raw, let maps = parseMappings(from: content) else {
            let p = configPath()
            if FileManager.default.fileExists(atPath: p) { print("No parsable mappings found. Showing raw file:\n\n\(raw ?? "(empty)")") }
            else { print("No config found at \(p)") }
            return
        }
        for m in maps { print("\(m.input) -> \(m.output)") }
    case .map:
        var fromKey: String?
        var toKey: String?
        var append = false
        var reload = true
        var i = 1
        while i < args.count {
            let a = args[i]
            switch a {
            case "--from": i += 1; if i < args.count { fromKey = args[i] }
            case "--to": i += 1; if i < args.count { toKey = args[i] }
            case "--append": append = true
            case "--no-reload": reload = false
            default: break
            }
            i += 1
        }
        guard let f = fromKey, let t = toKey else { print("Missing --from or --to\n"); printHelp(); return }

        let new = Mapping(input: f, output: t)
        if append, let content = readConfig(), let existing = parseMappings(from: content) {
            var merged = existing
            // Replace mapping if same input exists
            if let idx = merged.firstIndex(where: { normInput($0.input) == normInput(new.input) }) {
                merged[idx] = new
            } else {
                merged.append(new)
            }
            try? writeConfig(merged)
        } else {
            try? writeConfig([new])
        }
        print("✅ Wrote configuration at \(configPath())")
        // Match GUI: play tink on save
        playTink()
        if reload {
            // Try live reload over TCP first, fallback to launchctl
            Task {
                if await reloadViaTCP() {
                    print("🔄 Reload: TCP reload succeeded")
                    playGlass()
                } else {
                    let status = tryRestartService()
                    if status == 0 { print("🔄 Reload: launchctl kickstart succeeded") ; playGlass() }
                    else { print("⚠️ Reload failed (exit \(status)). Try: sudo launchctl kickstart -k system/com.keypath.kanata"); playErrorBeep() }
                }
                exit(0)
            }
            RunLoop.main.run()
        }
    case .reload:
        Task {
            if await reloadViaTCP() {
                print("🔄 Reload: TCP reload succeeded")
                playGlass()
            } else {
                let status = tryRestartService()
                if status == 0 { print("🔄 Reload: launchctl kickstart succeeded"); playGlass() }
                else { print("⚠️ Reload failed (exit \(status)). Try: sudo launchctl kickstart -k system/com.keypath.kanata"); playErrorBeep() }
            }
            exit(0)
        }
        RunLoop.main.run()
    }
}

main()
