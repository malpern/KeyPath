import Foundation
import Network

// Simple, dependency-free CLI for KeyPath
// Commands:
//   keypath map --from caps --to esc [--append] [--no-reload]
//   keypath list
//   keypath reload

// MARK: - Models

struct Mapping: Equatable {
    let input: String
    let output: String
}

// MARK: - Paths

func configDirectory() -> String {
    let home = FileManager.default.homeDirectoryForCurrentUser.path
    return "\(home)/.config/keypath"
}

func configPath() -> String { "\(configDirectory())/keypath.kbd" }

// MARK: - I/O

@discardableResult
func ensureConfigDirectory() throws -> String {
    let dir = configDirectory()
    try FileManager.default.createDirectory(atPath: dir, withIntermediateDirectories: true, attributes: [.posixPermissions: 0o755])
    return dir
}

func writeConfig(_ mappings: [Mapping]) throws {
    let content = generateKanataConfig(mappings)
    try ensureConfigDirectory()
    try content.write(toFile: configPath(), atomically: true, encoding: .utf8)
}

func readConfig() -> String? {
    try? String(contentsOfFile: configPath(), encoding: .utf8)
}

// MARK: - Kanata config generation (compatible with app formats)

func normInput(_ s: String) -> String {
    switch s.lowercased() {
    case "escape", "esc": return "esc"
    case "space", "spacebar": return "spc"
    case "return", "enter": return "ret"
    case "caps", "capslock": return "caps"
    case "control", "ctrl": return "lctl"
    case "command", "cmd", "meta": return "lmet"
    default: return s.lowercased()
    }
}

func normOutput(_ s: String) -> String {
    // Allow simple chords like "cmd+c" and map to Kanata-style tokens when trivial
    let v = s.lowercased()
    if v.contains("+") { return v.replacingOccurrences(of: "cmd", with: "C").replacingOccurrences(of: "ctrl", with: "T").replacingOccurrences(of: "alt", with: "A").replacingOccurrences(of: "opt", with: "A").replacingOccurrences(of: "shift", with: "S") }
    return normInput(v)
}

func generateKanataConfig(_ mappings: [Mapping]) -> String {
    if mappings.isEmpty {
        return """
        ;; Generated by KeyPath CLI
        ;; No key mappings configured

        (defcfg
          process-unmapped-keys yes
        )

        (defsrc)
        (deflayer base)
        """
    }

    let src = mappings.map { normInput($0.input) }.joined(separator: " ")
    let dst = mappings.map { normOutput($0.output) }.joined(separator: " ")
    return """
    ;; Generated by KeyPath CLI
    ;; \(mappings.count) key mapping(s)

    (defcfg
      process-unmapped-keys yes
    )

    (defsrc
      \(src)
    )

    (deflayer base
      \(dst)
    )
    """
}

// MARK: - Parse existing config (best effort for our generated format)

func parseMappings(from content: String) -> [Mapping]? {
    // Expect our generated structure; if not, return nil
    func tokens(after keyword: String) -> [String]? {
        guard let range = content.range(of: "(\(keyword)") else { return nil }
        let rest = content[range.lowerBound...]
        guard let end = rest.firstIndex(of: ")") else { return nil }
        let newlineStart = rest.range(of: "\n")?.lowerBound ?? rest.startIndex
        let between = rest[newlineStart ..< end]
        let toks = between
            .replacingOccurrences(of: "\n", with: " ")
            .split(separator: " ")
            .map { String($0).trimmingCharacters(in: .whitespaces) }
            .filter { !$0.isEmpty }
        return toks
    }
    guard let src = tokens(after: "defsrc"), let dst = tokens(after: "deflayer base") else { return nil }
    guard src.count == dst.count else { return nil }
    return zip(src, dst).map { Mapping(input: String($0), output: String($1)) }
}

// MARK: - Reload (best effort)

@discardableResult
func tryRestartService() -> Int32 {
    let task = Process()
    task.launchPath = "/bin/launchctl"
    task.arguments = ["kickstart", "-k", "system/com.keypath.kanata"]
    let pipe = Pipe()
    task.standardError = pipe
    task.standardOutput = pipe
    do { try task.run(); task.waitUntilExit(); return task.terminationStatus } catch { return 127 }
}

// MARK: - Sounds (match GUI semantics) via afplay (no AppKit dependency)

@discardableResult
func playSystemSound(_ name: String) -> Bool {
    let soundPath = "/System/Library/Sounds/\(name).aiff"
    let proc = Process()
    proc.launchPath = "/usr/bin/afplay"
    proc.arguments = [soundPath]
    do { try proc.run(); return true } catch { return false }
}

func beepFallback() {
    let p = Process()
    p.launchPath = "/usr/bin/osascript"
    p.arguments = ["-e", "beep"]
    try? p.run()
}

func playTink() { if !playSystemSound("Tink") { beepFallback() } }
func playGlass() { if !playSystemSound("Glass") { beepFallback() } }
func playErrorBeep() { if !playSystemSound("Basso") { beepFallback() } }

// MARK: - TCP live reload (like GUI)

struct CommPrefs {
    let enabled: Bool
    let port: Int
}

func readCommPrefs() -> CommPrefs {
    let enabled = UserDefaults.standard.object(forKey: "KeyPath.TCP.ServerEnabled") as? Bool ?? true
    let port = UserDefaults.standard.object(forKey: "KeyPath.TCP.ServerPort") as? Int ?? 37001
    return CommPrefs(enabled: enabled, port: port)
}

/// Send {"Reload":{}} over TCP and wait for a newline-terminated ServerResponse
func reloadViaTCP(timeout seconds: TimeInterval = 3.0) async -> Bool {
    let prefs = readCommPrefs()
    guard prefs.enabled && (1024...65535).contains(prefs.port) else { return false }

    // Use nc for a simple TCP round-trip to avoid concurrency pitfalls
    // printf '{"Reload":{}}\n' | nc -w <sec> 127.0.0.1 <port>
    let cmd = "/bin/sh"
    let json = "{\\\"Reload\\\":{}}\\n"
    let arg = "-lc"
    let pipeline = "printf '" + json + "' | nc -w \(Int(ceil(seconds))) 127.0.0.1 \(prefs.port)"

    let p = Process()
    p.launchPath = cmd
    p.arguments = [arg, pipeline]
    let out = Pipe()
    let err = Pipe()
    p.standardOutput = out
    p.standardError = err
    do { try p.run() } catch { return false }
    p.waitUntilExit()
    let data = out.fileHandleForReading.readDataToEndOfFile()
    if let s = String(data: data, encoding: .utf8) {
        for line in s.split(separator: "\n") {
            if let json = try? JSONSerialization.jsonObject(with: Data(line.utf8)) as? [String: Any],
               let status = json["status"] as? String, status == "Ok" {
                return true
            }
            if line.contains("Ok") { return true }
        }
    }
    return false
}

// MARK: - CLI

enum Command: String { case help, map, list, reload, reset }

func printHelp() {
    let p = configPath()
        print(
            """
            keypath â€” one-shot KeyPath CLI

            Usage:
              keypath map --from <key> --to <key|chord> [--append] [--no-reload]
              keypath list
              keypath reload
              keypath reset [--empty] [--no-reload]

            Examples:
              keypath map --from caps --to esc --append
              keypath map --from caps --to cmd+c
              keypath list
              keypath reset            # default config (Caps â†’ Esc)
              keypath reset --empty    # no mappings

            Notes:
              - Config path: \(p)
              - Reload uses 'launchctl kickstart -k system/com.keypath.kanata' (may require sudo).
            """
        )
}

func main() {
    let args = Array(CommandLine.arguments.dropFirst())
    
    // Check for help flags
    if args.isEmpty || args.contains("-help") || args.contains("--help") || args.contains("-h") {
        printHelp()
        return
    }
    
    guard let cmdRaw = args.first, let cmd = Command(rawValue: cmdRaw) else {
        printHelp(); return
    }
    switch cmd {
    case .help:
        printHelp()
    case .list:
        let raw = readConfig()
        guard let content = raw, let maps = parseMappings(from: content) else {
            let p = configPath()
            if FileManager.default.fileExists(atPath: p) { print("No parsable mappings found. Showing raw file:\n\n\(raw ?? "(empty)")") }
            else { print("No config found at \(p)") }
            return
        }
        for m in maps { print("\(m.input) -> \(m.output)") }
    case .map:
        var fromKey: String?
        var toKey: String?
        var append = false
        var reload = true
        var i = 1
        while i < args.count {
            let a = args[i]
            switch a {
            case "--from": i += 1; if i < args.count { fromKey = args[i] }
            case "--to": i += 1; if i < args.count { toKey = args[i] }
            case "--append": append = true
            case "--no-reload": reload = false
            default: break
            }
            i += 1
        }
        guard let f = fromKey, let t = toKey else { print("Missing --from or --to\n"); printHelp(); return }

        let new = Mapping(input: f, output: t)
        if append, let content = readConfig(), let existing = parseMappings(from: content) {
            var merged = existing
            // Replace mapping if same input exists
            if let idx = merged.firstIndex(where: { normInput($0.input) == normInput(new.input) }) {
                merged[idx] = new
            } else {
                merged.append(new)
            }
            try? writeConfig(merged)
        } else {
            try? writeConfig([new])
        }
        print("âœ… Wrote configuration at \(configPath())")
        // Match GUI: play tink on save
        playTink()
        if reload {
            // Try live reload over TCP first, fallback to launchctl
            Task {
                if await reloadViaTCP() {
                    print("ðŸ”„ Reload: TCP reload succeeded")
                    playGlass()
                } else {
                    let status = tryRestartService()
                    if status == 0 { print("ðŸ”„ Reload: launchctl kickstart succeeded") ; playGlass() }
                    else { print("âš ï¸ Reload failed (exit \(status)). Try: sudo launchctl kickstart -k system/com.keypath.kanata"); playErrorBeep() }
                }
                exit(0)
            }
            RunLoop.main.run()
        }
    case .reload:
        Task {
            if await reloadViaTCP() {
                print("ðŸ”„ Reload: TCP reload succeeded")
                playGlass()
            } else {
                let status = tryRestartService()
                if status == 0 { print("ðŸ”„ Reload: launchctl kickstart succeeded"); playGlass() }
                else { print("âš ï¸ Reload failed (exit \(status)). Try: sudo launchctl kickstart -k system/com.keypath.kanata"); playErrorBeep() }
            }
            exit(0)
        }
        RunLoop.main.run()
    case .reset:
        var makeEmpty = false
        var reload = true
        var i = 1
        while i < args.count {
            let a = args[i]
            switch a {
            case "--empty": makeEmpty = true
            case "--no-reload": reload = false
            default: break
            }
            i += 1
        }

        // Backup existing config (best effort)
        let cfg = configPath()
        if FileManager.default.fileExists(atPath: cfg) {
            let ts = Int(Date().timeIntervalSince1970)
            let bak = cfg + ".bak." + String(ts)
            _ = try? FileManager.default.copyItem(atPath: cfg, toPath: bak)
            print("ðŸ—‚ï¸  Backed up existing config to \(bak)")
        }

        // Write default or empty
        if makeEmpty {
            try? writeConfig([])
            print("âœ… Wrote empty configuration at \(cfg)")
        } else {
            try? writeConfig([Mapping(input: "caps", output: "esc")])
            print("âœ… Wrote default configuration (caps â†’ esc) at \(cfg)")
        }
        playTink()

        if reload {
            Task {
                if await reloadViaTCP() {
                    print("ðŸ”„ Reload: TCP reload succeeded")
                    playGlass()
                } else {
                    let status = tryRestartService()
                    if status == 0 { print("ðŸ”„ Reload: launchctl kickstart succeeded"); playGlass() }
                    else { print("âš ï¸ Reload failed (exit \(status)). Try: sudo launchctl kickstart -k system/com.keypath.kanata"); playErrorBeep() }
                }
                exit(0)
            }
            RunLoop.main.run()
        }
    }
}

main()
