import Foundation
import Observation

/// Communication protocol options for Kanata integration
enum CommunicationProtocol: String, CaseIterable {
    case udp

    var displayName: String {
        return "UDP (High Performance)"
    }

    var description: String {
        return "High-performance UDP protocol with ~10x lower latency and token-based security"
    }
}

/// Manages KeyPath application preferences and settings
@MainActor
@Observable
final class PreferencesService {
    // MARK: - Shared instance (backward compatible)

    static let shared = PreferencesService()

    // MARK: - Communication Protocol Configuration

    /// Communication protocol preference
    var communicationProtocol: CommunicationProtocol {
        didSet {
            UserDefaults.standard.set(communicationProtocol.rawValue, forKey: Keys.communicationProtocol)
            AppLogger.shared.log("üîß [PreferencesService] Communication protocol: \(communicationProtocol.rawValue)")
        }
    }

    // MARK: - UDP Server Configuration

    /// Whether UDP server should be enabled for low-latency communication
    var udpServerEnabled: Bool {
        didSet {
            UserDefaults.standard.set(udpServerEnabled, forKey: Keys.udpServerEnabled)
            AppLogger.shared.log("üîß [PreferencesService] UDP server enabled: \(udpServerEnabled)")
        }
    }

    /// UDP server port for Kanata communication
    var udpServerPort: Int {
        didSet {
            // Validate port range and revert if invalid
            if !isValidPort(udpServerPort) {
                AppLogger.shared.log(
                    "‚ùå [PreferencesService] Invalid UDP port \(udpServerPort), reverting to \(oldValue)")
                udpServerPort = oldValue
            } else {
                UserDefaults.standard.set(udpServerPort, forKey: Keys.udpServerPort)
                AppLogger.shared.log("üîß [PreferencesService] UDP server port: \(udpServerPort)")
            }
        }
    }

    /// Authentication token for UDP server (managed by UDPAuthTokenManager)
    /// If empty, will be auto-generated by Kanata and logged to console
    var udpAuthToken: String {
        get {
            // Read directly from shared file (single source of truth)
            let token = CommunicationSnapshot.readSharedUDPToken() ?? ""
            AppLogger.shared.log("üîß [PreferencesService] Reading UDP token from shared file: \(token.isEmpty ? "EMPTY" : "[REDACTED]")")
            return token
        }
        set {
            // Write directly to shared file (single source of truth)
            if newValue.isEmpty {
                // Clear token - remove file
                let tokenPath = CommunicationSnapshot.udpAuthTokenPath()
                try? FileManager.default.removeItem(atPath: tokenPath)
                AppLogger.shared.log("üîß [PreferencesService] UDP auth token cleared")
            } else {
                // Set token - write to shared file
                let success = CommunicationSnapshot.writeSharedUDPToken(newValue)
                if success {
                    AppLogger.shared.log("üîß [PreferencesService] UDP auth token updated in shared file")
                } else {
                    AppLogger.shared.log("‚ùå [PreferencesService] Failed to write token to shared file")
                }
            }
            // Remove legacy UserDefaults for security
            UserDefaults.standard.removeObject(forKey: Keys.udpAuthToken)
        }
    }

    /// Session timeout for UDP authentication in seconds
    var udpSessionTimeout: Int {
        didSet {
            if udpSessionTimeout < 300 || udpSessionTimeout > 86400 { // 5 minutes to 24 hours
                AppLogger.shared.log(
                    "‚ùå [PreferencesService] Invalid UDP session timeout \(udpSessionTimeout), reverting to \(oldValue)")
                udpSessionTimeout = oldValue
            } else {
                UserDefaults.standard.set(udpSessionTimeout, forKey: Keys.udpSessionTimeout)
                AppLogger.shared.log("üîß [PreferencesService] UDP session timeout: \(udpSessionTimeout) seconds")
            }
        }
    }

    // MARK: - Keys

    private enum Keys {
        static let communicationProtocol = "KeyPath.Communication.Protocol"
        static let udpServerEnabled = "KeyPath.UDP.ServerEnabled"
        static let udpServerPort = "KeyPath.UDP.ServerPort"
        static let udpAuthToken = "KeyPath.UDP.AuthToken"
        static let udpSessionTimeout = "KeyPath.UDP.SessionTimeout"
    }

    // MARK: - Defaults

    private enum Defaults {
        static let communicationProtocol = CommunicationProtocol.udp // UDP-only for high performance
        static let udpServerEnabled = true // Enable UDP by default
        static let udpServerPort = 37001 // Default port for Kanata UDP server
        static let udpAuthToken = "" // Auto-generate token
        static let udpSessionTimeout = 1800 // 30 minutes (same as Kanata default)
    }

    // MARK: - Initialization

    init() {
        // Load stored preferences or use defaults
        let protocolString = UserDefaults.standard.string(forKey: Keys.communicationProtocol) ?? Defaults.communicationProtocol.rawValue
        communicationProtocol = CommunicationProtocol(rawValue: protocolString) ?? Defaults.communicationProtocol

        udpServerEnabled =
            UserDefaults.standard.object(forKey: Keys.udpServerEnabled) as? Bool
                ?? Defaults.udpServerEnabled
        udpServerPort =
            UserDefaults.standard.object(forKey: Keys.udpServerPort) as? Int ?? Defaults.udpServerPort

        udpSessionTimeout =
            UserDefaults.standard.object(forKey: Keys.udpSessionTimeout) as? Int ?? Defaults.udpSessionTimeout

        AppLogger.shared.log(
            "üîß [PreferencesService] Initialized - Protocol: \(communicationProtocol.rawValue), UDP enabled: \(udpServerEnabled)"
        )

        // Handle legacy UserDefaults migration
        let legacyToken = UserDefaults.standard.string(forKey: Keys.udpAuthToken)
        if let legacyToken = legacyToken, !legacyToken.isEmpty {
            // Migrate to shared file
            let success = CommunicationSnapshot.writeSharedUDPToken(legacyToken)
            if success {
                UserDefaults.standard.removeObject(forKey: Keys.udpAuthToken)
                AppLogger.shared.log("üîÑ [PreferencesService] Migrated legacy UDP token to shared file")
            } else {
                AppLogger.shared.log("‚ö†Ô∏è [PreferencesService] Failed to migrate legacy token to shared file")
            }
        }
    }

    // MARK: - Public Interface

    /// Reset all communication settings to defaults
    func resetCommunicationSettings() {
        communicationProtocol = Defaults.communicationProtocol
        udpServerEnabled = Defaults.udpServerEnabled
        udpServerPort = Defaults.udpServerPort
        udpAuthToken = Defaults.udpAuthToken
        udpSessionTimeout = Defaults.udpSessionTimeout
        AppLogger.shared.log("üîß [PreferencesService] All communication settings reset to defaults")
    }

    /// Reset UDP settings to defaults
    func resetUDPSettings() {
        udpServerEnabled = Defaults.udpServerEnabled
        udpServerPort = Defaults.udpServerPort
        udpAuthToken = Defaults.udpAuthToken // This will trigger secure deletion
        udpSessionTimeout = Defaults.udpSessionTimeout
        AppLogger.shared.log("üîß [PreferencesService] UDP settings reset to defaults")
    }

    /// Validate port is in acceptable range
    func isValidPort(_ port: Int) -> Bool {
        port >= 1024 && port <= 65535
    }

    /// Get current communication configuration as string for logging
    var communicationConfigDescription: String {
        let tokenStatus = udpAuthToken.isEmpty ? "auto-generated" : "custom"
        return "UDP \(udpServerEnabled ? "enabled" : "disabled") on port \(udpServerPort) (secure token: \(tokenStatus))"
    }
}

// MARK: - Convenience Extensions

extension PreferencesService {
    /// Get the currently preferred communication protocol
    var preferredProtocol: CommunicationProtocol {
        communicationProtocol
    }

    /// Check if UDP should be used for communication
    var shouldUseUDP: Bool {
        communicationProtocol == .udp && udpServerEnabled && isValidPort(udpServerPort)
    }

    /// Get the full UDP endpoint URL if enabled
    var udpEndpoint: String? {
        guard udpServerEnabled else { return nil }
        return "127.0.0.1:\(udpServerPort)"
    }

    /// Check if UDP server should be included in Kanata launch arguments
    var shouldUseUDPServer: Bool {
        shouldUseUDP
    }

    /// Get the active communication endpoint based on protocol preference
    var activeEndpoint: String? {
        return udpEndpoint
    }

    /// Get UDP launch arguments for Kanata if UDP is enabled
    var udpLaunchArguments: [String] {
        guard shouldUseUDP else { return [] }
        // Ensure a token exists before building arguments/env
        _ = CommunicationSnapshot.ensureSharedUDPToken()
        return Self.buildUDPArguments(
            port: udpServerPort,
            sessionTimeout: udpSessionTimeout,
            defaultTimeout: Defaults.udpSessionTimeout
        )
    }

    /// Build UDP launch arguments - token passed via environment variable for security
    nonisolated static func buildUDPArguments(port: Int, sessionTimeout: Int, defaultTimeout: Int) -> [String] {
        var args = ["--udp-port", "\(port)"]

        // Always require auth: ensure token exists and will be provided via env
        let token = CommunicationSnapshot.ensureSharedUDPToken()
        if token.isEmpty {
            AppLogger.shared.log("‚ùå [UDP Launch] Failed to ensure UDP token; refusing to start without auth")
            // Still return args; caller should decide to abort launch if desired
        } else {
            AppLogger.shared.log("üîê [UDP Launch] Auth token ensured; using environment variable")
        }

        if sessionTimeout != defaultTimeout {
            args.append(contentsOf: ["--udp-session-timeout", "\(sessionTimeout)"])
        }

        return args
    }

    /// Get communication launch arguments based on protocol preference
    var communicationLaunchArguments: [String] {
        return udpLaunchArguments
    }

    /// Get environment variables for secure token passing
    var communicationEnvironmentVariables: [String: String] {
        guard shouldUseUDP else { return [:] }

        // Ensure and pass UDP token via environment variable for security
        let token = CommunicationSnapshot.ensureSharedUDPToken()
        if !token.isEmpty {
            return ["KANATA_UDP_TOKEN": token]
        }

        AppLogger.shared.log("‚ùå [PreferencesService] Missing UDP token; not exposing UDP environment")
        return [:]
    }
}

// MARK: - Thread-Safe Snapshot API

/// Thread-safe snapshot of UDP communication configuration for use from non-MainActor contexts
struct CommunicationSnapshot: Sendable {
    let udpEnabled: Bool
    let udpPort: Int
    let udpAuthToken: String
    let udpSessionTimeout: Int

    /// Check if UDP server should be used based on snapshot values
    var shouldUseUDP: Bool {
        udpEnabled && (1024 ... 65535).contains(udpPort)
    }

    /// Get active UDP endpoint
    var activeEndpoint: String? {
        guard shouldUseUDP else { return nil }
        return "127.0.0.1:\(udpPort)"
    }

    /// Get cross-platform path for shared UDP auth token file
    static func udpAuthTokenPath() -> String {
        return UDPAuthTokenManager.shared.sharedTokenPath()
    }

    /// Generate secure 32-character UDP auth token
    static func generateUDPAuthToken() -> String {
        return UDPAuthTokenManager.shared.generateSecureToken()
    }

    /// Write shared UDP auth token to cross-platform file location
    static func writeSharedUDPToken(_ token: String) -> Bool {
        let tokenPath = udpAuthTokenPath()
        let tokenDir = (tokenPath as NSString).deletingLastPathComponent

        do {
            // Create directory if it doesn't exist
            try FileManager.default.createDirectory(
                atPath: tokenDir,
                withIntermediateDirectories: true,
                attributes: [.posixPermissions: 0o700]
            )

            // Write token to file
            try token.write(toFile: tokenPath, atomically: true, encoding: .utf8)

            // Set secure permissions (owner read/write only)
            try FileManager.default.setAttributes(
                [.posixPermissions: 0o600],
                ofItemAtPath: tokenPath
            )

            return true
        } catch {
            AppLogger.shared.log("‚ùå [UDP Auth] Failed to write shared token: \(error)")
            return false
        }
    }

    /// Read shared UDP auth token from cross-platform file location
    static func readSharedUDPToken() -> String? {
        let tokenPath = udpAuthTokenPath()
        do {
            let token = try String(contentsOfFile: tokenPath, encoding: .utf8)
            return token.trimmingCharacters(in: .whitespacesAndNewlines)
        } catch {
            return nil
        }
    }

    /// Ensure shared UDP token exists, generating one if needed
    static func ensureSharedUDPToken() -> String {
        // Try to read existing token
        if let existingToken = readSharedUDPToken(), !existingToken.isEmpty {
            return existingToken
        }

        // Generate new token
        let newToken = generateUDPAuthToken()

        // Write to shared file
        if writeSharedUDPToken(newToken) {
            AppLogger.shared.log("üîê [UDP Auth] Generated new shared token")

            // Also store in Keychain for backup/persistence
            do {
                try KeychainService.shared.storeUDPToken(newToken)
            } catch {
                AppLogger.shared.log("‚ö†Ô∏è [UDP Auth] Failed to backup token in Keychain: \(error)")
            }

            return newToken
        } else {
            AppLogger.shared.log("‚ùå [UDP Auth] Failed to write shared token, using generated token")
            return newToken
        }
    }

    /// Get UDP launch arguments
    var communicationLaunchArguments: [String] {
        guard shouldUseUDP else { return [] }
        _ = CommunicationSnapshot.ensureSharedUDPToken()
        return PreferencesService.buildUDPArguments(
            port: udpPort,
            sessionTimeout: udpSessionTimeout,
            defaultTimeout: 1800
        )
    }

    /// Get environment variables for secure token passing
    var communicationEnvironmentVariables: [String: String] {
        guard shouldUseUDP else { return [:] }
        let token = CommunicationSnapshot.ensureSharedUDPToken()
        if !token.isEmpty {
            return ["KANATA_UDP_TOKEN": token]
        }
        return [:]
    }
}

extension PreferencesService {
    /// Get thread-safe snapshot of UDP communication configuration
    /// Safe to call from any actor context
    nonisolated static func communicationSnapshot() -> CommunicationSnapshot {
        let udpEnabled = UserDefaults.standard.object(forKey: "KeyPath.UDP.ServerEnabled") as? Bool ?? true
        let udpPort = UserDefaults.standard.object(forKey: "KeyPath.UDP.ServerPort") as? Int ?? 37001

        // Load UDP token from shared file (single source of truth)
        let udpAuthToken = CommunicationSnapshot.readSharedUDPToken() ?? ""

        let udpSessionTimeout = UserDefaults.standard.object(forKey: "KeyPath.UDP.SessionTimeout") as? Int ?? 1800

        return CommunicationSnapshot(
            udpEnabled: udpEnabled,
            udpPort: udpPort,
            udpAuthToken: udpAuthToken,
            udpSessionTimeout: udpSessionTimeout
        )
    }

    /// Get communication configuration for external clients
    /// Returns endpoint URL and shared token path for cross-platform integration
    nonisolated static func externalClientConfiguration() -> (endpoint: String?, tokenPath: String) {
        let snapshot = communicationSnapshot()
        let endpoint = snapshot.activeEndpoint
        let tokenPath = CommunicationSnapshot.udpAuthTokenPath()

        return (endpoint: endpoint, tokenPath: tokenPath)
    }
}
