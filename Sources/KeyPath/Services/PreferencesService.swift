import Foundation
import Observation

/// Communication protocol options for Kanata integration
enum CommunicationProtocol: String, CaseIterable {
    case tcp
    case udp

    var displayName: String {
        switch self {
        case .tcp:
            return "TCP (Traditional)"
        case .udp:
            return "UDP (Low Latency)"
        }
    }

    var description: String {
        switch self {
        case .tcp:
            return "Traditional TCP connection with higher latency but guaranteed delivery"
        case .udp:
            return "Modern UDP protocol with ~10x lower latency and token-based security"
        }
    }
}

/// Manages KeyPath application preferences and settings
@MainActor
@Observable
final class PreferencesService {
    // MARK: - Shared instance (backward compatible)

    static let shared = PreferencesService()

    // MARK: - Communication Protocol Configuration

    /// Communication protocol preference
    var communicationProtocol: CommunicationProtocol {
        didSet {
            UserDefaults.standard.set(communicationProtocol.rawValue, forKey: Keys.communicationProtocol)
            AppLogger.shared.log("üîß [PreferencesService] Communication protocol: \(communicationProtocol.rawValue)")
        }
    }

    // MARK: - TCP Server Configuration

    /// Whether TCP server should be enabled for config validation
    var tcpServerEnabled: Bool {
        didSet {
            UserDefaults.standard.set(tcpServerEnabled, forKey: Keys.tcpServerEnabled)
            AppLogger.shared.log("üîß [PreferencesService] TCP server enabled: \(tcpServerEnabled)")
        }
    }

    /// TCP server port for Kanata communication
    var tcpServerPort: Int {
        didSet {
            // Validate port range and revert if invalid
            if !isValidPort(tcpServerPort) {
                AppLogger.shared.log(
                    "‚ùå [PreferencesService] Invalid TCP port \(tcpServerPort), reverting to \(oldValue)")
                tcpServerPort = oldValue
            } else {
                UserDefaults.standard.set(tcpServerPort, forKey: Keys.tcpServerPort)
                AppLogger.shared.log("üîß [PreferencesService] TCP server port: \(tcpServerPort)")
            }
        }
    }

    // MARK: - UDP Server Configuration

    /// Whether UDP server should be enabled for low-latency communication
    var udpServerEnabled: Bool {
        didSet {
            UserDefaults.standard.set(udpServerEnabled, forKey: Keys.udpServerEnabled)
            AppLogger.shared.log("üîß [PreferencesService] UDP server enabled: \(udpServerEnabled)")
        }
    }

    /// UDP server port for Kanata communication
    var udpServerPort: Int {
        didSet {
            // Validate port range and revert if invalid
            if !isValidPort(udpServerPort) {
                AppLogger.shared.log(
                    "‚ùå [PreferencesService] Invalid UDP port \(udpServerPort), reverting to \(oldValue)")
                udpServerPort = oldValue
            } else {
                UserDefaults.standard.set(udpServerPort, forKey: Keys.udpServerPort)
                AppLogger.shared.log("üîß [PreferencesService] UDP server port: \(udpServerPort)")
            }
        }
    }

    /// Authentication token for UDP server (stored securely in Keychain)
    /// If empty, will be auto-generated by Kanata and logged to console
    var udpAuthToken: String {
        didSet {
            // Store token securely in Keychain instead of UserDefaults
            do {
                if udpAuthToken.isEmpty {
                    try KeychainService.shared.deleteUDPToken()
                } else {
                    try KeychainService.shared.storeUDPToken(udpAuthToken)
                }
                // Remove from UserDefaults for security (migration)
                UserDefaults.standard.removeObject(forKey: Keys.udpAuthToken)
                AppLogger.shared.log("üîß [PreferencesService] UDP auth token updated (stored securely)")
            } catch {
                AppLogger.shared.log("‚ùå [PreferencesService] Failed to store UDP token securely: \(error)")
            }
        }
    }

    /// Session timeout for UDP authentication in seconds
    var udpSessionTimeout: Int {
        didSet {
            if udpSessionTimeout < 300 || udpSessionTimeout > 86400 { // 5 minutes to 24 hours
                AppLogger.shared.log(
                    "‚ùå [PreferencesService] Invalid UDP session timeout \(udpSessionTimeout), reverting to \(oldValue)")
                udpSessionTimeout = oldValue
            } else {
                UserDefaults.standard.set(udpSessionTimeout, forKey: Keys.udpSessionTimeout)
                AppLogger.shared.log("üîß [PreferencesService] UDP session timeout: \(udpSessionTimeout) seconds")
            }
        }
    }

    // MARK: - Keys

    private enum Keys {
        static let communicationProtocol = "KeyPath.Communication.Protocol"
        static let tcpServerEnabled = "KeyPath.TCP.ServerEnabled"
        static let tcpServerPort = "KeyPath.TCP.ServerPort"
        static let udpServerEnabled = "KeyPath.UDP.ServerEnabled"
        static let udpServerPort = "KeyPath.UDP.ServerPort"
        static let udpAuthToken = "KeyPath.UDP.AuthToken"
        static let udpSessionTimeout = "KeyPath.UDP.SessionTimeout"
    }

    // MARK: - Defaults

    private enum Defaults {
        static let communicationProtocol = CommunicationProtocol.udp // Default to UDP for better performance
        static let tcpServerEnabled = false // TCP as fallback only
        static let tcpServerPort = 54141 // Default port for Kanata TCP server
        static let udpServerEnabled = true // Enable UDP by default
        static let udpServerPort = 37001 // Default port for Kanata UDP server
        static let udpAuthToken = "" // Auto-generate token
        static let udpSessionTimeout = 1800 // 30 minutes (same as Kanata default)
    }

    // MARK: - Initialization

    init() {
        // Load stored preferences or use defaults
        let protocolString = UserDefaults.standard.string(forKey: Keys.communicationProtocol) ?? Defaults.communicationProtocol.rawValue
        communicationProtocol = CommunicationProtocol(rawValue: protocolString) ?? Defaults.communicationProtocol

        tcpServerEnabled =
            UserDefaults.standard.object(forKey: Keys.tcpServerEnabled) as? Bool
                ?? Defaults.tcpServerEnabled
        tcpServerPort =
            UserDefaults.standard.object(forKey: Keys.tcpServerPort) as? Int ?? Defaults.tcpServerPort

        udpServerEnabled =
            UserDefaults.standard.object(forKey: Keys.udpServerEnabled) as? Bool
                ?? Defaults.udpServerEnabled
        udpServerPort =
            UserDefaults.standard.object(forKey: Keys.udpServerPort) as? Int ?? Defaults.udpServerPort
        // Migrate from UserDefaults to Keychain if needed
        let legacyToken = UserDefaults.standard.string(forKey: Keys.udpAuthToken)
        if let legacyToken = legacyToken, !legacyToken.isEmpty {
            // Migrate to Keychain
            do {
                try KeychainService.shared.storeUDPToken(legacyToken)
                UserDefaults.standard.removeObject(forKey: Keys.udpAuthToken)
                udpAuthToken = legacyToken
                AppLogger.shared.log("üîÑ [PreferencesService] Migrated UDP token to secure storage")
            } catch {
                AppLogger.shared.log("‚ö†Ô∏è [PreferencesService] Failed to migrate UDP token: \(error)")
                udpAuthToken = Defaults.udpAuthToken
            }
        } else {
            // Load from Keychain or use default
            do {
                udpAuthToken = try KeychainService.shared.retrieveUDPToken() ?? Defaults.udpAuthToken
            } catch {
                AppLogger.shared.log("‚ö†Ô∏è [PreferencesService] Failed to load UDP token from Keychain: \(error)")
                udpAuthToken = Defaults.udpAuthToken
            }
        }
        udpSessionTimeout =
            UserDefaults.standard.object(forKey: Keys.udpSessionTimeout) as? Int ?? Defaults.udpSessionTimeout

        AppLogger.shared.log(
            "üîß [PreferencesService] Initialized - Protocol: \(communicationProtocol.rawValue), TCP enabled: \(tcpServerEnabled), UDP enabled: \(udpServerEnabled)"
        )
    }

    // MARK: - Public Interface

    /// Reset all communication settings to defaults
    func resetCommunicationSettings() {
        communicationProtocol = Defaults.communicationProtocol
        tcpServerEnabled = Defaults.tcpServerEnabled
        tcpServerPort = Defaults.tcpServerPort
        udpServerEnabled = Defaults.udpServerEnabled
        udpServerPort = Defaults.udpServerPort
        udpAuthToken = Defaults.udpAuthToken
        udpSessionTimeout = Defaults.udpSessionTimeout
        AppLogger.shared.log("üîß [PreferencesService] All communication settings reset to defaults")
    }

    /// Reset TCP settings to defaults (backward compatibility)
    func resetTCPSettings() {
        tcpServerEnabled = Defaults.tcpServerEnabled
        tcpServerPort = Defaults.tcpServerPort
        AppLogger.shared.log("üîß [PreferencesService] TCP settings reset to defaults")
    }

    /// Reset UDP settings to defaults
    func resetUDPSettings() {
        udpServerEnabled = Defaults.udpServerEnabled
        udpServerPort = Defaults.udpServerPort
        udpAuthToken = Defaults.udpAuthToken // This will trigger secure deletion
        udpSessionTimeout = Defaults.udpSessionTimeout
        AppLogger.shared.log("üîß [PreferencesService] UDP settings reset to defaults")
    }

    /// Validate port is in acceptable range
    func isValidPort(_ port: Int) -> Bool {
        port >= 1024 && port <= 65535
    }

    /// Validate TCP port is in acceptable range (backward compatibility)
    func isValidTCPPort(_ port: Int) -> Bool {
        isValidPort(port)
    }

    /// Get current communication configuration as string for logging
    var communicationConfigDescription: String {
        let protocolName = communicationProtocol.rawValue.uppercased()
        switch communicationProtocol {
        case .tcp:
            return "\(protocolName) \(tcpServerEnabled ? "enabled" : "disabled") on port \(tcpServerPort)"
        case .udp:
            let tokenStatus = udpAuthToken.isEmpty ? "auto-generated" : "custom"
            return "\(protocolName) \(udpServerEnabled ? "enabled" : "disabled") on port \(udpServerPort) (secure token: \(tokenStatus))"
        }
    }

    /// Get current TCP configuration as string for logging (backward compatibility)
    var tcpConfigDescription: String {
        "TCP \(tcpServerEnabled ? "enabled" : "disabled") on port \(tcpServerPort)"
    }
}

// MARK: - Convenience Extensions

extension PreferencesService {
    /// Get the currently preferred communication protocol
    var preferredProtocol: CommunicationProtocol {
        communicationProtocol
    }

    /// Check if UDP should be used for communication
    var shouldUseUDP: Bool {
        communicationProtocol == .udp && udpServerEnabled && isValidPort(udpServerPort)
    }

    /// Check if TCP should be used for communication (fallback or explicit preference)
    var shouldUseTCP: Bool {
        communicationProtocol == .tcp && tcpServerEnabled && isValidPort(tcpServerPort)
    }

    /// Get the full TCP endpoint URL if enabled
    var tcpEndpoint: String? {
        guard tcpServerEnabled else { return nil }
        return "127.0.0.1:\(tcpServerPort)"
    }

    /// Get the full UDP endpoint URL if enabled
    var udpEndpoint: String? {
        guard udpServerEnabled else { return nil }
        return "127.0.0.1:\(udpServerPort)"
    }

    /// Check if TCP server should be included in Kanata launch arguments (backward compatibility)
    var shouldUseTCPServer: Bool {
        shouldUseTCP
    }

    /// Check if UDP server should be included in Kanata launch arguments
    var shouldUseUDPServer: Bool {
        shouldUseUDP
    }

    /// Get the active communication endpoint based on protocol preference
    var activeEndpoint: String? {
        switch communicationProtocol {
        case .udp:
            return udpEndpoint
        case .tcp:
            return tcpEndpoint
        }
    }

    /// Get UDP launch arguments for Kanata if UDP is enabled
    var udpLaunchArguments: [String] {
        guard shouldUseUDP else { return [] }

        var args = ["--udp-port", "\(udpServerPort)"]

        // Load token securely for launch arguments
        let secureToken: String
        do {
            secureToken = try KeychainService.shared.retrieveUDPToken() ?? ""
        } catch {
            secureToken = ""
        }

        if !secureToken.isEmpty {
            args.append(contentsOf: ["--udp-auth-token", secureToken])
        }

        if udpSessionTimeout != Defaults.udpSessionTimeout {
            args.append(contentsOf: ["--udp-session-timeout", "\(udpSessionTimeout)"])
        }

        return args
    }

    /// Get TCP launch arguments for Kanata if TCP is enabled (backward compatibility)
    var tcpLaunchArguments: [String] {
        guard shouldUseTCP else { return [] }
        return ["--port", "\(tcpServerPort)"]
    }

    /// Get communication launch arguments based on protocol preference
    var communicationLaunchArguments: [String] {
        switch communicationProtocol {
        case .udp:
            return udpLaunchArguments
        case .tcp:
            return tcpLaunchArguments
        }
    }
}

// MARK: - Thread-Safe Snapshot API

/// Thread-safe snapshot of communication configuration for use from non-MainActor contexts
struct CommunicationSnapshot: Sendable {
    let `protocol`: CommunicationProtocol
    let tcpEnabled: Bool
    let tcpPort: Int
    let udpEnabled: Bool
    let udpPort: Int
    let udpAuthToken: String
    let udpSessionTimeout: Int

    /// Check if UDP server should be used based on snapshot values
    var shouldUseUDP: Bool {
        `protocol` == .udp && udpEnabled && (1024 ... 65535).contains(udpPort)
    }

    /// Check if TCP server should be used based on snapshot values
    var shouldUseTCP: Bool {
        `protocol` == .tcp && tcpEnabled && (1024 ... 65535).contains(tcpPort)
    }

    /// Check if TCP server should be used based on snapshot values (backward compatibility)
    var shouldUseTCPServer: Bool {
        shouldUseTCP
    }

    /// Get active endpoint based on protocol preference
    var activeEndpoint: String? {
        switch `protocol` {
        case .udp where shouldUseUDP:
            return "127.0.0.1:\(udpPort)"
        case .tcp where shouldUseTCP:
            return "127.0.0.1:\(tcpPort)"
        default:
            return nil
        }
    }

    /// Get launch arguments for the preferred protocol
    var communicationLaunchArguments: [String] {
        switch `protocol` {
        case .udp where shouldUseUDP:
            var args = ["--udp-port", "\(udpPort)"]
            // Load token securely for launch arguments
            let secureToken: String
            do {
                secureToken = try KeychainService.shared.retrieveUDPToken() ?? ""
            } catch {
                secureToken = ""
            }

            if !secureToken.isEmpty {
                args.append(contentsOf: ["--udp-auth-token", secureToken])
            }
            if udpSessionTimeout != 1800 { // Default timeout
                args.append(contentsOf: ["--udp-session-timeout", "\(udpSessionTimeout)"])
            }
            return args
        case .tcp where shouldUseTCP:
            return ["--port", "\(tcpPort)"]
        default:
            return []
        }
    }
}

/// Thread-safe snapshot of TCP configuration for use from non-MainActor contexts (backward compatibility)
struct TCPConfigSnapshot: Sendable {
    let enabled: Bool
    let port: Int

    /// Check if TCP server should be used based on snapshot values
    var shouldUseTCPServer: Bool {
        enabled && (1024 ... 65535).contains(port)
    }
}

extension PreferencesService {
    /// Get thread-safe snapshot of communication configuration
    /// Safe to call from any actor context
    nonisolated static func communicationSnapshot() -> CommunicationSnapshot {
        let protocolString = UserDefaults.standard.string(forKey: "KeyPath.Communication.Protocol") ?? "udp"
        let protocolValue = CommunicationProtocol(rawValue: protocolString) ?? .udp

        let tcpEnabled = UserDefaults.standard.object(forKey: "KeyPath.TCP.ServerEnabled") as? Bool ?? false
        let tcpPort = UserDefaults.standard.object(forKey: "KeyPath.TCP.ServerPort") as? Int ?? 54141

        let udpEnabled = UserDefaults.standard.object(forKey: "KeyPath.UDP.ServerEnabled") as? Bool ?? true
        let udpPort = UserDefaults.standard.object(forKey: "KeyPath.UDP.ServerPort") as? Int ?? 37001
        // Load UDP token from Keychain (thread-safe)
        let udpAuthToken: String
        do {
            udpAuthToken = try KeychainService.shared.retrieveUDPToken() ?? ""
        } catch {
            // Fallback to empty string if Keychain fails
            udpAuthToken = ""
        }
        let udpSessionTimeout = UserDefaults.standard.object(forKey: "KeyPath.UDP.SessionTimeout") as? Int ?? 1800

        return CommunicationSnapshot(
            protocol: protocolValue,
            tcpEnabled: tcpEnabled,
            tcpPort: tcpPort,
            udpEnabled: udpEnabled,
            udpPort: udpPort,
            udpAuthToken: udpAuthToken,
            udpSessionTimeout: udpSessionTimeout
        )
    }

    /// Get thread-safe snapshot of TCP configuration (backward compatibility)
    /// Safe to call from any actor context
    nonisolated static func tcpSnapshot() -> TCPConfigSnapshot {
        let enabled = UserDefaults.standard.object(forKey: "KeyPath.TCP.ServerEnabled") as? Bool ?? false
        let port = UserDefaults.standard.object(forKey: "KeyPath.TCP.ServerPort") as? Int ?? 54141

        return TCPConfigSnapshot(enabled: enabled, port: port)
    }
}
