import Foundation
import Observation

/// Communication protocol options for Kanata integration
enum CommunicationProtocol: String, CaseIterable {
    case tcp

    var displayName: String {
        "TCP (High Performance)"
    }

    var description: String {
        "High-performance TCP protocol with ~10x lower latency and token-based security"
    }
}

/// Manages KeyPath application preferences and settings
@Observable
final class PreferencesService: @unchecked Sendable {
    // MARK: - Shared instance (backward compatible)

    @MainActor static let shared = PreferencesService()

    // MARK: - Communication Protocol Configuration

    /// Communication protocol preference
    var communicationProtocol: CommunicationProtocol {
        didSet {
            UserDefaults.standard.set(communicationProtocol.rawValue, forKey: Keys.communicationProtocol)
            AppLogger.shared.log("üîß [PreferencesService] Communication protocol: \(communicationProtocol.rawValue)")
        }
    }

    // MARK: - TCP Server Configuration

    /// Whether TCP server should be enabled for low-latency communication
    var tcpServerEnabled: Bool {
        didSet {
            UserDefaults.standard.set(tcpServerEnabled, forKey: Keys.tcpServerEnabled)
            AppLogger.shared.log("üîß [PreferencesService] TCP server enabled: \(tcpServerEnabled)")
        }
    }

    /// TCP server port for Kanata communication
    var tcpServerPort: Int {
        didSet {
            // Validate port range and revert if invalid
            if !isValidPort(tcpServerPort) {
                AppLogger.shared.log(
                    "‚ùå [PreferencesService] Invalid TCP port \(tcpServerPort), reverting to \(oldValue)")
                tcpServerPort = oldValue
            } else {
                UserDefaults.standard.set(tcpServerPort, forKey: Keys.tcpServerPort)
                AppLogger.shared.log("üîß [PreferencesService] TCP server port: \(tcpServerPort)")
            }
        }
    }

    /// Authentication token for TCP server (managed by TCPAuthTokenManager)
    /// If empty, will be auto-generated by Kanata and logged to console
    var tcpAuthToken: String {
        get {
            // Read directly from shared file (single source of truth)
            let token = CommunicationSnapshot.readSharedTCPToken() ?? ""
            AppLogger.shared.log("üîß [PreferencesService] Reading TCP token from shared file: \(token.isEmpty ? "EMPTY" : "[REDACTED]")")
            return token
        }
        set {
            // Write directly to shared file (single source of truth)
            if newValue.isEmpty {
                // Clear token - remove file
                let tokenPath = CommunicationSnapshot.tcpAuthTokenPath()
                try? FileManager.default.removeItem(atPath: tokenPath)
                AppLogger.shared.log("üîß [PreferencesService] TCP auth token cleared")
            } else {
                // Set token - write to shared file
                let success = CommunicationSnapshot.writeSharedTCPToken(newValue)
                if success {
                    AppLogger.shared.log("üîß [PreferencesService] TCP auth token updated in shared file")
                } else {
                    AppLogger.shared.log("‚ùå [PreferencesService] Failed to write token to shared file")
                }
            }
            // Remove legacy UserDefaults for security
            UserDefaults.standard.removeObject(forKey: Keys.tcpAuthToken)
        }
    }

    /// Session timeout for TCP authentication in seconds
    var tcpSessionTimeout: Int {
        didSet {
            if tcpSessionTimeout < 300 || tcpSessionTimeout > 86400 { // 5 minutes to 24 hours
                AppLogger.shared.log(
                    "‚ùå [PreferencesService] Invalid TCP session timeout \(tcpSessionTimeout), reverting to \(oldValue)")
                tcpSessionTimeout = oldValue
            } else {
                UserDefaults.standard.set(tcpSessionTimeout, forKey: Keys.tcpSessionTimeout)
                AppLogger.shared.log("üîß [PreferencesService] TCP session timeout: \(tcpSessionTimeout) seconds")
            }
        }
    }

    /// Whether user notifications are enabled
    var notificationsEnabled: Bool {
        didSet {
            UserDefaults.standard.set(notificationsEnabled, forKey: Keys.notificationsEnabled)
            AppLogger.shared.log("üîî [PreferencesService] Notifications enabled: \(notificationsEnabled)")
        }
    }

    /// Whether non-critical (info/success) notifications are enabled.
    /// Critical/service/permission notifications are unaffected by this flag.
    var successNotificationsEnabled: Bool {
        didSet {
            UserDefaults.standard.set(successNotificationsEnabled, forKey: Keys.successNotificationsEnabled)
            AppLogger.shared.log("üîî [PreferencesService] Success notifications: \(successNotificationsEnabled)")
        }
    }

    /// When true, leave mappings active while recording (effective preview).
    /// When false, temporarily suspend mappings so the recorder captures raw keys.
    var applyMappingsDuringRecording: Bool {
        didSet {
            UserDefaults.standard.set(applyMappingsDuringRecording, forKey: Keys.applyMappingsDuringRecording)
            AppLogger.shared.log("üéõÔ∏è [Preferences] applyMappingsDuringRecording = \(applyMappingsDuringRecording)")
        }
    }

    // MARK: - Keys

    private enum Keys {
        static let communicationProtocol = "KeyPath.Communication.Protocol"
        static let tcpServerEnabled = "KeyPath.TCP.ServerEnabled"
        static let tcpServerPort = "KeyPath.TCP.ServerPort"
        static let tcpAuthToken = "KeyPath.TCP.AuthToken"
        static let tcpSessionTimeout = "KeyPath.TCP.SessionTimeout"
        static let notificationsEnabled = "KeyPath.Notifications.Enabled"
        static let successNotificationsEnabled = "KeyPath.Notifications.SuccessEnabled"
        static let applyMappingsDuringRecording = "KeyPath.Recording.ApplyMappingsDuringRecording"
    }

    // MARK: - Defaults

    private enum Defaults {
        static let communicationProtocol = CommunicationProtocol.tcp // TCP-only for high performance
        static let tcpServerEnabled = true // Enable TCP by default
        static let tcpServerPort = 37001 // Default port for Kanata TCP server
        static let tcpAuthToken = "" // Auto-generate token
        static let tcpSessionTimeout = 1800 // 30 minutes (same as Kanata default)
        static let notificationsEnabled = true
        static let successNotificationsEnabled = true
        static let applyMappingsDuringRecording = true
    }

    // MARK: - Initialization

    init() {
        // Load stored preferences or use defaults
        let protocolString = UserDefaults.standard.string(forKey: Keys.communicationProtocol) ?? Defaults.communicationProtocol.rawValue
        communicationProtocol = CommunicationProtocol(rawValue: protocolString) ?? Defaults.communicationProtocol

        tcpServerEnabled =
            UserDefaults.standard.object(forKey: Keys.tcpServerEnabled) as? Bool
                ?? Defaults.tcpServerEnabled
        tcpServerPort =
            UserDefaults.standard.object(forKey: Keys.tcpServerPort) as? Int ?? Defaults.tcpServerPort

        tcpSessionTimeout =
            UserDefaults.standard.object(forKey: Keys.tcpSessionTimeout) as? Int ?? Defaults.tcpSessionTimeout

        notificationsEnabled =
            UserDefaults.standard.object(forKey: Keys.notificationsEnabled) as? Bool
                ?? Defaults.notificationsEnabled
        successNotificationsEnabled =
            UserDefaults.standard.object(forKey: Keys.successNotificationsEnabled) as? Bool
                ?? Defaults.successNotificationsEnabled

        // Recording preference
        applyMappingsDuringRecording =
            UserDefaults.standard.object(forKey: Keys.applyMappingsDuringRecording) as? Bool
                ?? Defaults.applyMappingsDuringRecording

        AppLogger.shared.log(
            "üîß [PreferencesService] Initialized - Protocol: \(communicationProtocol.rawValue), TCP enabled: \(tcpServerEnabled)"
        )

        // Handle legacy UserDefaults migration
        let legacyToken = UserDefaults.standard.string(forKey: Keys.tcpAuthToken)
        if let legacyToken, !legacyToken.isEmpty {
            // Migrate to shared file
            let success = CommunicationSnapshot.writeSharedTCPToken(legacyToken)
            if success {
                UserDefaults.standard.removeObject(forKey: Keys.tcpAuthToken)
                AppLogger.shared.log("üîÑ [PreferencesService] Migrated legacy TCP token to shared file")
            } else {
                AppLogger.shared.log("‚ö†Ô∏è [PreferencesService] Failed to migrate legacy token to shared file")
            }
        }
    }

    // MARK: - Public Interface

    /// Reset all communication settings to defaults
    func resetCommunicationSettings() {
        communicationProtocol = Defaults.communicationProtocol
        tcpServerEnabled = Defaults.tcpServerEnabled
        tcpServerPort = Defaults.tcpServerPort
        tcpAuthToken = Defaults.tcpAuthToken
        tcpSessionTimeout = Defaults.tcpSessionTimeout
        AppLogger.shared.log("üîß [PreferencesService] All communication settings reset to defaults")
    }

    /// Reset TCP settings to defaults
    func resetTCPSettings() {
        tcpServerEnabled = Defaults.tcpServerEnabled
        tcpServerPort = Defaults.tcpServerPort
        tcpAuthToken = Defaults.tcpAuthToken // This will trigger secure deletion
        tcpSessionTimeout = Defaults.tcpSessionTimeout
        AppLogger.shared.log("üîß [PreferencesService] TCP settings reset to defaults")
    }

    /// Validate port is in acceptable range
    func isValidPort(_ port: Int) -> Bool {
        port >= 1024 && port <= 65535
    }

    /// Get current communication configuration as string for logging
    var communicationConfigDescription: String {
        let tokenStatus = tcpAuthToken.isEmpty ? "auto-generated" : "custom"
        return "TCP \(tcpServerEnabled ? "enabled" : "disabled") on port \(tcpServerPort) (secure token: \(tokenStatus))"
    }
}

// MARK: - Convenience Extensions

extension PreferencesService {
    /// Get the currently preferred communication protocol
    var preferredProtocol: CommunicationProtocol {
        communicationProtocol
    }

    /// Check if TCP should be used for communication
    var shouldUseTCP: Bool {
        communicationProtocol == .tcp && tcpServerEnabled && isValidPort(tcpServerPort)
    }

    /// Get the full TCP endpoint URL if enabled
    var tcpEndpoint: String? {
        guard tcpServerEnabled else { return nil }
        return "127.0.0.1:\(tcpServerPort)"
    }

    /// Check if TCP server should be included in Kanata launch arguments
    var shouldUseTCPServer: Bool {
        shouldUseTCP
    }

    /// Get the active communication endpoint based on protocol preference
    var activeEndpoint: String? {
        tcpEndpoint
    }

    /// Get TCP launch arguments for Kanata if TCP is enabled
    var tcpLaunchArguments: [String] {
        guard shouldUseTCP else { return [] }
        // Ensure a token exists before building arguments/env
        _ = CommunicationSnapshot.ensureSharedTCPToken()
        return Self.buildTCPArguments(
            port: tcpServerPort,
            sessionTimeout: tcpSessionTimeout,
            defaultTimeout: Defaults.tcpSessionTimeout
        )
    }

    /// Build TCP launch arguments - token passed via environment variable for security
    nonisolated static func buildTCPArguments(port: Int, sessionTimeout: Int, defaultTimeout: Int) -> [String] {
        var args = ["--tcp-port", "\(port)"]

        // Always require auth: ensure token exists and will be provided via env
        let token = CommunicationSnapshot.ensureSharedTCPToken()
        if token.isEmpty {
            AppLogger.shared.log("‚ùå [TCP Launch] Failed to ensure TCP token; refusing to start without auth")
            // Still return args; caller should decide to abort launch if desired
        } else {
            AppLogger.shared.log("üîê [TCP Launch] Auth token ensured; using environment variable")
        }

        if sessionTimeout != defaultTimeout {
            args.append(contentsOf: ["--tcp-session-timeout", "\(sessionTimeout)"])
        }

        return args
    }

    /// Get communication launch arguments based on protocol preference
    var communicationLaunchArguments: [String] {
        tcpLaunchArguments
    }

    /// Get environment variables for secure token passing
    var communicationEnvironmentVariables: [String: String] {
        guard shouldUseTCP else { return [:] }

        // Ensure and pass TCP token via environment variable for security
        let token = CommunicationSnapshot.ensureSharedTCPToken()
        if !token.isEmpty {
            return ["KANATA_TCP_TOKEN": token]
        }

        AppLogger.shared.log("‚ùå [PreferencesService] Missing TCP token; not exposing TCP environment")
        return [:]
    }
}


// MARK: - Thread-Safe Snapshot API

/// Thread-safe snapshot of TCP communication configuration for use from non-MainActor contexts
struct CommunicationSnapshot: Sendable {
    let tcpEnabled: Bool
    let tcpPort: Int
    let tcpAuthToken: String
    let tcpSessionTimeout: Int

    /// Check if TCP server should be used based on snapshot values
    var shouldUseTCP: Bool {
        tcpEnabled && (1024 ... 65535).contains(tcpPort)
    }

    /// Get active TCP endpoint
    var activeEndpoint: String? {
        guard shouldUseTCP else { return nil }
        return "127.0.0.1:\(tcpPort)"
    }

    /// Get cross-platform path for shared TCP auth token file
    nonisolated static func tcpAuthTokenPath() -> String {
        #if os(macOS)
            return FileManager.default.homeDirectoryForCurrentUser
                .appendingPathComponent(".config/keypath/tcp-auth-token")
                .path
        #elseif os(Windows)
            let supportDir = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first
            return supportDir?.appendingPathComponent("keypath/tcp-auth-token").path ??
                NSHomeDirectory() + "/AppData/Roaming/keypath/tcp-auth-token"
        #else
            return FileManager.default.homeDirectoryForCurrentUser
                .appendingPathComponent(".config/keypath/tcp-auth-token")
                .path
        #endif
    }

    /// Generate secure 32-character TCP auth token
    nonisolated static func generateTCPAuthToken() -> String {
        var randomBytes = [UInt8](repeating: 0, count: 32)
        let result = SecRandomCopyBytes(kSecRandomDefault, randomBytes.count, &randomBytes)
        if result == errSecSuccess {
            let data = Data(randomBytes)
            return data.base64EncodedString()
                .replacingOccurrences(of: "+", with: "-")
                .replacingOccurrences(of: "/", with: "_")
                .replacingOccurrences(of: "=", with: "")
        } else {
            let characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_"
            return String((0 ..< 32).map { _ in characters.randomElement()! })
        }
    }

    /// Write shared TCP auth token to cross-platform file location
    nonisolated static func writeSharedTCPToken(_ token: String) -> Bool {
        let tokenPath = tcpAuthTokenPath()
        let tokenDir = (tokenPath as NSString).deletingLastPathComponent

        do {
            // Create directory if it doesn't exist
            try FileManager.default.createDirectory(
                atPath: tokenDir,
                withIntermediateDirectories: true,
                attributes: [.posixPermissions: 0o700]
            )

            // Write token to file
            try token.write(toFile: tokenPath, atomically: true, encoding: .utf8)

            // Set secure permissions (owner read/write only)
            try FileManager.default.setAttributes(
                [.posixPermissions: 0o600],
                ofItemAtPath: tokenPath
            )

            return true
        } catch {
            AppLogger.shared.log("‚ùå [TCP Auth] Failed to write shared token: \(error)")
            return false
        }
    }

    /// Read shared TCP auth token from cross-platform file location
    nonisolated static func readSharedTCPToken() -> String? {
        let tokenPath = tcpAuthTokenPath()
        do {
            let token = try String(contentsOfFile: tokenPath, encoding: .utf8)
            return token.trimmingCharacters(in: .whitespacesAndNewlines)
        } catch {
            return nil
        }
    }

    /// Ensure shared TCP token exists, generating one if needed
    nonisolated static func ensureSharedTCPToken() -> String {
        // Try to read existing token
        if let existingToken = readSharedTCPToken(), !existingToken.isEmpty {
            return existingToken
        }

        // Generate new token
        let newToken = generateTCPAuthToken()

        // Write to shared file
        if writeSharedTCPToken(newToken) {
            AppLogger.shared.log("üîê [TCP Auth] Generated new shared token")

            // Also store in Keychain for backup/persistence
            Task { @MainActor in
                do {
                    try KeychainService.shared.storeTCPToken(newToken)
                } catch {
                    AppLogger.shared.log("‚ö†Ô∏è [TCP Auth] Failed to backup token in Keychain: \(error)")
                }
            }

            return newToken
        } else {
            AppLogger.shared.log("‚ùå [TCP Auth] Failed to write shared token, using generated token")
            return newToken
        }
    }

    /// Get TCP launch arguments
    var communicationLaunchArguments: [String] {
        guard shouldUseTCP else { return [] }
        _ = CommunicationSnapshot.ensureSharedTCPToken()
        return PreferencesService.buildTCPArguments(
            port: tcpPort,
            sessionTimeout: tcpSessionTimeout,
            defaultTimeout: 1800
        )
    }

    /// Get environment variables for secure token passing
    var communicationEnvironmentVariables: [String: String] {
        guard shouldUseTCP else { return [:] }
        let token = CommunicationSnapshot.ensureSharedTCPToken()
        if !token.isEmpty {
            return ["KANATA_TCP_TOKEN": token]
        }
        return [:]
    }
}

extension PreferencesService {
    /// Get thread-safe snapshot of TCP communication configuration
    /// Safe to call from any actor context
    nonisolated static func communicationSnapshot() -> CommunicationSnapshot {
        let tcpEnabled = UserDefaults.standard.object(forKey: "KeyPath.TCP.ServerEnabled") as? Bool ?? true
        let tcpPort = UserDefaults.standard.object(forKey: "KeyPath.TCP.ServerPort") as? Int ?? 37001

        // Load TCP token from shared file (single source of truth)
        let tcpAuthToken = CommunicationSnapshot.readSharedTCPToken() ?? ""

        let tcpSessionTimeout = UserDefaults.standard.object(forKey: "KeyPath.TCP.SessionTimeout") as? Int ?? 1800

        return CommunicationSnapshot(
            tcpEnabled: tcpEnabled,
            tcpPort: tcpPort,
            tcpAuthToken: tcpAuthToken,
            tcpSessionTimeout: tcpSessionTimeout
        )
    }

    /// Get communication configuration for external clients
    /// Returns endpoint URL and shared token path for cross-platform integration
    nonisolated static func externalClientConfiguration() -> (endpoint: String?, tokenPath: String) {
        let snapshot = communicationSnapshot()
        let endpoint = snapshot.activeEndpoint
        let tokenPath = CommunicationSnapshot.tcpAuthTokenPath()

        return (endpoint: endpoint, tokenPath: tokenPath)
    }
}
