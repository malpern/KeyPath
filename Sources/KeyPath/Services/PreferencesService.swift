import Foundation
import Observation

/// Communication protocol options for Kanata integration
enum CommunicationProtocol: String, CaseIterable {
    case udp

    var displayName: String {
        return "UDP (High Performance)"
    }

    var description: String {
        return "High-performance UDP protocol with ~10x lower latency and token-based security"
    }
}

/// Manages KeyPath application preferences and settings
@MainActor
@Observable
final class PreferencesService {
    // MARK: - Shared instance (backward compatible)

    static let shared = PreferencesService()

    // MARK: - Communication Protocol Configuration

    /// Communication protocol preference
    var communicationProtocol: CommunicationProtocol {
        didSet {
            UserDefaults.standard.set(communicationProtocol.rawValue, forKey: Keys.communicationProtocol)
            AppLogger.shared.log("üîß [PreferencesService] Communication protocol: \(communicationProtocol.rawValue)")
        }
    }

    // MARK: - UDP Server Configuration

    /// Whether UDP server should be enabled for low-latency communication
    var udpServerEnabled: Bool {
        didSet {
            UserDefaults.standard.set(udpServerEnabled, forKey: Keys.udpServerEnabled)
            AppLogger.shared.log("üîß [PreferencesService] UDP server enabled: \(udpServerEnabled)")
        }
    }

    /// UDP server port for Kanata communication
    var udpServerPort: Int {
        didSet {
            // Validate port range and revert if invalid
            if !isValidPort(udpServerPort) {
                AppLogger.shared.log(
                    "‚ùå [PreferencesService] Invalid UDP port \(udpServerPort), reverting to \(oldValue)")
                udpServerPort = oldValue
            } else {
                UserDefaults.standard.set(udpServerPort, forKey: Keys.udpServerPort)
                AppLogger.shared.log("üîß [PreferencesService] UDP server port: \(udpServerPort)")
            }
        }
    }

    /// Authentication token for UDP server (stored securely in Keychain)
    /// If empty, will be auto-generated by Kanata and logged to console
    var udpAuthToken: String {
        didSet {
            // Store token securely in Keychain instead of UserDefaults
            do {
                if udpAuthToken.isEmpty {
                    try KeychainService.shared.deleteUDPToken()
                } else {
                    try KeychainService.shared.storeUDPToken(udpAuthToken)
                }
                // Remove from UserDefaults for security (migration)
                UserDefaults.standard.removeObject(forKey: Keys.udpAuthToken)
                AppLogger.shared.log("üîß [PreferencesService] UDP auth token updated (stored securely)")
            } catch {
                AppLogger.shared.log("‚ùå [PreferencesService] Failed to store UDP token securely: \(error)")
            }
        }
    }

    /// Session timeout for UDP authentication in seconds
    var udpSessionTimeout: Int {
        didSet {
            if udpSessionTimeout < 300 || udpSessionTimeout > 86400 { // 5 minutes to 24 hours
                AppLogger.shared.log(
                    "‚ùå [PreferencesService] Invalid UDP session timeout \(udpSessionTimeout), reverting to \(oldValue)")
                udpSessionTimeout = oldValue
            } else {
                UserDefaults.standard.set(udpSessionTimeout, forKey: Keys.udpSessionTimeout)
                AppLogger.shared.log("üîß [PreferencesService] UDP session timeout: \(udpSessionTimeout) seconds")
            }
        }
    }

    // MARK: - Keys

    private enum Keys {
        static let communicationProtocol = "KeyPath.Communication.Protocol"
        static let udpServerEnabled = "KeyPath.UDP.ServerEnabled"
        static let udpServerPort = "KeyPath.UDP.ServerPort"
        static let udpAuthToken = "KeyPath.UDP.AuthToken"
        static let udpSessionTimeout = "KeyPath.UDP.SessionTimeout"
    }

    // MARK: - Defaults

    private enum Defaults {
        static let communicationProtocol = CommunicationProtocol.udp // UDP-only for high performance
        static let udpServerEnabled = true // Enable UDP by default
        static let udpServerPort = 37001 // Default port for Kanata UDP server
        static let udpAuthToken = "" // Auto-generate token
        static let udpSessionTimeout = 1800 // 30 minutes (same as Kanata default)
    }

    // MARK: - Initialization

    init() {
        // Load stored preferences or use defaults
        let protocolString = UserDefaults.standard.string(forKey: Keys.communicationProtocol) ?? Defaults.communicationProtocol.rawValue
        communicationProtocol = CommunicationProtocol(rawValue: protocolString) ?? Defaults.communicationProtocol

        udpServerEnabled =
            UserDefaults.standard.object(forKey: Keys.udpServerEnabled) as? Bool
                ?? Defaults.udpServerEnabled
        udpServerPort =
            UserDefaults.standard.object(forKey: Keys.udpServerPort) as? Int ?? Defaults.udpServerPort
        // Migrate from UserDefaults to Keychain if needed
        let legacyToken = UserDefaults.standard.string(forKey: Keys.udpAuthToken)
        if let legacyToken = legacyToken, !legacyToken.isEmpty {
            // Migrate to Keychain
            do {
                try KeychainService.shared.storeUDPToken(legacyToken)
                UserDefaults.standard.removeObject(forKey: Keys.udpAuthToken)
                udpAuthToken = legacyToken
                AppLogger.shared.log("üîÑ [PreferencesService] Migrated UDP token to secure storage")
            } catch {
                AppLogger.shared.log("‚ö†Ô∏è [PreferencesService] Failed to migrate UDP token: \(error)")
                udpAuthToken = Defaults.udpAuthToken
            }
        } else {
            // Load from Keychain or use default
            do {
                udpAuthToken = try KeychainService.shared.retrieveUDPToken() ?? Defaults.udpAuthToken
            } catch {
                AppLogger.shared.log("‚ö†Ô∏è [PreferencesService] Failed to load UDP token from Keychain: \(error)")
                udpAuthToken = Defaults.udpAuthToken
            }
        }
        udpSessionTimeout =
            UserDefaults.standard.object(forKey: Keys.udpSessionTimeout) as? Int ?? Defaults.udpSessionTimeout

        AppLogger.shared.log(
            "üîß [PreferencesService] Initialized - Protocol: \(communicationProtocol.rawValue), UDP enabled: \(udpServerEnabled)"
        )
    }

    // MARK: - Public Interface

    /// Reset all communication settings to defaults
    func resetCommunicationSettings() {
        communicationProtocol = Defaults.communicationProtocol
        udpServerEnabled = Defaults.udpServerEnabled
        udpServerPort = Defaults.udpServerPort
        udpAuthToken = Defaults.udpAuthToken
        udpSessionTimeout = Defaults.udpSessionTimeout
        AppLogger.shared.log("üîß [PreferencesService] All communication settings reset to defaults")
    }

    /// Reset UDP settings to defaults
    func resetUDPSettings() {
        udpServerEnabled = Defaults.udpServerEnabled
        udpServerPort = Defaults.udpServerPort
        udpAuthToken = Defaults.udpAuthToken // This will trigger secure deletion
        udpSessionTimeout = Defaults.udpSessionTimeout
        AppLogger.shared.log("üîß [PreferencesService] UDP settings reset to defaults")
    }

    /// Validate port is in acceptable range
    func isValidPort(_ port: Int) -> Bool {
        port >= 1024 && port <= 65535
    }

    /// Get current communication configuration as string for logging
    var communicationConfigDescription: String {
        let tokenStatus = udpAuthToken.isEmpty ? "auto-generated" : "custom"
        return "UDP \(udpServerEnabled ? "enabled" : "disabled") on port \(udpServerPort) (secure token: \(tokenStatus))"
    }
}

// MARK: - Convenience Extensions

extension PreferencesService {
    /// Get the currently preferred communication protocol
    var preferredProtocol: CommunicationProtocol {
        communicationProtocol
    }

    /// Check if UDP should be used for communication
    var shouldUseUDP: Bool {
        communicationProtocol == .udp && udpServerEnabled && isValidPort(udpServerPort)
    }

    /// Get the full UDP endpoint URL if enabled
    var udpEndpoint: String? {
        guard udpServerEnabled else { return nil }
        return "127.0.0.1:\(udpServerPort)"
    }

    /// Check if UDP server should be included in Kanata launch arguments
    var shouldUseUDPServer: Bool {
        shouldUseUDP
    }

    /// Get the active communication endpoint based on protocol preference
    var activeEndpoint: String? {
        return udpEndpoint
    }

    /// Get UDP launch arguments for Kanata if UDP is enabled
    var udpLaunchArguments: [String] {
        guard shouldUseUDP else { return [] }

        var args = ["--udp-port", "\(udpServerPort)"]

        // Phase 1-3: Multi-phase token authentication
        let sharedTokenPath = CommunicationSnapshot.udpAuthTokenPath()
        if let sharedToken = try? String(contentsOfFile: sharedTokenPath, encoding: .utf8).trimmingCharacters(in: .whitespacesAndNewlines),
           !sharedToken.isEmpty {
            // Phase 2/3: Use shared token file for cross-platform compatibility
            args.append(contentsOf: ["--udp-auth-token", sharedToken])
        } else {
            // Phase 1: Disable auth for immediate functionality
            args.append("--udp-no-auth")
        }

        if udpSessionTimeout != Defaults.udpSessionTimeout {
            args.append(contentsOf: ["--udp-session-timeout", "\(udpSessionTimeout)"])
        }

        return args
    }

    /// Get communication launch arguments based on protocol preference
    var communicationLaunchArguments: [String] {
        return udpLaunchArguments
    }
}

// MARK: - Thread-Safe Snapshot API

/// Thread-safe snapshot of UDP communication configuration for use from non-MainActor contexts
struct CommunicationSnapshot: Sendable {
    let udpEnabled: Bool
    let udpPort: Int
    let udpAuthToken: String
    let udpSessionTimeout: Int

    /// Check if UDP server should be used based on snapshot values
    var shouldUseUDP: Bool {
        udpEnabled && (1024 ... 65535).contains(udpPort)
    }

    /// Get active UDP endpoint
    var activeEndpoint: String? {
        guard shouldUseUDP else { return nil }
        return "127.0.0.1:\(udpPort)"
    }

    /// Get cross-platform path for shared UDP auth token file
    static func udpAuthTokenPath() -> String {
        #if os(macOS)
            return NSHomeDirectory() + "/.config/keypath/udp-auth-token"
        #elseif os(Windows)
            return NSHomeDirectory() + "/AppData/Roaming/keypath/udp-auth-token"
        #else
            return NSHomeDirectory() + "/.config/keypath/udp-auth-token"
        #endif
    }

    /// Generate secure 32-character UDP auth token
    static func generateUDPAuthToken() -> String {
        let characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        return String((0 ..< 32).map { _ in characters.randomElement()! })
    }

    /// Write shared UDP auth token to cross-platform file location
    static func writeSharedUDPToken(_ token: String) -> Bool {
        let tokenPath = udpAuthTokenPath()
        let tokenDir = (tokenPath as NSString).deletingLastPathComponent

        do {
            // Create directory if it doesn't exist
            try FileManager.default.createDirectory(
                atPath: tokenDir,
                withIntermediateDirectories: true,
                attributes: nil
            )

            // Write token to file
            try token.write(toFile: tokenPath, atomically: true, encoding: .utf8)

            // Set secure permissions (owner read/write only)
            try FileManager.default.setAttributes(
                [.posixPermissions: 0o600],
                ofItemAtPath: tokenPath
            )

            return true
        } catch {
            AppLogger.shared.log("‚ùå [UDP Auth] Failed to write shared token: \(error)")
            return false
        }
    }

    /// Read shared UDP auth token from cross-platform file location
    static func readSharedUDPToken() -> String? {
        let tokenPath = udpAuthTokenPath()
        do {
            let token = try String(contentsOfFile: tokenPath, encoding: .utf8)
            return token.trimmingCharacters(in: .whitespacesAndNewlines)
        } catch {
            return nil
        }
    }

    /// Ensure shared UDP token exists, generating one if needed
    static func ensureSharedUDPToken() -> String {
        // Try to read existing token
        if let existingToken = readSharedUDPToken(), !existingToken.isEmpty {
            return existingToken
        }

        // Generate new token
        let newToken = generateUDPAuthToken()

        // Write to shared file
        if writeSharedUDPToken(newToken) {
            AppLogger.shared.log("üîê [UDP Auth] Generated new shared token")

            // Also store in Keychain for backup/persistence
            do {
                try KeychainService.shared.storeUDPToken(newToken)
            } catch {
                AppLogger.shared.log("‚ö†Ô∏è [UDP Auth] Failed to backup token in Keychain: \(error)")
            }

            return newToken
        } else {
            AppLogger.shared.log("‚ùå [UDP Auth] Failed to write shared token, using generated token")
            return newToken
        }
    }

    /// Get UDP launch arguments
    var communicationLaunchArguments: [String] {
        guard shouldUseUDP else { return [] }

        var args = ["--udp-port", "\(udpPort)"]

        // Phase 1-3: Multi-phase token authentication
        let sharedTokenPath = CommunicationSnapshot.udpAuthTokenPath()
        if let sharedToken = try? String(contentsOfFile: sharedTokenPath, encoding: .utf8).trimmingCharacters(in: .whitespacesAndNewlines),
           !sharedToken.isEmpty {
            // Phase 2/3: Use shared token file for cross-platform compatibility
            args.append(contentsOf: ["--udp-auth-token", sharedToken])
        } else if !udpAuthToken.isEmpty {
            // Fallback: Use provided token (from snapshot/keychain)
            args.append(contentsOf: ["--udp-auth-token", udpAuthToken])
        } else {
            // Phase 1: Disable auth for immediate functionality
            args.append("--udp-no-auth")
        }

        if udpSessionTimeout != 1800 { // Default timeout
            args.append(contentsOf: ["--udp-session-timeout", "\(udpSessionTimeout)"])
        }

        return args
    }
}

extension PreferencesService {
    /// Get thread-safe snapshot of UDP communication configuration
    /// Safe to call from any actor context
    nonisolated static func communicationSnapshot() -> CommunicationSnapshot {
        let udpEnabled = UserDefaults.standard.object(forKey: "KeyPath.UDP.ServerEnabled") as? Bool ?? true
        let udpPort = UserDefaults.standard.object(forKey: "KeyPath.UDP.ServerPort") as? Int ?? 37001

        // Load UDP token from Keychain (thread-safe)
        let udpAuthToken: String
        do {
            udpAuthToken = try KeychainService.shared.retrieveUDPToken() ?? ""
        } catch {
            // Fallback to empty string if Keychain fails
            udpAuthToken = ""
        }

        let udpSessionTimeout = UserDefaults.standard.object(forKey: "KeyPath.UDP.SessionTimeout") as? Int ?? 1800

        return CommunicationSnapshot(
            udpEnabled: udpEnabled,
            udpPort: udpPort,
            udpAuthToken: udpAuthToken,
            udpSessionTimeout: udpSessionTimeout
        )
    }

    /// Get communication configuration for external clients
    /// Returns endpoint URL and shared token path for cross-platform integration
    nonisolated static func externalClientConfiguration() -> (endpoint: String?, tokenPath: String) {
        let snapshot = communicationSnapshot()
        let endpoint = snapshot.activeEndpoint
        let tokenPath = CommunicationSnapshot.udpAuthTokenPath()

        return (endpoint: endpoint, tokenPath: tokenPath)
    }
}
