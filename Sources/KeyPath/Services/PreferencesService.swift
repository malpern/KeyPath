import Foundation
import Observation

/// Communication protocol options for Kanata integration
enum CommunicationProtocol: String, CaseIterable {
    case udp

    var displayName: String {
        return "UDP (High Performance)"
    }

    var description: String {
        return "High-performance UDP protocol with ~10x lower latency and token-based security"
    }
}

/// Manages KeyPath application preferences and settings
@MainActor
@Observable
final class PreferencesService {
    // MARK: - Shared instance (backward compatible)

    static let shared = PreferencesService()

    // MARK: - Communication Protocol Configuration

    /// Communication protocol preference
    var communicationProtocol: CommunicationProtocol {
        didSet {
            UserDefaults.standard.set(communicationProtocol.rawValue, forKey: Keys.communicationProtocol)
            AppLogger.shared.log("üîß [PreferencesService] Communication protocol: \(communicationProtocol.rawValue)")
        }
    }

    // MARK: - UDP Server Configuration

    /// Whether UDP server should be enabled for low-latency communication
    var udpServerEnabled: Bool {
        didSet {
            UserDefaults.standard.set(udpServerEnabled, forKey: Keys.udpServerEnabled)
            AppLogger.shared.log("üîß [PreferencesService] UDP server enabled: \(udpServerEnabled)")
        }
    }

    /// UDP server port for Kanata communication
    var udpServerPort: Int {
        didSet {
            // Validate port range and revert if invalid
            if !isValidPort(udpServerPort) {
                AppLogger.shared.log(
                    "‚ùå [PreferencesService] Invalid UDP port \(udpServerPort), reverting to \(oldValue)")
                udpServerPort = oldValue
            } else {
                UserDefaults.standard.set(udpServerPort, forKey: Keys.udpServerPort)
                AppLogger.shared.log("üîß [PreferencesService] UDP server port: \(udpServerPort)")
            }
        }
    }

    /// Authentication token for UDP server (stored securely in Keychain)
    /// If empty, will be auto-generated by Kanata and logged to console
    var udpAuthToken: String {
        didSet {
            // Store token securely in Keychain instead of UserDefaults
            do {
                if udpAuthToken.isEmpty {
                    try KeychainService.shared.deleteUDPToken()
                } else {
                    try KeychainService.shared.storeUDPToken(udpAuthToken)
                }
                // Remove from UserDefaults for security (migration)
                UserDefaults.standard.removeObject(forKey: Keys.udpAuthToken)
                AppLogger.shared.log("üîß [PreferencesService] UDP auth token updated (stored securely)")
            } catch {
                AppLogger.shared.log("‚ùå [PreferencesService] Failed to store UDP token securely: \(error)")
            }
        }
    }

    /// Session timeout for UDP authentication in seconds
    var udpSessionTimeout: Int {
        didSet {
            if udpSessionTimeout < 300 || udpSessionTimeout > 86400 { // 5 minutes to 24 hours
                AppLogger.shared.log(
                    "‚ùå [PreferencesService] Invalid UDP session timeout \(udpSessionTimeout), reverting to \(oldValue)")
                udpSessionTimeout = oldValue
            } else {
                UserDefaults.standard.set(udpSessionTimeout, forKey: Keys.udpSessionTimeout)
                AppLogger.shared.log("üîß [PreferencesService] UDP session timeout: \(udpSessionTimeout) seconds")
            }
        }
    }

    // MARK: - Keys

    private enum Keys {
        static let communicationProtocol = "KeyPath.Communication.Protocol"
        static let udpServerEnabled = "KeyPath.UDP.ServerEnabled"
        static let udpServerPort = "KeyPath.UDP.ServerPort"
        static let udpAuthToken = "KeyPath.UDP.AuthToken"
        static let udpSessionTimeout = "KeyPath.UDP.SessionTimeout"
    }

    // MARK: - Defaults

    private enum Defaults {
        static let communicationProtocol = CommunicationProtocol.udp // UDP-only for high performance
        static let udpServerEnabled = true // Enable UDP by default
        static let udpServerPort = 37001 // Default port for Kanata UDP server
        static let udpAuthToken = "" // Auto-generate token
        static let udpSessionTimeout = 1800 // 30 minutes (same as Kanata default)
    }

    // MARK: - Initialization

    init() {
        // Load stored preferences or use defaults
        let protocolString = UserDefaults.standard.string(forKey: Keys.communicationProtocol) ?? Defaults.communicationProtocol.rawValue
        communicationProtocol = CommunicationProtocol(rawValue: protocolString) ?? Defaults.communicationProtocol

        udpServerEnabled =
            UserDefaults.standard.object(forKey: Keys.udpServerEnabled) as? Bool
                ?? Defaults.udpServerEnabled
        udpServerPort =
            UserDefaults.standard.object(forKey: Keys.udpServerPort) as? Int ?? Defaults.udpServerPort
        // Migrate from UserDefaults to Keychain if needed
        let legacyToken = UserDefaults.standard.string(forKey: Keys.udpAuthToken)
        if let legacyToken = legacyToken, !legacyToken.isEmpty {
            // Migrate to Keychain
            do {
                try KeychainService.shared.storeUDPToken(legacyToken)
                UserDefaults.standard.removeObject(forKey: Keys.udpAuthToken)
                udpAuthToken = legacyToken
                AppLogger.shared.log("üîÑ [PreferencesService] Migrated UDP token to secure storage")
            } catch {
                AppLogger.shared.log("‚ö†Ô∏è [PreferencesService] Failed to migrate UDP token: \(error)")
                udpAuthToken = Defaults.udpAuthToken
            }
        } else {
            // Load from Keychain or use default
            do {
                udpAuthToken = try KeychainService.shared.retrieveUDPToken() ?? Defaults.udpAuthToken
            } catch {
                AppLogger.shared.log("‚ö†Ô∏è [PreferencesService] Failed to load UDP token from Keychain: \(error)")
                udpAuthToken = Defaults.udpAuthToken
            }
        }
        udpSessionTimeout =
            UserDefaults.standard.object(forKey: Keys.udpSessionTimeout) as? Int ?? Defaults.udpSessionTimeout

        AppLogger.shared.log(
            "üîß [PreferencesService] Initialized - Protocol: \(communicationProtocol.rawValue), UDP enabled: \(udpServerEnabled)"
        )
    }

    // MARK: - Public Interface

    /// Reset all communication settings to defaults
    func resetCommunicationSettings() {
        communicationProtocol = Defaults.communicationProtocol
        udpServerEnabled = Defaults.udpServerEnabled
        udpServerPort = Defaults.udpServerPort
        udpAuthToken = Defaults.udpAuthToken
        udpSessionTimeout = Defaults.udpSessionTimeout
        AppLogger.shared.log("üîß [PreferencesService] All communication settings reset to defaults")
    }

    /// Reset UDP settings to defaults
    func resetUDPSettings() {
        udpServerEnabled = Defaults.udpServerEnabled
        udpServerPort = Defaults.udpServerPort
        udpAuthToken = Defaults.udpAuthToken // This will trigger secure deletion
        udpSessionTimeout = Defaults.udpSessionTimeout
        AppLogger.shared.log("üîß [PreferencesService] UDP settings reset to defaults")
    }

    /// Validate port is in acceptable range
    func isValidPort(_ port: Int) -> Bool {
        port >= 1024 && port <= 65535
    }

    /// Get current communication configuration as string for logging
    var communicationConfigDescription: String {
        let tokenStatus = udpAuthToken.isEmpty ? "auto-generated" : "custom"
        return "UDP \(udpServerEnabled ? "enabled" : "disabled") on port \(udpServerPort) (secure token: \(tokenStatus))"
    }
}

// MARK: - Convenience Extensions

extension PreferencesService {
    /// Get the currently preferred communication protocol
    var preferredProtocol: CommunicationProtocol {
        communicationProtocol
    }

    /// Check if UDP should be used for communication
    var shouldUseUDP: Bool {
        communicationProtocol == .udp && udpServerEnabled && isValidPort(udpServerPort)
    }

    /// Get the full UDP endpoint URL if enabled
    var udpEndpoint: String? {
        guard udpServerEnabled else { return nil }
        return "127.0.0.1:\(udpServerPort)"
    }

    /// Check if UDP server should be included in Kanata launch arguments
    var shouldUseUDPServer: Bool {
        shouldUseUDP
    }

    /// Get the active communication endpoint based on protocol preference
    var activeEndpoint: String? {
        return udpEndpoint
    }

    /// Get UDP launch arguments for Kanata if UDP is enabled
    var udpLaunchArguments: [String] {
        guard shouldUseUDP else { return [] }

        var args = ["--udp-port", "\(udpServerPort)"]

        // Load token securely for launch arguments
        let secureToken: String
        do {
            secureToken = try KeychainService.shared.retrieveUDPToken() ?? ""
        } catch {
            secureToken = ""
        }

        if !secureToken.isEmpty {
            args.append(contentsOf: ["--udp-auth-token", secureToken])
        }

        if udpSessionTimeout != Defaults.udpSessionTimeout {
            args.append(contentsOf: ["--udp-session-timeout", "\(udpSessionTimeout)"])
        }

        return args
    }

    /// Get communication launch arguments based on protocol preference
    var communicationLaunchArguments: [String] {
        return udpLaunchArguments
    }
}

// MARK: - Thread-Safe Snapshot API

/// Thread-safe snapshot of UDP communication configuration for use from non-MainActor contexts
struct CommunicationSnapshot: Sendable {
    let udpEnabled: Bool
    let udpPort: Int
    let udpAuthToken: String
    let udpSessionTimeout: Int

    /// Check if UDP server should be used based on snapshot values
    var shouldUseUDP: Bool {
        udpEnabled && (1024 ... 65535).contains(udpPort)
    }

    /// Get active UDP endpoint
    var activeEndpoint: String? {
        guard shouldUseUDP else { return nil }
        return "127.0.0.1:\(udpPort)"
    }

    /// Get UDP launch arguments
    var communicationLaunchArguments: [String] {
        guard shouldUseUDP else { return [] }

        var args = ["--udp-port", "\(udpPort)"]

        // Use provided token (from snapshot)
        if !udpAuthToken.isEmpty {
            args.append(contentsOf: ["--udp-auth-token", udpAuthToken])
        }

        if udpSessionTimeout != 1800 { // Default timeout
            args.append(contentsOf: ["--udp-session-timeout", "\(udpSessionTimeout)"])
        }

        return args
    }
}

extension PreferencesService {
    /// Get thread-safe snapshot of UDP communication configuration
    /// Safe to call from any actor context
    nonisolated static func communicationSnapshot() -> CommunicationSnapshot {
        let udpEnabled = UserDefaults.standard.object(forKey: "KeyPath.UDP.ServerEnabled") as? Bool ?? true
        let udpPort = UserDefaults.standard.object(forKey: "KeyPath.UDP.ServerPort") as? Int ?? 37001

        // Load UDP token from Keychain (thread-safe)
        let udpAuthToken: String
        do {
            udpAuthToken = try KeychainService.shared.retrieveUDPToken() ?? ""
        } catch {
            // Fallback to empty string if Keychain fails
            udpAuthToken = ""
        }

        let udpSessionTimeout = UserDefaults.standard.object(forKey: "KeyPath.UDP.SessionTimeout") as? Int ?? 1800

        return CommunicationSnapshot(
            udpEnabled: udpEnabled,
            udpPort: udpPort,
            udpAuthToken: udpAuthToken,
            udpSessionTimeout: udpSessionTimeout
        )
    }
}
