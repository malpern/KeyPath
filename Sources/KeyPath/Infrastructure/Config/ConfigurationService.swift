import ApplicationServices
import Foundation
import IOKit.hidsystem
import Network
import SwiftUI

// MARK: - Kanata Configuration Model

/// Represents Kanata configuration data and metadata
public struct KanataConfiguration: Sendable {
    public let content: String
    public let keyMappings: [KeyMapping]
    public let lastModified: Date
    public let path: String

    public init(content: String, keyMappings: [KeyMapping], lastModified: Date, path: String) {
        self.content = content
        self.keyMappings = keyMappings
        self.lastModified = lastModified
        self.path = path
    }

    /// Generate configuration content from key mappings
    public static func generateFromMappings(_ mappings: [KeyMapping]) -> String {
        guard !mappings.isEmpty else {
            return defaultEmptyConfig
        }

        let sourceKeys = mappings.map { KanataKeyConverter.convertToKanataKey($0.input) }.joined(separator: " ")
        let layerKeys = mappings.map { KanataKeyConverter.convertToKanataSequence($0.output) }.joined(separator: " ")

        return """
        ;; Generated by KeyPath
        ;; \(mappings.count) key mapping(s) configured
        ;;
        ;; SAFETY FEATURES:
        ;; - process-unmapped-keys yes: Unmapped keys pass through (safer defaults)

        (defcfg
          process-unmapped-keys yes
        )

        (defsrc
          \(sourceKeys)
        )

        (deflayer base
          \(layerKeys)
        )
        """
    }

    private static let defaultEmptyConfig = """
    ;; Generated by KeyPath
    ;; No key mappings configured
    ;;
    ;; SAFETY FEATURES:
    ;; - process-unmapped-keys yes: Unmapped keys pass through (safer defaults)

    (defcfg
      process-unmapped-keys yes
    )

    (defsrc)
    (deflayer base)
    """
}

// MARK: - Configuration Service

/// Centralized configuration management service for Kanata
///
/// This service handles all configuration-related operations:
/// - Loading and saving configuration files
/// - Validation via UDP and file-based checks
/// - File watching and change detection
/// - Key mapping generation and conversion
@MainActor public final class ConfigurationService: FileConfigurationProviding {
    public typealias Config = KanataConfiguration

    // MARK: - Properties

    public let configurationPath: String
    public let configDirectory: String
    public let configFileName = "keypath.kbd"

    private var currentConfiguration: KanataConfiguration?
    private var fileWatcher: FileWatcher?
    private var observers: [@Sendable (Config) async -> Void] = []

    // MARK: - Initialization

    public init(configDirectory: String? = nil) {
        if let customDirectory = configDirectory {
            self.configDirectory = customDirectory
        } else {
            self.configDirectory = "\(NSHomeDirectory())/.config/keypath"
        }
        configurationPath = "\(self.configDirectory)/\(configFileName)"
    }

    // MARK: - ConfigurationProviding Protocol

    public func current() async -> KanataConfiguration {
        if let config = currentConfiguration {
            return config
        }

        // Try to load existing configuration, fallback to empty if not found
        do {
            let config = try await reload()
            return config
        } catch {
            AppLogger.shared.log("‚ö†Ô∏è [ConfigService] Failed to load current config, using empty: \(error)")
            let emptyConfig = KanataConfiguration(
                content: KanataConfiguration.generateFromMappings([]),
                keyMappings: [],
                lastModified: Date(),
                path: configurationPath
            )
            currentConfiguration = emptyConfig
            return emptyConfig
        }
    }

    public func reload() async throws -> KanataConfiguration {
        guard FileManager.default.fileExists(atPath: configurationPath) else {
            throw KeyPathError.configuration(.fileNotFound(path: configurationPath))
        }

        do {
            let content = try String(contentsOfFile: configurationPath, encoding: .utf8)
            let config = try validate(content: content)
            currentConfiguration = config

            // Notify observers
            for observer in observers {
                await observer(config)
            }

            return config
        } catch let error as KeyPathError {
            throw error
        } catch {
            throw KeyPathError.configuration(.loadFailed(reason: error.localizedDescription))
        }
    }

    public func observe(_ onChange: @Sendable @escaping (Config) async -> Void) -> ConfigurationObservationToken {
        observers.append(onChange)
        let index = observers.count - 1

        return ConfigurationObservationToken {
            self.observers.remove(at: index)
        }
    }

    // MARK: - FileConfigurationProviding Protocol

    public func validate(content: String) throws -> KanataConfiguration {
        // Basic validation - ensure content is not empty
        guard !content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            throw KeyPathError.configuration(.invalidFormat(details: "Configuration content is empty"))
        }

        // Get file modification date
        let attributes = try? FileManager.default.attributesOfItem(atPath: configurationPath)
        let lastModified = (attributes?[.modificationDate] as? Date) ?? Date()

        // Extract key mappings from content (simplified - could be enhanced)
        let keyMappings = extractKeyMappingsFromContent(content)

        return KanataConfiguration(
            content: content,
            keyMappings: keyMappings,
            lastModified: lastModified,
            path: configurationPath
        )
    }

    public func startFileMonitoring() -> ConfigurationObservationToken {
        guard fileWatcher == nil else {
            // Already monitoring
            return ConfigurationObservationToken { /* no-op */ }
        }

        fileWatcher = FileWatcher(path: configurationPath) { [weak self] in
            Task { @MainActor in
                await self?.handleFileChange()
            }
        }

        return ConfigurationObservationToken { [weak self] in
            self?.stopFileMonitoring()
        }
    }

    // MARK: - Configuration Management

    /// Create the configuration directory and initial config if needed
    public func createInitialConfigIfNeeded() async throws {
        // Create config directory if it doesn't exist
        try FileManager.default.createDirectory(
            atPath: configDirectory, withIntermediateDirectories: true, attributes: [.posixPermissions: 0o755]
        )
        AppLogger.shared.log("‚úÖ [ConfigService] Config directory created at \(configDirectory)")

        // Check if config file exists
        let exists = FileManager.default.fileExists(atPath: configurationPath)
        if !exists {
            AppLogger.shared.log("‚ö†Ô∏è [ConfigService] No existing config found at \(configurationPath)")

            // Create empty configuration
            try await saveConfiguration(keyMappings: [])
            AppLogger.shared.log("‚úÖ [ConfigService] Created initial empty configuration")
        } else {
            AppLogger.shared.log("‚úÖ [ConfigService] Existing config found at \(configurationPath)")
        }
    }

    /// Save configuration with key mappings
    public func saveConfiguration(keyMappings: [KeyMapping]) async throws {
        let configContent = KanataConfiguration.generateFromMappings(keyMappings)
        try configContent.write(toFile: configurationPath, atomically: true, encoding: .utf8)

        // Update current configuration
        let newConfig = KanataConfiguration(
            content: configContent,
            keyMappings: keyMappings,
            lastModified: Date(),
            path: configurationPath
        )
        currentConfiguration = newConfig

        // Notify observers
        for observer in observers {
            await observer(newConfig)
        }

        AppLogger.shared.log("‚úÖ [ConfigService] Configuration saved with \(keyMappings.count) mappings")
    }

    /// Save configuration with specific input/output mapping
    public func saveConfiguration(input: String, output: String) async throws {
        let keyMapping = KeyMapping(input: input, output: output)
        try await saveConfiguration(keyMappings: [keyMapping])
    }

    // MARK: - Validation

    /// Validate configuration via UDP with authentication and timeout
    public func validateConfigViaUDP() async -> (isValid: Bool, errors: [String])? {
        do {
            let config = await current()
            let commConfig = PreferencesService.communicationSnapshot()
            let client = KanataUDPClient(port: commConfig.udpPort)

            // Authenticate first
            let authToken = commConfig.udpAuthToken.isEmpty ? nil : commConfig.udpAuthToken
            guard let token = authToken else {
                AppLogger.shared.log("‚ö†Ô∏è [ConfigService] No UDP auth token available for validation")
                return nil
            }

            guard await client.authenticate(token: token) else {
                AppLogger.shared.log("‚ùå [ConfigService] UDP authentication failed for validation")
                return nil
            }

            // Use proper async timeout with Task cancellation
            let udpResult = try await withThrowingTaskGroup(of: UDPValidationResult.self) { group in
                group.addTask { @Sendable in
                    await client.validateConfig(config.content)
                }

                group.addTask { @Sendable in
                    try await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds
                    return UDPValidationResult.networkError("Validation timeout")
                }

                return try await group.next()!
            }

            switch udpResult {
            case .success:
                return (true, [])
            case let .failure(errors: configErrors):
                let errorMessages = configErrors.map { "Line \($0.line):\($0.column) - \($0.message)" }
                return (false, errorMessages)
            case .authenticationRequired:
                AppLogger.shared.log("‚ùå [ConfigService] UDP validation requires re-authentication")
                return nil
            case let .networkError(message):
                AppLogger.shared.log("‚ùå [ConfigService] UDP validation network error: \(message)")
                return nil
            }

        } catch {
            AppLogger.shared.log("‚ö†Ô∏è [ConfigService] UDP validation failed with error: \(error)")
            return nil
        }
    }

    /// Validate configuration via file-based check
    public func validateConfigViaFile() -> (isValid: Bool, errors: [String]) {
        let task = Process()
        task.executableURL = URL(fileURLWithPath: WizardSystemPaths.kanataActiveBinary)
        task.arguments = buildKanataArguments(checkOnly: true)

        let pipe = Pipe()
        task.standardOutput = pipe
        task.standardError = pipe

        var errors: [String] = []

        do {
            try task.run()
            task.waitUntilExit()

            let data = pipe.fileHandleForReading.readDataToEndOfFile()
            let output = String(data: data, encoding: .utf8) ?? ""

            if task.terminationStatus == 0 {
                AppLogger.shared.log("‚úÖ [ConfigService] File validation passed")
                return (true, [])
            } else {
                // Parse errors from output
                let lines = output.components(separatedBy: .newlines)
                for line in lines where !line.isEmpty && (line.contains("error") || line.contains("Error")) {
                    errors.append(line.trimmingCharacters(in: .whitespaces))
                }

                if errors.isEmpty {
                    errors.append("Configuration validation failed (exit code: \(task.terminationStatus))")
                }

                AppLogger.shared.log("‚ùå [ConfigService] File validation failed: \(errors)")
                return (false, errors)
            }

        } catch {
            AppLogger.shared.log("‚ùå [ConfigService] File validation error: \(error)")
            return (false, ["Failed to validate configuration file: \(error.localizedDescription)"])
        }
    }

    /// Validate configuration content with combined UDP + CLI validation
    /// Tries UDP first (fast, live server), falls back to CLI validation if UDP unavailable
    public func validateConfiguration(_ config: String) async -> (isValid: Bool, errors: [String]) {
        AppLogger.shared.log("üîç [Validation] ========== CONFIG VALIDATION START ==========")
        AppLogger.shared.log("üîç [Validation] Config size: \(config.count) characters")

        // First try UDP validation if server is available
        let commConfig = PreferencesService.communicationSnapshot()
        if commConfig.shouldUseUDP {
            let udpPort = commConfig.udpPort
            AppLogger.shared.log("üì° [Validation] UDP port configured: \(udpPort)")
            let udpClient = KanataUDPClient(port: udpPort)

            // Check if UDP server is available
            AppLogger.shared.log("üì° [Validation] Checking UDP server availability on port \(udpPort)...")
            if await udpClient.checkServerStatus() {
                AppLogger.shared.log("üì° [Validation] UDP server is AVAILABLE, using UDP validation")
                let udpStart = Date()
                let result = await udpClient.validateConfig(config)
                let udpDuration = Date().timeIntervalSince(udpStart)
                AppLogger.shared.log(
                    "‚è±Ô∏è [Validation] UDP validation completed in \(String(format: "%.3f", udpDuration)) seconds"
                )

                switch result {
                case .success:
                    AppLogger.shared.log("‚úÖ [Validation] UDP validation PASSED")
                    AppLogger.shared.log("üîç [Validation] ========== CONFIG VALIDATION END ==========")
                    return (true, [])
                case let .failure(udpErrors):
                    AppLogger.shared.log("‚ùå [Validation] UDP validation FAILED with \(udpErrors.count) errors:")
                    let errorStrings = udpErrors.map(\.description)
                    for (index, error) in errorStrings.enumerated() {
                        AppLogger.shared.log("   Error \(index + 1): \(error)")
                    }
                    AppLogger.shared.log("üîç [Validation] ========== CONFIG VALIDATION END ==========")
                    return (false, errorStrings)
                case let .networkError(error):
                    AppLogger.shared.log("‚ö†Ô∏è [Validation] UDP validation network error: \(error)")
                    AppLogger.shared.log("‚ö†Ô∏è [Validation] Falling back to CLI validation...")
                // Fall through to CLI validation
                case .authenticationRequired:
                    AppLogger.shared.log("‚ö†Ô∏è [Validation] UDP authentication required")
                    AppLogger.shared.log("‚ö†Ô∏è [Validation] Falling back to CLI validation...")
                    // Fall through to CLI validation
                }
            } else {
                AppLogger.shared.log("‚ö†Ô∏è [Validation] UDP server NOT available on port \(udpPort)")
                AppLogger.shared.log("‚ö†Ô∏è [Validation] Falling back to CLI validation...")
            }
        } else {
            AppLogger.shared.log("‚ÑπÔ∏è [Validation] No UDP port configured or UDP disabled")
            AppLogger.shared.log("‚ÑπÔ∏è [Validation] Using CLI validation as primary method")
        }

        // Fallback to CLI validation
        AppLogger.shared.log("üñ•Ô∏è [Validation] Starting CLI validation...")
        let cliResult = await validateConfigWithCLI(config)
        AppLogger.shared.log("üîç [Validation] ========== CONFIG VALIDATION END ==========")
        return cliResult
    }

    /// Validate configuration via CLI (kanata --check)
    private func validateConfigWithCLI(_ config: String) async -> (isValid: Bool, errors: [String]) {
        AppLogger.shared.log("üñ•Ô∏è [Validation-CLI] Starting CLI validation process...")

        // Write config to a temporary file for validation
        let tempConfigPath = "\(configDirectory)/temp_validation.kbd"
        AppLogger.shared.log("üìù [Validation-CLI] Creating temp config file: \(tempConfigPath)")

        do {
            let tempConfigURL = URL(fileURLWithPath: tempConfigPath)
            let configDir = URL(fileURLWithPath: configDirectory)
            try FileManager.default.createDirectory(at: configDir, withIntermediateDirectories: true)
            try config.write(to: tempConfigURL, atomically: true, encoding: .utf8)
            AppLogger.shared.log("üìù [Validation-CLI] Temp config written successfully (\(config.count) characters)")

            // Use kanata --check to validate
            let kanataBinary = WizardSystemPaths.kanataActiveBinary
            AppLogger.shared.log("üîß [Validation-CLI] Using kanata binary: \(kanataBinary)")

            let task = Process()
            task.executableURL = URL(fileURLWithPath: kanataBinary)
            let arguments = ["--cfg", tempConfigPath, "--check"]
            task.arguments = arguments
            AppLogger.shared.log("üîß [Validation-CLI] Command: \(kanataBinary) \(arguments.joined(separator: " "))")

            let pipe = Pipe()
            task.standardOutput = pipe
            task.standardError = pipe

            let cliStart = Date()
            try task.run()
            task.waitUntilExit()
            let cliDuration = Date().timeIntervalSince(cliStart)
            AppLogger.shared.log(
                "‚è±Ô∏è [Validation-CLI] CLI validation completed in \(String(format: "%.3f", cliDuration)) seconds"
            )

            let data = pipe.fileHandleForReading.readDataToEndOfFile()
            let output = String(data: data, encoding: .utf8) ?? ""

            AppLogger.shared.log("üìã [Validation-CLI] Exit code: \(task.terminationStatus)")
            if !output.isEmpty {
                AppLogger.shared.log("üìã [Validation-CLI] Output: \(output.prefix(500))...")
            }

            // Clean up temp file
            try? FileManager.default.removeItem(at: tempConfigURL)
            AppLogger.shared.log("üóëÔ∏è [Validation-CLI] Temp file cleaned up")

            if task.terminationStatus == 0 {
                AppLogger.shared.log("‚úÖ [Validation-CLI] CLI validation PASSED")
                return (true, [])
            } else {
                let errors = parseKanataErrors(output)
                AppLogger.shared.log("‚ùå [Validation-CLI] CLI validation FAILED with \(errors.count) errors:")
                for (index, error) in errors.enumerated() {
                    AppLogger.shared.log("   Error \(index + 1): \(error)")
                }
                return (false, errors)
            }
        } catch {
            // Clean up temp file on error
            try? FileManager.default.removeItem(atPath: tempConfigPath)
            AppLogger.shared.log("‚ùå [Validation-CLI] Validation process failed: \(error)")
            AppLogger.shared.log("‚ùå [Validation-CLI] Error type: \(type(of: error))")
            return (false, ["Validation failed: \(error.localizedDescription)"])
        }
    }

    // MARK: - Backup and Recovery

    /// Backs up a failed config and applies safe default, returning backup path
    public func backupFailedConfigAndApplySafe(failedConfig: String, mappings: [KeyMapping]) async throws
        -> String
    {
        AppLogger.shared.log("üõ°Ô∏è [Config] Backing up failed config and applying safe default")

        // Create backup directory if it doesn't exist
        let backupDir = "\(configDirectory)/backups"
        let backupDirURL = URL(fileURLWithPath: backupDir)
        try FileManager.default.createDirectory(at: backupDirURL, withIntermediateDirectories: true)

        // Create timestamped backup filename
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        let timestamp = formatter.string(from: Date())

        let backupPath = "\(backupDir)/failed_config_\(timestamp).kbd"
        let backupURL = URL(fileURLWithPath: backupPath)

        // Write the failed config to backup
        let backupContent = """
        ;; FAILED CONFIG - AUTOMATICALLY BACKED UP
        ;; Timestamp: \(timestamp)
        ;; Errors: \(mappings.count) mapping(s) could not be applied

        \(failedConfig)
        """
        try backupContent.write(to: backupURL, atomically: true, encoding: .utf8)

        AppLogger.shared.log("üíæ [Config] Failed config backed up to: \(backupPath)")

        // Apply safe default config (explicit tokens to keep human-readable form)
        let safeConfig = """
        ;; Generated by KeyPath (Safe Default)
        (defcfg
          process-unmapped-keys yes
        )

        (defsrc
          caps
        )

        (deflayer base
          escape
        )
        """

        let configURL = URL(fileURLWithPath: configurationPath)
        try safeConfig.write(to: configURL, atomically: true, encoding: .utf8)

        AppLogger.shared.log("‚úÖ [Config] Safe default config applied")

        // Update current configuration
        currentConfiguration = KanataConfiguration(
            content: safeConfig,
            keyMappings: [KeyMapping(input: "caps", output: "escape")],
            lastModified: Date(),
            path: configurationPath
        )

        return backupPath
    }

    /// Repair configuration using rule-based strategies
    public func repairConfiguration(config: String, errors: [String], mappings: [KeyMapping]) async throws
        -> String
    {
        AppLogger.shared.log("üîß [Config] Performing rule-based repair for \(errors.count) errors")

        // Common repair strategies
        var repairedConfig = config

        for error in errors {
            let lowerError = error.lowercased()

            // Fix common syntax errors
            if lowerError.contains("missing"), lowerError.contains("defcfg") {
                // Add missing defcfg
                if !repairedConfig.contains("(defcfg") {
                    let defcfgSection = """
                    (defcfg
                      process-unmapped-keys yes
                    )

                    """
                    repairedConfig = defcfgSection + repairedConfig
                }
            }

            // Fix empty parentheses issues
            if lowerError.contains("()") || lowerError.contains("empty") {
                repairedConfig = repairedConfig.replacingOccurrences(of: "()", with: "_")
                repairedConfig = repairedConfig.replacingOccurrences(of: "( )", with: "_")
            }

            // Fix mismatched defsrc/deflayer lengths
            if lowerError.contains("mismatch") || lowerError.contains("length") {
                // Regenerate from scratch using our proven template
                return KanataConfiguration.generateFromMappings(mappings)
            }
        }

        return repairedConfig
    }

    // MARK: - Private Methods

    private func handleFileChange() async {
        AppLogger.shared.log("üìÅ [ConfigService] Configuration file changed - reloading")
        do {
            _ = try await reload()
            AppLogger.shared.log("‚úÖ [ConfigService] Configuration reloaded successfully")
        } catch {
            AppLogger.shared.log("‚ùå [ConfigService] Failed to reload configuration: \(error)")
        }
    }

    private func stopFileMonitoring() {
        fileWatcher = nil
        AppLogger.shared.log("üõë [ConfigService] File monitoring stopped")
    }

    /// Extract key mappings from Kanata configuration content
    private func extractKeyMappingsFromContent(_ configContent: String) -> [KeyMapping] {
        var mappings: [KeyMapping] = []
        let lines = configContent.components(separatedBy: .newlines)

        var inDefsrc = false
        var inDeflayer = false
        var srcKeys: [String] = []
        var layerKeys: [String] = []

        for line in lines {
            let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)

            if trimmed.hasPrefix("(defsrc") {
                inDefsrc = true
                inDeflayer = false
                continue
            } else if trimmed.hasPrefix("(deflayer") {
                inDefsrc = false
                inDeflayer = true
                continue
            } else if trimmed == ")" {
                inDefsrc = false
                inDeflayer = false
                continue
            }

            if inDefsrc, !trimmed.isEmpty, !trimmed.hasPrefix(";") {
                srcKeys.append(
                    contentsOf: trimmed.components(separatedBy: .whitespaces).filter { !$0.isEmpty })
            } else if inDeflayer, !trimmed.isEmpty, !trimmed.hasPrefix(";") {
                layerKeys.append(
                    contentsOf: trimmed.components(separatedBy: .whitespaces).filter { !$0.isEmpty })
            }
        }

        // Match up src and layer keys, filtering out invalid keys
        var tempMappings: [KeyMapping] = []
        for (index, srcKey) in srcKeys.enumerated() where index < layerKeys.count {
            // Skip obviously invalid keys
            if srcKey != "invalid", !srcKey.isEmpty {
                tempMappings.append(KeyMapping(input: srcKey, output: layerKeys[index]))
            }
        }

        // Deduplicate mappings - keep only the last mapping for each input key
        var seenInputs: Set<String> = []
        for mapping in tempMappings.reversed() where !seenInputs.contains(mapping.input) {
            mappings.insert(mapping, at: 0)
            seenInputs.insert(mapping.input)
        }

        AppLogger.shared.log(
            "üîç [Parse] Found \(srcKeys.count) src keys, \(layerKeys.count) layer keys, deduplicated to \(mappings.count) unique mappings"
        )
        return mappings
    }

    private func buildKanataArguments(checkOnly: Bool = false) -> [String] {
        var args = ["--cfg", configurationPath]
        if checkOnly {
            args.append("--check")
        }

        // Add communication protocol arguments only for actual runs (not validation checks)
        if !checkOnly {
            let commConfig = PreferencesService.communicationSnapshot()
            args.append(contentsOf: commConfig.communicationLaunchArguments)
        }

        return args
    }

    /// Parse configuration from string content
    public func parseConfigurationFromString(_ content: String) throws -> KanataConfiguration {
        // Use the existing validate method which handles parsing
        try validate(content: content)
    }

    /// Parse Kanata error output to extract error messages
    public func parseKanataErrors(_ output: String) -> [String] {
        var errors: [String] = []
        let lines = output.components(separatedBy: .newlines)

        for line in lines {
            if line.contains("[ERROR]") {
                // Extract the actual error message
                if let errorRange = line.range(of: "[ERROR]") {
                    let errorMessage = String(line[errorRange.upperBound...]).trimmingCharacters(
                        in: .whitespaces)
                    errors.append(errorMessage)
                }
            }
        }

        // Don't return empty strings - if no specific errors found and output is empty/whitespace,
        // return empty array instead of an array with empty string
        if errors.isEmpty {
            let trimmedOutput = output.trimmingCharacters(in: .whitespacesAndNewlines)
            if !trimmedOutput.isEmpty {
                // If there's non-empty output but no [ERROR] tags, include the full output as error
                errors.append(trimmedOutput)
            }
        }

        return errors
    }
}

// MARK: - Key Conversion Utilities

/// Utility class for converting keys between KeyPath and Kanata formats
public enum KanataKeyConverter {
    /// Convert KeyPath input key to Kanata key format
    public static func convertToKanataKey(_ input: String) -> String {
        // Use the same key mapping logic as the original KanataManager
        let keyMap: [String: String] = [
            "caps": "caps",
            "capslock": "caps",
            "caps lock": "caps",
            "space": "spc",
            "spacebar": "spc",
            "enter": "ret",
            "return": "ret",
            "tab": "tab",
            "escape": "esc",
            "esc": "esc",
            "backspace": "bspc",
            "delete": "del",
            "cmd": "lmet",
            "command": "lmet",
            "lcmd": "lmet",
            "rcmd": "rmet",
            "leftcmd": "lmet",
            "rightcmd": "rmet",
            "left command": "lmet",
            "right command": "rmet",
            "left shift": "lsft",
            "lshift": "lsft",
            "right shift": "rsft",
            "rshift": "rsft",
            "left control": "lctl",
            "lctrl": "lctl",
            "right control": "rctl",
            "rctrl": "rctl",
            "left option": "lalt",
            "lalt": "lalt",
            "right option": "ralt",
            "ralt": "ralt"
        ]

        let lowercased = input.lowercased()

        // Check if we have a specific mapping
        if let mapped = keyMap[lowercased] {
            return mapped
        }

        // For single characters, return as-is
        if lowercased.count == 1 {
            return lowercased
        }

        // For function keys and others, return as-is but lowercased
        return lowercased
    }

    /// Convert KeyPath output sequence to Kanata output format
    public static func convertToKanataSequence(_ output: String) -> String {
        // Handle multi-character sequences
        if output.contains(" ") {
            // Multi-key sequence
            let keys = output.components(separatedBy: " ")
            let kanataKeys = keys.map { convertToKanataKey($0) }
            return "(\(kanataKeys.joined(separator: " ")))"
        } else {
            // Single key
            return convertToKanataKey(output)
        }
    }
}

// MARK: - File Watcher (Simplified)

/// Simple file watcher for configuration changes
private class FileWatcher {
    private let path: String
    private let callback: () -> Void
    private var source: DispatchSourceFileSystemObject?

    init(path: String, callback: @escaping () -> Void) {
        self.path = path
        self.callback = callback
        startWatching()
    }

    deinit {
        stopWatching()
    }

    private func startWatching() {
        let fileDescriptor = open(path, O_RDONLY)
        guard fileDescriptor >= 0 else {
            AppLogger.shared.log("‚ùå [FileWatcher] Could not open file for watching: \(path)")
            return
        }

        source = DispatchSource.makeFileSystemObjectSource(
            fileDescriptor: fileDescriptor,
            eventMask: [.write, .delete, .rename],
            queue: DispatchQueue.global(qos: .utility)
        )

        source?.setEventHandler { [weak self] in
            self?.callback()
        }

        source?.setCancelHandler {
            close(fileDescriptor)
        }

        source?.resume()
    }

    private func stopWatching() {
        source?.cancel()
        source = nil
    }
}
