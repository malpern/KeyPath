import ApplicationServices
import Foundation
import IOKit.hidsystem
import Network
import SwiftUI

// MARK: - Kanata Configuration Model

/// Represents Kanata configuration data and metadata
public struct KanataConfiguration {
    public let content: String
    public let keyMappings: [KeyMapping]
    public let lastModified: Date
    public let path: String

    public init(content: String, keyMappings: [KeyMapping], lastModified: Date, path: String) {
        self.content = content
        self.keyMappings = keyMappings
        self.lastModified = lastModified
        self.path = path
    }

    /// Generate configuration content from key mappings
    public static func generateFromMappings(_ mappings: [KeyMapping]) -> String {
        guard !mappings.isEmpty else {
            return defaultEmptyConfig
        }

        let sourceKeys = mappings.map { KanataKeyConverter.convertToKanataKey($0.input) }.joined(separator: " ")
        let layerKeys = mappings.map { KanataKeyConverter.convertToKanataSequence($0.output) }.joined(separator: " ")

        return """
        ;; Generated by KeyPath
        ;; \(mappings.count) key mapping(s) configured
        ;;
        ;; SAFETY FEATURES:
        ;; - process-unmapped-keys no: Only process explicitly mapped keys

        (defcfg
          process-unmapped-keys no
        )

        (defsrc
          \(sourceKeys)
        )

        (deflayer base
          \(layerKeys)
        )
        """
    }

    private static let defaultEmptyConfig = """
    ;; Generated by KeyPath
    ;; No key mappings configured
    ;;
    ;; SAFETY FEATURES:
    ;; - process-unmapped-keys no: Only process explicitly mapped keys

    (defcfg
      process-unmapped-keys no
    )

    (defsrc)
    (deflayer base)
    """
}

// MARK: - Configuration Service

/// Centralized configuration management service for Kanata
///
/// This service handles all configuration-related operations:
/// - Loading and saving configuration files
/// - Validation via UDP and file-based checks
/// - File watching and change detection
/// - Key mapping generation and conversion
public final class ConfigurationService: FileConfigurationProviding {
    public typealias Config = KanataConfiguration

    // MARK: - Properties

    public let configurationPath: String
    public let configDirectory: String
    public let configFileName = "keypath.kbd"

    private var currentConfiguration: KanataConfiguration?
    private var fileWatcher: FileWatcher?
    private var observers: [(Config) async -> Void] = []

    // MARK: - Initialization

    public init(configDirectory: String? = nil) {
        if let customDirectory = configDirectory {
            self.configDirectory = customDirectory
        } else {
            self.configDirectory = "\(NSHomeDirectory())/.config/keypath"
        }
        configurationPath = "\(self.configDirectory)/\(configFileName)"
    }

    // MARK: - ConfigurationProviding Protocol

    public func current() async -> KanataConfiguration {
        if let config = currentConfiguration {
            return config
        }

        // Try to load existing configuration, fallback to empty if not found
        do {
            let config = try await reload()
            return config
        } catch {
            AppLogger.shared.log("⚠️ [ConfigService] Failed to load current config, using empty: \(error)")
            let emptyConfig = KanataConfiguration(
                content: KanataConfiguration.generateFromMappings([]),
                keyMappings: [],
                lastModified: Date(),
                path: configurationPath
            )
            currentConfiguration = emptyConfig
            return emptyConfig
        }
    }

    public func reload() async throws -> KanataConfiguration {
        guard FileManager.default.fileExists(atPath: configurationPath) else {
            throw ConfigurationError.fileNotFound(configurationPath)
        }

        do {
            let content = try String(contentsOfFile: configurationPath, encoding: .utf8)
            let config = try validate(content: content)
            currentConfiguration = config

            // Notify observers
            for observer in observers {
                await observer(config)
            }

            return config
        } catch let error as ConfigurationError {
            throw error
        } catch {
            throw ConfigurationError.loadFailed(error.localizedDescription)
        }
    }

    public func observe(_ onChange: @escaping (Config) async -> Void) -> ConfigurationObservationToken {
        observers.append(onChange)
        let index = observers.count - 1

        return ConfigurationObservationToken {
            self.observers.remove(at: index)
        }
    }

    // MARK: - FileConfigurationProviding Protocol

    public func validate(content: String) throws -> KanataConfiguration {
        // Basic validation - ensure content is not empty
        guard !content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            throw ConfigurationError.invalidFormat("Configuration content is empty")
        }

        // Get file modification date
        let attributes = try FileManager.default.attributesOfItem(atPath: configurationPath)
        let lastModified = attributes[.modificationDate] as? Date ?? Date()

        // Extract key mappings from content (simplified - could be enhanced)
        let keyMappings = extractKeyMappingsFromContent(content)

        return KanataConfiguration(
            content: content,
            keyMappings: keyMappings,
            lastModified: lastModified,
            path: configurationPath
        )
    }

    public func startFileMonitoring() -> ConfigurationObservationToken {
        guard fileWatcher == nil else {
            // Already monitoring
            return ConfigurationObservationToken { /* no-op */ }
        }

        fileWatcher = FileWatcher(path: configurationPath) { [weak self] in
            Task {
                await self?.handleFileChange()
            }
        }

        return ConfigurationObservationToken { [weak self] in
            self?.stopFileMonitoring()
        }
    }

    // MARK: - Configuration Management

    /// Create the configuration directory and initial config if needed
    public func createInitialConfigIfNeeded() async throws {
        // Create config directory if it doesn't exist
        try FileManager.default.createDirectory(
            atPath: configDirectory, withIntermediateDirectories: true, attributes: [.posixPermissions: 0o755]
        )
        AppLogger.shared.log("✅ [ConfigService] Config directory created at \(configDirectory)")

        // Check if config file exists
        let exists = FileManager.default.fileExists(atPath: configurationPath)
        if !exists {
            AppLogger.shared.log("⚠️ [ConfigService] No existing config found at \(configurationPath)")

            // Create empty configuration
            try await saveConfiguration(keyMappings: [])
            AppLogger.shared.log("✅ [ConfigService] Created initial empty configuration")
        } else {
            AppLogger.shared.log("✅ [ConfigService] Existing config found at \(configurationPath)")
        }
    }

    /// Save configuration with key mappings
    public func saveConfiguration(keyMappings: [KeyMapping]) async throws {
        let configContent = KanataConfiguration.generateFromMappings(keyMappings)
        try configContent.write(toFile: configurationPath, atomically: true, encoding: .utf8)

        // Update current configuration
        let newConfig = KanataConfiguration(
            content: configContent,
            keyMappings: keyMappings,
            lastModified: Date(),
            path: configurationPath
        )
        currentConfiguration = newConfig

        // Notify observers
        for observer in observers {
            await observer(newConfig)
        }

        AppLogger.shared.log("✅ [ConfigService] Configuration saved with \(keyMappings.count) mappings")
    }

    /// Save configuration with specific input/output mapping
    public func saveConfiguration(input: String, output: String) async throws {
        let keyMapping = KeyMapping(input: input, output: output)
        try await saveConfiguration(keyMappings: [keyMapping])
    }

    // MARK: - Validation

    /// Validate configuration via UDP with authentication and timeout
    public func validateConfigViaUDP() async -> (isValid: Bool, errors: [String])? {
        do {
            let config = await current()
            let commConfig = PreferencesService.communicationSnapshot()
            let client = KanataUDPClient(port: commConfig.udpPort)

            // Authenticate first
            let authToken = commConfig.udpAuthToken.isEmpty ? nil : commConfig.udpAuthToken
            guard let token = authToken else {
                AppLogger.shared.log("⚠️ [ConfigService] No UDP auth token available for validation")
                return nil
            }

            guard await client.authenticate(token: token) else {
                AppLogger.shared.log("❌ [ConfigService] UDP authentication failed for validation")
                return nil
            }

            // Use proper async timeout with Task cancellation
            let udpResult = try await withThrowingTaskGroup(of: UDPValidationResult.self) { group in
                group.addTask {
                    await client.validateConfig(config.content)
                }

                group.addTask {
                    try await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds
                    return UDPValidationResult.networkError("Validation timeout")
                }

                return try await group.next()!
            }

            switch udpResult {
            case .success:
                return (true, [])
            case let .failure(errors: configErrors):
                let errorMessages = configErrors.map { "Line \($0.line):\($0.column) - \($0.message)" }
                return (false, errorMessages)
            case .authenticationRequired:
                AppLogger.shared.log("❌ [ConfigService] UDP validation requires re-authentication")
                return nil
            case let .networkError(message):
                AppLogger.shared.log("❌ [ConfigService] UDP validation network error: \(message)")
                return nil
            }

        } catch {
            AppLogger.shared.log("⚠️ [ConfigService] UDP validation failed with error: \(error)")
            return nil
        }
    }

    /// Validate configuration via file-based check
    public func validateConfigViaFile() -> (isValid: Bool, errors: [String]) {
        let task = Process()
        task.executableURL = URL(fileURLWithPath: WizardSystemPaths.kanataActiveBinary)
        task.arguments = buildKanataArguments(checkOnly: true)

        let pipe = Pipe()
        task.standardOutput = pipe
        task.standardError = pipe

        var errors: [String] = []

        do {
            try task.run()
            task.waitUntilExit()

            let data = pipe.fileHandleForReading.readDataToEndOfFile()
            let output = String(data: data, encoding: .utf8) ?? ""

            if task.terminationStatus == 0 {
                AppLogger.shared.log("✅ [ConfigService] File validation passed")
                return (true, [])
            } else {
                // Parse errors from output
                let lines = output.components(separatedBy: .newlines)
                for line in lines where !line.isEmpty && (line.contains("error") || line.contains("Error")) {
                    errors.append(line.trimmingCharacters(in: .whitespaces))
                }

                if errors.isEmpty {
                    errors.append("Configuration validation failed (exit code: \(task.terminationStatus))")
                }

                AppLogger.shared.log("❌ [ConfigService] File validation failed: \(errors)")
                return (false, errors)
            }

        } catch {
            AppLogger.shared.log("❌ [ConfigService] File validation error: \(error)")
            return (false, ["Failed to validate configuration file: \(error.localizedDescription)"])
        }
    }

    // MARK: - Private Methods

    private func handleFileChange() async {
        AppLogger.shared.log("📁 [ConfigService] Configuration file changed - reloading")
        do {
            _ = try await reload()
            AppLogger.shared.log("✅ [ConfigService] Configuration reloaded successfully")
        } catch {
            AppLogger.shared.log("❌ [ConfigService] Failed to reload configuration: \(error)")
        }
    }

    private func stopFileMonitoring() {
        fileWatcher = nil
        AppLogger.shared.log("🛑 [ConfigService] File monitoring stopped")
    }

    private func extractKeyMappingsFromContent(_: String) -> [KeyMapping] {
        // Simplified key mapping extraction
        // This would need to be enhanced to fully parse Kanata config format
        // For now, return empty array as this is primarily used for round-trip scenarios
        return []
    }

    private func buildKanataArguments(checkOnly: Bool = false) -> [String] {
        var args = ["--cfg", configurationPath]
        if checkOnly {
            args.append("--check")
        }

        // Add communication protocol arguments only for actual runs (not validation checks)
        if !checkOnly {
            let commConfig = PreferencesService.communicationSnapshot()
            args.append(contentsOf: commConfig.communicationLaunchArguments)
        }

        return args
    }

    /// Parse configuration from string content
    public func parseConfigurationFromString(_ content: String) throws -> KanataConfiguration {
        // Use the existing validate method which handles parsing
        return try validate(content: content)
    }

    /// Parse Kanata error output to extract error messages
    public func parseKanataErrors(_ output: String) -> [String] {
        var errors: [String] = []
        let lines = output.components(separatedBy: .newlines)

        for line in lines {
            if line.contains("[ERROR]") {
                // Extract the actual error message
                if let errorRange = line.range(of: "[ERROR]") {
                    let errorMessage = String(line[errorRange.upperBound...]).trimmingCharacters(
                        in: .whitespaces)
                    errors.append(errorMessage)
                }
            }
        }

        // Don't return empty strings - if no specific errors found and output is empty/whitespace,
        // return empty array instead of an array with empty string
        if errors.isEmpty {
            let trimmedOutput = output.trimmingCharacters(in: .whitespacesAndNewlines)
            if !trimmedOutput.isEmpty {
                // If there's non-empty output but no [ERROR] tags, include the full output as error
                errors.append(trimmedOutput)
            }
        }

        return errors
    }
}

// MARK: - Key Conversion Utilities

/// Utility class for converting keys between KeyPath and Kanata formats
public enum KanataKeyConverter {
    /// Convert KeyPath input key to Kanata key format
    public static func convertToKanataKey(_ input: String) -> String {
        // Use the same key mapping logic as the original KanataManager
        let keyMap: [String: String] = [
            "caps": "caps",
            "capslock": "caps",
            "caps lock": "caps",
            "space": "spc",
            "spacebar": "spc",
            "enter": "ret",
            "return": "ret",
            "tab": "tab",
            "escape": "esc",
            "esc": "esc",
            "backspace": "bspc",
            "delete": "del",
            "cmd": "lmet",
            "command": "lmet",
            "lcmd": "lmet",
            "rcmd": "rmet",
            "leftcmd": "lmet",
            "rightcmd": "rmet",
            "left command": "lmet",
            "right command": "rmet",
            "left shift": "lsft",
            "lshift": "lsft",
            "right shift": "rsft",
            "rshift": "rsft",
            "left control": "lctl",
            "lctrl": "lctl",
            "right control": "rctl",
            "rctrl": "rctl",
            "left option": "lalt",
            "lalt": "lalt",
            "right option": "ralt",
            "ralt": "ralt"
        ]

        let lowercased = input.lowercased()

        // Check if we have a specific mapping
        if let mapped = keyMap[lowercased] {
            return mapped
        }

        // For single characters, return as-is
        if lowercased.count == 1 {
            return lowercased
        }

        // For function keys and others, return as-is but lowercased
        return lowercased
    }

    /// Convert KeyPath output sequence to Kanata output format
    public static func convertToKanataSequence(_ output: String) -> String {
        // Handle multi-character sequences
        if output.contains(" ") {
            // Multi-key sequence
            let keys = output.components(separatedBy: " ")
            let kanataKeys = keys.map { convertToKanataKey($0) }
            return "(\(kanataKeys.joined(separator: " ")))"
        } else {
            // Single key
            return convertToKanataKey(output)
        }
    }
}

// MARK: - File Watcher (Simplified)

/// Simple file watcher for configuration changes
private class FileWatcher {
    private let path: String
    private let callback: () -> Void
    private var source: DispatchSourceFileSystemObject?

    init(path: String, callback: @escaping () -> Void) {
        self.path = path
        self.callback = callback
        startWatching()
    }

    deinit {
        stopWatching()
    }

    private func startWatching() {
        let fileDescriptor = open(path, O_RDONLY)
        guard fileDescriptor >= 0 else {
            AppLogger.shared.log("❌ [FileWatcher] Could not open file for watching: \(path)")
            return
        }

        source = DispatchSource.makeFileSystemObjectSource(
            fileDescriptor: fileDescriptor,
            eventMask: [.write, .delete, .rename],
            queue: DispatchQueue.global(qos: .utility)
        )

        source?.setEventHandler { [weak self] in
            self?.callback()
        }

        source?.setCancelHandler {
            close(fileDescriptor)
        }

        source?.resume()
    }

    private func stopWatching() {
        source?.cancel()
        source = nil
    }
}
